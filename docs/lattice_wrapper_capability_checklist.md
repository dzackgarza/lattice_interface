# Documented Mathematical Capability Checklist

PURPOSE OF THIS DOCUMENT: group ALL methods in checklists into extremely fine-grained buckets to define the new lattice interface.
It should have every *capability* reflected in the union of methods in checklists for all lattice-related tools, but e.g. if both Julia and Sage define LLL algorithms, they should be placed in the same bucket, since the new interface only needs *one* LLL computation method.

## Bridge Design Requirement
Number-field capabilities in this checklist impose a required interface-design bridge via trace-form constructions.
The wrapper design is incomplete unless it explicitly supports number-field to lattice integration end-to-end (construction plus downstream lattice algorithms through the same standardized interface paths).
Number-field method coverage should be treated as defining required wrapper capabilities, not optional/reference-only items.
Minimum required bridge surface in the new wrapper: a dedicated constructor capability (for example `from_number_field_order(...)` / `from_ring_of_integers_ideal(...)`) that materializes a lattice from number-field arithmetic data and then exposes the standard lattice API path.

### Required constructor capabilities for the bridge

- [ ] `from_number_field_order` - Input: an order $\mathcal O\subset K$. Output: lattice on $\mathcal O$ with Gram matrix

$$
G_{ij}=\operatorname{Tr}_{K/\mathbf Q}(b_i b_j)
$$
for an integral $\mathbf Z$-basis $(b_i)$ of $\mathcal O$.

- [ ] `from_ring_of_integers_ideal` - Input: fractional/ integral ideal $I\subset K$. Output: lattice on $I$ with Gram matrix

$$
G_{ij}=\operatorname{Tr}_{K/\mathbf Q}(b_i b_j)
$$
for a $\mathbf Z$-basis $(b_i)$ of $I$.

## Lattices over $\mathbf{Z}$

### Lattice construction from standard models
Constructs lattices from defining matrices/bases and from named families (root-lattice constructors and hyperbolic-plane constructors).

- [ ] `constructor("U")` - In `IntegralLattice`, the string input `\"U\"` (or `\"H\"`) sets the inner-product matrix to $\begin{pmatrix}0&1\\1&0\end{pmatrix}$, i.e. the rank-$2$ hyperbolic plane over $\mathbf Z$. [sources: sage/modules/free_quadratic_module_integer_symmetric.py::IntegralLattice (data==\"U\" or \"H\" branch), sage_doc/test_integrallattice_static.py::test_integrallattice_constructor_u_hyperbolic_plane]
- [ ] `integer_lattice` - Constructor for an integral lattice over $\mathbf Z$: from Gram data (`integer_lattice(gram=G)`) or from basis plus Gram data (`integer_lattice(B; gram=G)`), with documented contract $\operatorname{gram\_matrix}(L)=G$ and $\operatorname{rank}(L)=\mathrm{rows}(G)$. [sources: julia_doc/test_zzlat_construction.jl::\"integer_lattice: construct from Gram matrix\", julia_doc/test_zzlat_construction.jl::\"integer_lattice: construct from basis and Gram\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_integer_lattice]
- [ ] `lattice` - Constructor in ambient quadratic space: for $V$ and basis/generator matrix $B$, `lattice(V,B)` returns the corresponding lattice in $V$ (tested contract includes $\operatorname{rank}(L)=2$ for the 2D example). [sources: julia_doc/test_zzlat_construction.jl::\"lattice: construct in quadratic space\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_lattice]
- [ ] `quadratic_lattice` - Constructs a lattice in a quadratic space over the base field from generators and explicit Gram data; verified example over $\mathbf Q$ has $\operatorname{rank}(L)=2$ and $\det(L)=4$. [sources: julia_doc/test_zzlat_construction.jl::\"quadratic_lattice: construct from generators and Gram\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_quadratic_lattice]
- [ ] `root_lattice` - Returns the integral root-space realization `root_space(ZZ)`, i.e. root lattice $Q=\bigoplus_{i\in I}\mathbf Z\,\alpha_i$ with $\operatorname{rank}(Q)=|I|$. [sources: sage/combinat/root_system/root_system.py::root_lattice, sage_doc/test_rootsystem_static.py::test_rootsystem_cartan_type_rank_matches_lattice_dimension]
- [ ] `hyperbolic_plane_lattice` - Returns the hyperbolic plane constructor (`hyperbolic_plane_lattice(n)` in docs; unscaled call in tests), with checked invariants $\operatorname{sig}(L)=(1,1)$ and $\det(L)=-1$ for the unscaled case. [sources: docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md::2.3, julia_doc/test_zzlat_construction.jl::\"hyperbolic_plane_lattice: signature (1,1)\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_hyperbolic_plane_lattice]
- [ ] `lattice_in_same_ambient_space` - Given ambient lattice $L$ and basis matrix $B$ in the same ambient space, returns the sublattice generated by rows of $B$ without changing ambient space. [sources: docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md::2.9, julia_doc/test_zzlat_module_ops.jl::\"lattice_in_same_ambient_space: sublattice construction\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_lattice_in_same_ambient_space]

### Lattice/space rank and dimension
Returns lattice/genus dimension invariants.

- [ ] `dimension` - For a genus object, returns $p+n$ where $(p,n)=\texttt{signature\_pair()}$; equivalently the common matrix size/rank of representatives. [sources: sage/quadratic_forms/genera/genus.py::GenusSymbol_global_ring.dimension, sage_doc/test_genus_static.py::test_genus_dimension_matches_representative_size]
- [ ] `dim` - Direct alias assignment `dim = dimension` on genus objects, hence same invariant as `dimension`/`rank`. [sources: sage/quadratic_forms/genera/genus.py::GenusSymbol_global_ring (dim alias), sage_doc/test_genus_static.py::test_genus_dim_and_dimension_aliases_match_rank]

### Lattice signature invariant
For a real quadratic space $(V,q)$, the signature is $(n_+,n_-)$ with $n_++n_-=\dim V$.

- [ ] `signature` - If the real form is equivalent to $\langle 1\rangle^{\oplus p}\oplus\langle -1\rangle^{\oplus n}$, then `signature` returns $p-n$ (difference of positive and negative indices of inertia). [source: sage_doc/test_genus_static.py::test_genus_signature_is_difference_of_signature_pair]
- [ ] `signature_pair` - Returns $(p,n)$ where $p$ (resp. $n$) is the number of positive (resp. negative) eigenvalues of a real Gram matrix; for nonsingular forms, $p+n=\operatorname{rank}$. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_signature_pair_for_indefinite_form]
- [ ] `signature_tuple` - Returns $(p,n,z)$ such that over $\mathbf R$ the form is congruent to $\langle 1\rangle^{\oplus p}\oplus\langle -1\rangle^{\oplus n}\oplus\langle 0\rangle^{\oplus z}$; documented examples include $(2,0,0)$ for $A_2$ and $(1,1,0)$ for $U$. [sources: julia_doc/test_zzlat_attributes.jl::\"signature_tuple: positive definite A2\", julia_doc/test_zzlat_attributes.jl::\"signature_tuple: indefinite hyperbolic plane\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_signature_tuple]
- [ ] `signature_pair_of_matrix` - Matrix-level alias for the same inertia pair $(p,n)$ returned by `signature_pair`, computed from a real symmetric representative matrix. [source: sage_doc/test_genus_static.py::test_genus_signature_pair_of_matrix_alias]

### Lattice covolume invariant
The covolume is $\operatorname{vol}(L)=\sqrt{|\det(G)|}$ in Euclidean normalization.

- [ ] `volume` - Implementation computes $\sqrt{\det(BB^T)}$ for a basis matrix $B$: full-rank branch returns $|\det(B)|$, non-full-rank branch returns $\sqrt{\det(G)}$ for Gram matrix $G=BB^T$. [sources: sage/modules/free_module_integer.py::volume, sage_doc/test_integerlattice_static.py::test_integerlattice_volume_square_matches_discriminant]

### Lattice scale invariant
Computes the scale ideal $\mathfrak s(L)=\langle (x,y):x,y\in L\rangle$.

- [ ] `scale` - Returns the scale ideal $\mathfrak s(L)=\langle (x,y):x,y\in L\rangle$; in the tested $\mathbf Z$ setting this is generated by a positive integer. [sources: sage/quadratic_forms/genera/genus.py::scale, sage_doc/test_genus_static.py::test_genus_scale_and_norm_are_positive]

### Lattice norm ideal invariant
Computes the norm ideal generated by represented norms.

- [ ] `norm` - Returns the norm ideal generated by $\{(x,x):x\in L\}$; in the tested genus setting it is a positive integer dividing twice the scale. [source: sage_doc/test_genus_static.py::test_genus_norm_divides_scale_times_two]

### Lattice level invariant
For an integral lattice with Gram matrix $G$, computes the least positive integer $N$ such that $N\,G^{-1}$ has integral entries (equivalently, the level ideal in the ideal-theoretic variant).

- [ ] `level` - Returns the least $N\in\mathbf Z_{>0}$ such that $N\,G^{-1}$ is integral (equivalently, $N\cdot q^\vee$ is integral on the dual lattice). [sources: sage/quadratic_forms/genera/genus.py::level, sage_doc/test_genus_static.py::test_genus_level_positive_integer]

### Parity invariant
Determines whether $q(x)\in 2\mathbf Z$ for all $x\in L$ (even) or not (odd).

- [ ] `is_even` - Predicate for even lattices/forms: $\forall x\in L,\ q(x)\in 2\mathbf Z$ (equivalently diagonal norms $(x,x)$ are even for integral Gram models). [sources: sage/modules/free_quadratic_module_integer_symmetric.py::is_even, sage_doc/test_integrallattice_static.py::test_integrallattice_is_even_detects_odd_diagonal]

### Unimodularity predicate
Tests whether $L=L^\vee$, equivalently $|\det(G)|=1$.

- [ ] `is_unimodular` - Tests $L=L^\vee$ under the bilinear pairing; for integral lattices this is equivalent to $|\det(G)|=1$. [sources: sage/modules/free_module_integer.py::is_unimodular, sage_doc/test_integerlattice_static.py::test_integerlattice_is_unimodular_false_for_scaled_basis]

### Dual lattice/module construction
Forms $L^\vee=\{x\in L\otimes\mathbf Q:(x,L)\subseteq\mathbf Z\}$ and the discriminant module $A_L:=L^\vee/L$ with induced quadratic/bilinear structure.

- [ ] `dual` - Returns $L^\vee=\{x\in V:(x,L)\subseteq\mathbf Z\}$ in the same ambient space $V=L\otimes\mathbf Q$; tested examples verify $\det(L)\det(L^\vee)=1$. [sources: julia_doc/test_zzlat_module_ops.jl::\"dual: dual lattice has reciprocal determinant\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_dual]
- [ ] `dual_lattice` - Returns the arithmetic dual $L^\vee=\{x\in L\otimes\mathbf Q:(x,L)\subseteq\mathbf Z\}$ as a lattice object (Sage naming variant of `dual`). [sources: sage/modules/free_quadratic_module_integer_symmetric.py::dual_lattice, sage_doc/test_integrallattice_static.py::test_integrallattice_dual_lattice_contains_scaled_basis]
- [ ] `discriminant_group` - Returns the finite abelian group $A_L=L^\vee/L$ (with induced finite quadratic/bilinear data); for nondegenerate integral lattices, $|A_L|=|\det G|$. [sources: sage/modules/free_quadratic_module_integer_symmetric.py::discriminant_group, sage_doc/test_integrallattice_static.py::test_integrallattice_discriminant_group_has_expected_order_rank_one]
- [ ] `discriminant_form` - Returns the finite quadratic module $(A_L,q_L)$ on $A_L=L^\vee/L$, where $q_L(x+L)=\frac{(x,x)}2\!\!\mod \mathbf Z$ (or the equivalent normalization used by the backend). [sources: sage/quadratic_forms/genera/genus.py::discriminant_form, sage_doc/test_genus_static.py::test_genus_discriminant_form_cardinality_matches_abs_determinant]

### Lattice sum/product/tensor operations
Builds standard constructions $L\oplus M$, $L\times M$, and $L\otimes M$ with induced bilinear/quadratic forms.

- [ ] `direct_sum` - Constructs the orthogonal sum $L\oplus M$ with block-diagonal Gram matrix $\mathrm{diag}(G_L,G_M)$; in particular $\operatorname{rank}(L\oplus M)=\operatorname{rank}(L)+\operatorname{rank}(M)$. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_direct_sum_adds_rank]
- [ ] `direct_product` - Returns a product object $(L,p_1,p_2)$ with projection maps to factors; in the finite-rank lattice context tested here, rank is additive: $\operatorname{rank}(L)=\operatorname{rank}(L_1)+\operatorname{rank}(L_2)$. [sources: julia_doc/test_zzlat_module_ops.jl::\"direct_product: product of two lattices\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_direct_product]
- [ ] `biproduct` - Returns $(L,i_1,i_2,p_1,p_2)$ exhibiting the additive-category biproduct structure (simultaneous product and coproduct data via injections/projections). [sources: julia_doc/test_zzlat_module_ops.jl::\"biproduct: returns injections and projections\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_biproduct]
- [ ] `tensor_product` - Builds $L\otimes_{\mathbf Z} M$ with induced bilinear form $(x_1\!\otimes y_1,\ x_2\!\otimes y_2)=(x_1,x_2)_L\,(y_1,y_2)_M$; tested rank satisfies $\operatorname{rank}(L\otimes M)=\operatorname{rank}(L)\operatorname{rank}(M)$. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_tensor_product_rank_multiplies]

### Lattice substructure relations
Computes/tests inclusions $M\subseteq L$, primitive closure $\overline M^{\,\mathrm{prim}}$, intersections, and orthogonal complements $M^\perp$.

- [ ] `intersect` - For $L_1,L_2\subset V$, returns the lattice intersection $L_1\cap L_2=\{v\in V:v\in L_1\ \wedge\ v\in L_2\}$. [sources: julia_doc/test_zzlat_module_ops.jl::\"intersect: intersection in common ambient\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_intersect]
- [ ] `is_sublattice` - Decides inclusion $M\subseteq L$ for lattices in a fixed ambient space (equivalently every basis vector of $M$ is in $L$). [sources: julia_doc/test_zzlat_module_ops.jl::\"is_sublattice: 2L is sublattice of L\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_is_sublattice]
- [ ] `sublattice` - Given vectors $v_1,\dots,v_r\in L\otimes\mathbf Q$, returns the generated $\mathbf Z$-submodule $\sum_i \mathbf Z v_i$ as a lattice in the same ambient space. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_sublattice_rank_from_single_generator]
- [ ] `overlattice` - For $L\subset V$ and extra vectors $w_i\in V$, returns the lattice $\langle L,w_1,\dots,w_r\rangle_{\mathbf Z}$ containing $L$. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_overlattice_contains_original_rank]
- [ ] `maximal_integral_lattice` - Returns an integral overlattice maximal (by inclusion) among integral overlattices in the same ambient space; documented checks verify integrality and rank preservation on sample input. [sources: docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md::2.9, julia_doc/test_zzlat_module_ops.jl::\"maximal_integral_lattice: maximal overlattice\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_maximal_integral_lattice]
- [ ] `maximal_overlattice` - Returns a maximal even integral overlattice $M\supseteq L$; if $p$ is specified, maximality is imposed at $p$ with $M_q=L_q$ for $q\neq p$. For $p=2$ or global (`p=None`), $L$ must be even. [sources: sage/modules/free_quadratic_module_integer_symmetric.py::maximal_overlattice, sage_doc/test_integrallattice_static.py::test_integrallattice_maximal_overlattice_evenness_constraint_at_two]
- [ ] `orthogonal_submodule` - For $S\subseteq L$, returns $S^\perp=\{x\in L:(x,s)=0\ \forall s\in S\}$ with respect to the lattice bilinear form. [sources: julia_doc/test_zzlat_module_ops.jl::\"orthogonal_submodule: orthogonal complement\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_orthogonal_submodule]
- [ ] `orthogonal_complement` - For a submodule $M$, returns $M^\perp=\{x:(x,m)=0\ \forall m\in M\}$ in the ambient quadratic module. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_orthogonal_complement_dimension]
- [ ] `primitive_closure` - For $S\subseteq L$, returns the smallest primitive sublattice $P$ with $S\subseteq P\subseteq L$, equivalently $L/P$ torsion-free. [sources: julia_doc/test_zzlat_module_ops.jl::\"primitive_closure: primitive closure of sublattice\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_primitive_closure]

### Lattice scaling/twisting
Applies form-scaling maps $q\mapsto a\,q$ (rescale, scale_by_factor) together with the separate lattice-twist operation twist.

- [ ] `rescale` - Replaces the form by $q'(x)=c\,q(x)$ (equivalently $B'=cB$, $G'=cG$), keeping the same underlying module. [sources: julia_doc/test_zzlat_construction.jl::\"rescale: flips sign of Gram\", julia_doc/test_zzlat_construction.jl::\"rescale: scales Gram by integer\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_rescale]
- [ ] `twist` - On the same underlying (finite) module, replaces $(q,b)$ by $(c\,q,\ c\,b)$ (normalization mod $\mathbf Z$ or $\mathbf Q/\mathbf Z$ inherited from the object). [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_twist_multiplies_quadratic_values]
- [ ] `scale_by_factor` - Multiplies all form coefficients by $c$, hence $q'(x)=c\,q(x)$ and the Hessian/Gram matrix scales by $c$. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_scale_by_factor_scales_coefficients]

### Orthogonal/isometry group construction
Constructs $O(L)=\{g\in GL(L):(gx,gy)=(x,y)\}$ and computes group-theoretic outputs such as generators and order.

- [ ] `orthogonal_group` - Returns the matrix group of isometries preserving the form, i.e. $O(L)=\{g\in GL(V):(gx,gy)=(x,y)\}$ and $g(L)=L$ (ambient action convention as in implementation). [sources: sage/modules/free_quadratic_module_integer_symmetric.py::orthogonal_group, sage_doc/test_torsionquadraticmodule_static.py::test_tqm_orthogonal_group_has_generators]
- [ ] `automorphism_group` - For a quadratic form $Q$, returns the matrix group $\{M\in GL_n(\mathbf Z):Q(Mx)=Q(x)\}$ (implemented via PARI `qfauto` for supported definite $\mathbf Z$-forms). [sources: sage/quadratic_forms/quadratic_form__automorphisms.py::automorphism_group, sage_doc/test_quadraticform_static.py::test_quadraticform_automorphism_group_order_matches_automorphisms_list]
- [ ] `automorphisms` - Returns the finite list of matrices $M$ satisfying $Q\circ M=Q$ for the tested definite integral form; list length equals `number_of_automorphisms()`. [sources: sage/quadratic_forms/quadratic_form__automorphisms.py::automorphisms, sage_doc/test_ternaryqf_static.py::test_ternaryqf_automorphisms_count_matches_number_of_automorphisms]
- [ ] `automorphism_group_generators` - Returns a generating set $\{g_i\}$ for $\operatorname{Aut}(L)$; each generator satisfies $g_i\,G\,g_i^{T}=G$ for the Gram matrix $G$. [sources: julia_doc/test_zzlat_automorphism.jl::\"automorphism_group_generators: A2 automorphism group\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_automorphism_group_generators]
- [ ] `automorphism_group_order` - Returns the group cardinality $|\operatorname{Aut}(L)|$ of lattice isometries. [sources: julia_doc/test_zzlat_automorphism.jl::\"automorphism_group_order: A2 has |Aut| = 12\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_automorphism_group_order]
- [ ] `automorphism_spin_norm` - For ternary forms, computes the spin norm of automorphism $A$ via decomposition into symmetries; implementation returns $1$ for identity and otherwise the squarefree part of $Q(v_1)Q(v_2)$. [sources: sage/quadratic_forms/ternary_qf.py::automorphism_spin_norm, sage_doc/test_ternaryqf_static.py::test_ternaryqf_automorphism_spin_norm_identity]
- [ ] `automorphism_symmetries` - For ternary forms, decomposes automorphism $A$ as a product of two reflections/symmetries determined by vectors $(v_1,v_2)$; returns `[]` for $A=I$. [sources: sage/quadratic_forms/ternary_qf.py::automorphism_symmetries, sage_doc/test_ternaryqf_static.py::test_ternaryqf_automorphism_symmetries_identity_empty]
- [ ] `invariant_bilinear_form` - Returns the symmetric matrix $B$ defining the bilinear form invariant under the group action, i.e. $g^TBg=B$ for group elements $g$. [sources: sage/groups/matrix_gps/isometries.py::invariant_bilinear_form, sage_doc/test_groupofisometries_static.py::test_groupofisometries_invariant_bilinear_form_matches_lattice]

### Isometry predicates
Tests isometry/equivalence relations, e.g. $L_1\cong L_2$ over $\mathbf Z$, over $\mathbf Q$, or locally over $\mathbf Z_p$.

- [ ] `is_isometric` - Decides existence of an isometry $\varphi:L_1\to L_2$ preserving the bilinear/quadratic form (matrix condition $T G_1 T^T = G_2$ in chosen bases). [sources: julia_doc/test_zzlat_automorphism.jl::\"is_isometric: A2 is isometric to itself\", julia_doc/test_zzlat_automorphism.jl::\"is_isometric: A2 not isometric to A3\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_is_isometric]
- [ ] `is_equivalent` - For binary quadratic forms, tests proper equivalence under the action of $SL_2(\mathbf Z)$ on variables. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_is_equivalent_reflexive]

### Hermite normal form
Computes Hermite normal form $H=UM$ over $\mathbf Z$.

- [ ] `hnf` - For $X\in M_{m,n}(\mathbf Z)$, returns Hermite normal form $H=UX$ with $U\in GL_m(\mathbf Z)$ and canonical row-echelon divisibility conditions. [sources: julia_doc/test_nemo.jl::\"hnf: Hermite normal form\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_hnf]
- [ ] `hnf_with_transform` - Returns $(H,U)$ where $U\in GL_m(\mathbf Z)$ and $H=UX$ is Hermite normal form of the input $X$. [sources: julia_doc/test_nemo.jl::\"hnf_with_transform: HNF + transformation matrix\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_hnf_with_transform]

### Smith normal form
Computes Smith form $UMV=\operatorname{diag}(d_i)$ with $d_i\mid d_{i+1}$.

- [ ] `snf` - For $X\in M_{m,n}(\mathbf Z)$, returns diagonal invariant-factor form $D=\operatorname{diag}(d_i)$ with $d_i\mid d_{i+1}$ and $D=UXV$ for unimodular $U,V$. [sources: julia_doc/test_nemo.jl::\"snf: Smith normal form\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_snf]
- [ ] `snf_with_transform` - Returns $(D,U,V)$ with $U,V$ unimodular and $D=UXV$ in Smith normal form. [sources: julia_doc/test_nemo.jl::\"snf_with_transform: SNF + transformation matrices\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_snf_with_transform]
- [ ] `smith_form` - Returns Smith invariant factors $(d_i)$ (or corresponding diagonal form) with $d_i\mid d_{i+1}$ describing $\mathbf Z^n/\operatorname{im}(X)$. [source: sage_doc/test_matrix_methods_static.py::test_matrix_smith_form_diagonal_divisibility]

### Toric lattice duality bridge
Implements dual-lattice correspondence $(M,N)$ with $N=\operatorname{Hom}(M,\mathbf Z)$ and cone/lattice conversion maps.

- [ ] `dual_pairing` - For dual lattices $M=\operatorname{Hom}(N,\mathbf Z)$ and $N$, returns the canonical evaluation $\langle n,m\rangle=m(n)\in\mathbf Z$ (dot product in dual coordinate bases). [source: sage_doc/test_toriclattice_static.py::test_toriclattice_dual_pairing_matches_coordinate_dot_product]
- [ ] `cone_dual` - For a rational polyhedral cone $C$, duality sends $C$ to $C^\vee=\{u:\langle u,v\rangle\ge0\ \forall v\in C\}$ and satisfies $(C^\vee)^\vee=C$ in the tested setting. [source: sage_doc/test_toriclattice_static.py::test_toriclattice_cone_dual_involution_preserves_ray_count]
- [ ] `cone_from_integrallattice` - Cone construction accepts a general free $\mathbf Z$-module lattice parameter $L$ (not only ToricLattice), using $L$ as ambient lattice for rays. [source: sage_doc/test_toriclattice_static.py::test_toric_cone_accepts_integrallattice_as_lattice_parameter]
- [ ] `integrallattice_from_toriclattice_parent` - Constructor-domain restriction: passing a ToricLattice parent object directly is not a valid IntegralLattice constructor input in the documented API. [source: sage_doc/test_toriclattice_static.py::test_integrallattice_cannot_be_built_directly_from_toriclattice_parent]
- [ ] `integrallattice_from_toriclattice_basis_matrix` - A basis matrix extracted from ToricLattice data is a valid matrix-model input for IntegralLattice construction. [source: sage_doc/test_toriclattice_static.py::test_integrallattice_can_be_built_from_toriclattice_basis_matrix]

### Free quadratic module ambient data
Returns ambient module/ambient vector space, basis matrix data, and pairing matrices for a free quadratic module.

- [ ] `gram_matrix` - For submodule basis matrix $B$ inside ambient bilinear matrix $A$, returns $G=BAB^T$, i.e. $G_{ij}=(b_i,b_j)$. [source: sage_doc/test_freequadraticmodule_static.py::test_freequadraticmodule_gram_matrix_on_submodule_basis]
- [ ] `basis_matrix` - Returns the matrix whose rows are a chosen lattice basis vectors in ambient coordinates. [sources: julia_doc/test_zzlat_attributes.jl::\"basis_matrix: identity for standard construction\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_basis_matrix]
- [ ] `ambient_module` - Returns the parent free quadratic module $M$ in which the current submodule/lattice is embedded. [source: sage_doc/test_freequadraticmodule_static.py::test_freequadraticmodule_ambient_module_is_self_for_ambient]
- [ ] `ambient_space` - Returns the ambient quadratic vector space $(V,q)$ over the coefficient field containing the lattice/module. [sources: julia_doc/test_zzlat_attributes.jl::\"ambient_space: returns quadratic space\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_ambient_space]
- [ ] `ambient_vector_space` - Extends scalars of the ambient module to the fraction field, giving $M\otimes_R \operatorname{Frac}(R)$ with induced bilinear form. [source: sage_doc/test_freequadraticmodule_static.py::test_freequadraticmodule_ambient_vector_space_keeps_dimension]
- [ ] `rational_span` - Returns $\mathbf Q\otimes_{\mathbf Z}L$, the rational quadratic space generated by lattice vectors. [sources: julia_doc/test_zzlat_attributes.jl::\"rational_span: returns quadratic space over QQ\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_rational_span]
- [ ] `inner_product_matrix` - Returns the ambient symmetric matrix $A$ representing $(x,y)=xAy^T$ in ambient coordinates. [source: sage_doc/test_freequadraticmodule_static.py::test_freequadraticmodule_inner_product_matrix_returns_ambient_form]
- [ ] `zero_submodule` - Returns $\{0\}$, the rank-$0$ submodule of the ambient module. [source: sage_doc/test_freequadraticmodule_static.py::test_freequadraticmodule_zero_submodule_has_rank_zero]
- [ ] `span` - Returns the submodule generated by supplied vectors: $\langle v_1,\dots,v_r\rangle_R$. [source: sage_doc/test_freequadraticmodule_static.py::test_freequadraticmodule_span_and_span_of_basis_agree_on_rank]
- [ ] `span_of_basis` - Constructs the submodule generated by a declared basis list (assumed independent in the intended usage). [source: sage_doc/test_freequadraticmodule_static.py::test_freequadraticmodule_span_of_basis_rank_two_on_independent_basis]

## Definite lattices over $\mathbf{Z}$

### Definiteness predicates
Classifies the sign type of $q$: positive definite, negative definite, or indefinite.

- [ ] `is_positive_definite` - For binary form $ax^2+bxy+cy^2$, positive-definite iff discriminant $D=b^2-4ac<0$ and $a>0$ (equivalently both eigenvalues positive). [source: sage_doc/test_binaryqf_static.py::test_binaryqf_positive_definite_criterion_example]
- [ ] `is_negative_definite` - Tests negative-definiteness (all real eigenvalues $<0$); in binary form terms, $D<0$ and leading coefficient $a<0$. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_negative_definite_aliases_match]
- [ ] `is_indefinite` - Tests whether the real form has mixed signature $(p,n)$ with $p,n>0$; for binary forms this is equivalent to $D>0$. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_is_indefinite_true_for_positive_discriminant]
- [ ] `is_definite` - Returns `True` iff the real signature is purely positive or purely negative (no mixed inertia). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_definite_true_for_positive_diagonal]
- [ ] `is_indef` - Alias of `is_indefinite`: mixed-signature predicate ($p,n>0$). [source: sage_doc/test_binaryqf_static.py::test_binaryqf_indefinite_aliases_match_on_indefinite_example]
- [ ] `is_negdef` - Alias predicate for negative-definiteness (all real eigenvalues negative). [source: sage_doc/test_binaryqf_static.py::test_binaryqf_is_negdef_true_for_negative_identity]
- [ ] `is_posdef` - Alias predicate for positive-definiteness (all real eigenvalues positive). [source: sage_doc/test_binaryqf_static.py::test_binaryqf_is_posdef_alias_matches_positive_definite]
- [ ] `compute_definiteness` - Computes and stores the definiteness class from real inertia/sign conditions (positive definite, negative definite, indefinite, etc.). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_compute_definiteness_sets_consistent_string]
- [ ] `compute_definiteness_string_by_determinants` - Returns a definiteness label using determinant/principal-minor sign criteria (Sylvester-style tests in the implemented classifier). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_compute_definiteness_string_expected_value]

### LLL reduction
Applies LLL reduction to obtain a basis satisfying Lovasz-size conditions.

- [ ] `LLL` - Applies Lenstra-Lenstra-Lovasz reduction to a basis (size reduction + Lovasz condition), returning an LLL-reduced basis and updating cached reduced-basis state. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_lll_returns_matrix_and_sets_reduced_basis]
- [ ] `lll` - Returns an integrally equivalent LLL-reduced form/basis representative, preserving arithmetic invariants such as discriminant. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_lll_preserves_discriminant]
- [ ] `LLL_gram` - Performs LLL in Gram-matrix form: returns unimodular $U$ such that $U^T G U$ is LLL-reduced. [source: sage_doc/test_matrix_methods_static.py::test_matrix_lll_gram_returns_unimodular_transform]
- [ ] `lll_gram` - LLL reduction routine acting on Gram matrices, producing an equivalent reduced Gram model. [sources: julia_doc/test_nemo.jl::\"lll_gram: LLL on Gram matrix\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_lll_gram]
- [ ] `lll_with_transform` - Returns reduced basis data together with change-of-basis matrix $T$ such that reduced basis equals $TB$ for input basis $B$. [sources: julia_doc/test_nemo.jl::\"lll_with_transform: returns reduced basis and transform\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_lll_with_transform]
- [ ] `lll_gram_with_transform` - Returns reduced Gram matrix $G'$ and transform $T$ with congruence relation $G'=TGT^T$. [sources: julia_doc/test_nemo.jl::\"lll_gram_with_transform: Gram LLL + transform\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_lll_gram_with_transform]
- [ ] `is_LLL_reduced` - Predicate verifying the LLL size-reduction and Lovasz inequalities for the given basis/Gram data. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_lll_reduced_true_after_lll]
- [ ] `update_reduced_basis` - Recomputes and stores an internal reduced basis cache used by subsequent reduction/enumeration routines. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_update_reduced_basis_sets_attribute]

### BKZ reduction
Applies BKZ with block size $\beta$, i.e., enforces local HKZ reduction on projected blocks of length $\beta$ along the basis chain.

- [ ] `BKZ` - Applies block Korkine-Zolotarev reduction: performs local HKZ reductions on projected blocks of fixed size $\beta$ along the basis chain. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_bkz_preserves_lattice_rank]

### HKZ reduction
Computes an HKZ-reduced basis, i.e. for each projected lattice, the first projected basis vector has minimal norm.

- [ ] `HKZ` - Computes Hermite-Korkine-Zolotarev reduction, equivalent to BKZ with block size equal to full rank. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_hkz_preserves_rank]

### Shortest vector norm
Computes $\lambda_1(L)^2=\min\{(x,x):x\in L\setminus\{0\}\}$.

- [ ] `minimum` - Returns $\lambda_1(L)^2=\min\{(x,x):x\in L\setminus\{0\}\}$ for positive-definite lattices (with documented signature-dependent conventions in tests). [source: sage_doc/test_integrallattice_static.py::test_integrallattice_minimum_extremes_by_signature]
- [ ] `min` - Alias accessor for `minimum` (same minimal represented norm invariant). [source: sage_doc/test_integrallattice_static.py::test_integrallattice_min_alias_matches_minimum]

### Maximal represented norm (enumerated set)
For a finite enumerated subset $S\subset L$, returns $\max\{(x,x):x\in S\}$.

- [ ] `maximum` - Returns the maximal represented norm over the finite enumerated vector set used by the routine/test context. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_maximum_extremes_by_signature]
- [ ] `max` - Alias accessor for `maximum` in the same enumeration context. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_max_alias_matches_maximum]

### Shortest vector computation
Computes vectors in $\{x\in L\setminus\{0\}:(x,x)\le B\}$ and, where requested, the primitive subset $\{x:\gcd(x_i)=1\}$.

- [ ] `shortest_vector` - Solves exact SVP: returns $v\in L\setminus\{0\}$ minimizing $(v,v)$. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_shortest_vector_has_expected_norm_rank_one]
- [ ] `shortest_vectors` - Returns the full shell $\{v\in L:(v,v)=\lambda_1(L)^2\}$ (implementation may quotient/sign-normalize in display). [sources: julia_doc/test_zzlat_enumeration.jl::\"shortest_vectors: A2 minimum norm is 2\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_shortest_vectors]
- [ ] `short_vectors` - Enumerates vectors with norm bound $(v,v)\le B$, typically grouped by represented norm values. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_short_vectors_contains_minimal_vector]
- [ ] `enumerate_short_vectors` - Iterator over lattice vectors ordered by nondecreasing norm (within requested bound/context). [source: sage_doc/test_integrallattice_static.py::test_integrallattice_enumerate_short_vectors_iterator_nonempty]
- [ ] `short_primitive_vector_list_up_to_length` - Returns vectors with $Q(v)\le B$ that are primitive (coordinate gcd $1$ in the tested integral setting). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_short_primitive_vector_list_subset_of_short_vectors]
- [ ] `short_vector_list_up_to_length` - Returns vectors satisfying $Q(v)\le B$ (without primitive restriction). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_short_vector_list_up_to_length_zero_contains_none]
- [ ] `basis_of_short_vectors` - Returns a basis chosen from short vectors (small represented norms) for the underlying module/form. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_basis_of_short_vectors_has_minimal_norm]
- [ ] `vectors_by_length` - Partitions enumerated vectors into shells indexed by represented value $Q(v)=m$ (or $(v,v)=m$). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_vectors_by_length_zero_shell_is_zero_vector]

### Closest vector computation
Solves/approximates CVP: given $v$, find $x\in L$ minimizing $\|v-x\|$.

- [ ] `closest_vector` - Solves exact CVP: for target $t$, returns $x\in L$ minimizing $\|t-x\|$ in the Euclidean embedding. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_closest_vector_exact_rank_one]
- [ ] `close_vectors` - Enumerates vectors $x\in L$ satisfying $\|t-x\|^2\le B$ for target $t$ and bound $B$. [sources: julia_doc/test_zzlat_enumeration.jl::\"close_vectors: finds vectors near target\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_close_vectors]
- [ ] `enumerate_close_vectors` - Iterator over lattice vectors ordered by increasing distance to a target vector. [source: sage_doc/test_integrallattice_static.py::test_integrallattice_enumerate_close_vectors_returns_candidate]
- [ ] `approximate_closest_vector` - Returns a heuristic/approximate CVP solution $x\in L$ near the minimizer for target $t$. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_approximate_closest_vector_returns_lattice_vector]
- [ ] `babai` - Babai nearest-plane algorithm: returns a lattice vector from sequential rounding in a reduced basis as a CVP approximation. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_babai_returns_lattice_vector_rank_one]

### Voronoi-cell algorithms
Computes the Voronoi domain $\mathcal V(L)$ and its facet-defining relevant vectors.

- [ ] `voronoi_cell` - Returns the Dirichlet-Voronoi polytope $\mathcal V(L)=\{x:\|x\|\le\|x-v\|\ \forall v\in L\}$ for a positive-definite lattice. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_voronoi_cell_has_vertices]
- [ ] `voronoi_relevant_vectors` - Returns vectors $v$ whose bisector inequalities define facets of $\mathcal V(L)$. [source: sage_doc/test_integerlattice_static.py::test_integerlattice_voronoi_relevant_vectors_nonempty]

### Kissing number
Computes $\tau(L):=\left|\{x\in L:(x,x)=\lambda_1(L)^2\}\right|$.

- [ ] `kissing_number` - Returns $\tau(L)=|\{v\in L:(v,v)=\lambda_1(L)^2\}|$, the number of minimal vectors. [sources: julia_doc/test_zzlat_enumeration.jl::\"kissing_number: A2 kissing number is 6\", julia_doc/test_zzlat_enumeration.jl::\"kissing_number: E8 kissing number is 240\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_kissing_number]

## Indefinite lattices and genera

### Hasse-Witt invariants
Computes the local Hasse symbols $\epsilon_p(q)$ and Witt-theoretic invariants determining the local isometry class.

- [ ] `hasse_invariant` - Returns local Hasse symbol $\epsilon_p(q)\in\{\pm1\}$ of the quadratic space over $\mathbf Q_p$, a product of Hilbert symbols in diagonal form. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_hasse_invariant_comparison_with_omeara]
- [ ] `hasse_invariant__OMeara` - Returns O'Meara-normalized local Hasse invariant (same local isometry information with that sign convention). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_hasse_invariant_omeara_sign_value]
- [ ] `witt_invariant` - Returns the local Witt invariant/class sign distinguishing Witt-equivalence data at a place (documented $\pm1$ output normalization). [sources: julia_doc/test_zzlat_automorphism.jl::\"witt_invariant: A2 at prime 2\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_witt_invariant]
- [ ] `hasse_conductor` - Returns the product of primes where the local Hasse invariant is $-1$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_hasse_conductor_positive]

### Genus object and representatives
Constructs the genus $\operatorname{Gen}(L)$, i.e. lattices locally isometric to $L$ at every place, and returns representatives.

- [ ] `genus` - Constructs the genus class determined by compatible local invariants (signature/discriminant-form data), i.e. lattices locally isometric at all places. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_genus_matches_discriminant_cardinality_for_valid_signature]
- [ ] `representative` - Returns one integral Gram matrix representative of the genus isometry class. [source: sage_doc/test_genus_static.py::test_genus_representative_preserves_dimension]
- [ ] `representatives` - Returns a list of explicit genus representatives (typically one per class in the genus decomposition). [source: sage_doc/test_genus_static.py::test_genus_representatives_returns_nonempty_same_rank_matrices]
- [ ] `rational_representative` - Returns a representative of the genus in the rational quadratic-space class (typically in diagonalized $\mathbf Q$-form in tests). [source: sage_doc/test_genus_static.py::test_genus_rational_representative_shape]
- [ ] `quadratic_space` - Returns the ambient rational quadratic space $(V,q)$ associated to the genus data. [sources: julia_doc/test_zzgenus.jl::\"quadratic_space: genus quadratic space\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_quadratic_space]
- [ ] `genera` - Enumerates genera satisfying prescribed global invariants (in tested usage: signature pair and determinant). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_genera_nonempty_for_signature_and_det]
- [ ] `determinant` - Returns determinant of a representative Gram matrix of the genus. [source: sage_doc/test_genus_static.py::test_genus_determinant_matches_input_gram_det]

### Genus-membership predicate
Tests local-global genus compatibility, i.e., agreement of local isometry invariants at every finite prime and at $\infty$.

- [ ] `is_genus` - Predicate that given local/discriminant data and signature constraints satisfy genus-consistency conditions for existence of a global lattice class. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_is_genus_true_exactly_for_valid_signature_example]

### Genus mass
Computes genus mass $\sum_{[L']\in\mathcal G}1/|\operatorname{Aut}(L')|$.

- [ ] `mass` - Returns Minkowski-Siegel mass $\operatorname{Mass}(\mathcal G)=\sum_{[L']\in\mathcal G}1/|\operatorname{Aut}(L')|$. [source: sage_doc/test_genus_static.py::test_genus_mass_positive_rational]
- [ ] `mass__by_Siegel_densities` - Computes genus mass via Siegel product formula from local density factors. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_mass_by_siegel_densities_positive]
- [ ] `mass_at_two_by_counting_mod_power` - Computes the $p=2$ local mass factor by counting congruence classes modulo powers of $2$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_mass_at_two_by_counting_mod_power_positive]
- [ ] `shimura_mass__maximal` - Shimura-formula mass routine specialized to maximal lattices (with non-maximal inputs rejected/undefined in tests). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_shimura_mass_maximal_returns_none_for_nonmaximal_case]
- [ ] `siegel_product` - Evaluates the Siegel-product expression for mass/densities at parameter values where the formula is defined in the coefficient field. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_siegel_product_raises_for_nonsquare_root_rationality]
- [ ] `GHY_mass__maximal` - Gan-Hanke-Yu maximal-mass routine for lattices satisfying maximality hypotheses. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_GHY_mass_maximal_returns_none_for_nonmaximal_case]
- [ ] `Kitaoka_mass_at_2` - Computes the $2$-adic local mass density factor using Kitaoka's formula. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_Kitaoka_mass_at_2_positive]
- [ ] `Pall_mass_density_at_odd_prime` - Computes odd-prime local mass/density factor via Pall's formula at prime $p\neq 2$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_Pall_mass_density_at_odd_prime_positive]
- [ ] `Watson_mass_at_2` - Computes the $2$-adic local mass factor in Watson's normalization. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_Watson_mass_at_2_positive]
- [ ] `conway_mass` - Computes mass using Conway-Sloane style mass-factor normalization. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_mass_positive]
- [ ] `conway_p_mass` - Returns Conway local factor at prime $p$ in the product expansion of Conway mass. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_p_mass_positive_at_three]
- [ ] `conway_standard_mass` - Computes the Conway standard/reference mass normalization. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_standard_mass_positive]
- [ ] `conway_standard_p_mass` - Returns prime-local factor at $p$ in the Conway standard mass product. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_standard_p_mass_positive_at_three]

### Genus local symbols
Computes local genus symbols from $p$-adic Jordan decompositions at each relevant place.

- [ ] `local_symbols` - Returns the collection of $p$-adic genus/Jordan symbols at all relevant primes. [source: sage_doc/test_genus_static.py::test_genus_local_symbols_nonempty_for_nonsingular_example]
- [ ] `local_symbol` - Returns the single local genus symbol at specified prime $p$. [source: sage_doc/test_genus_static.py::test_genus_local_symbol_returns_prime_data]
- [ ] `global_genus_symbol` - Returns the assembled global genus symbol encoding local genus data across primes (and archimedean component). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_global_genus_symbol_determinant_matches]
- [ ] `local_genus_symbol` - Returns the genus symbol at specified prime $p$ from the $p$-adic Jordan decomposition data. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_genus_symbol_returns_symbol]
- [ ] `CS_genus_symbol_list` - Returns Conway-Sloane local symbol list over relevant primes. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_CS_genus_symbol_list_nonempty]
- [ ] `Genus_Symbol_p_adic_ring.compartments` - For $2$-adic genus symbols, returns index groups of Jordan constituents belonging to the same compartment in Conway-Sloane compartment decomposition. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_genus_symbol_compartments_match_known_2adic_partition]

### Genus local-density congruence algorithms
Computes local representation densities $\alpha_p(\cdot)$ via congruence-solution counts and $p$-adic decomposition formulas.

- [ ] `local_density` - Returns local representation density $\alpha_p(m,Q)$ at prime $p$ for represented value $m$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_density_agrees_with_congruence_at_sample]
- [ ] `local_primitive_density` - Returns primitive local density $\alpha^{\mathrm{prim}}_p(m,Q)$ counting primitive $p$-adic representations. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_primitive_density_agrees_with_congruence]
- [ ] `local_representation_conditions` - Returns local congruence/valuation conditions characterizing representability by $Q$ at each relevant prime. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_representation_conditions_mentions_exception_prime]
- [ ] `local_bad_density_congruence` - Returns the "bad" congruence-density contribution, decomposed as $\alpha^{\mathrm{bad}}=\alpha^{\mathrm{badI}}+\alpha^{\mathrm{badII}}$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_bad_density_equals_sum_of_I_and_II]
- [ ] `local_good_density_congruence` - Returns "good" local congruence-density contribution (with even/odd refinement subroutines in the implementation). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_good_density_even_odd_helpers_on_sample]
- [ ] `local_zero_density_congruence` - Returns the "zero-type" component in local congruence-density decomposition. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_zero_density_congruence_zero_at_sample]
- [ ] `local_badI_density_congruence` - Returns bad-I summand in the local bad-density decomposition. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_badI_density_congruence_zero_at_sample]
- [ ] `local_badII_density_congruence` - Returns bad-II summand in the local bad-density decomposition. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_badII_density_congruence_zero_at_sample]
- [ ] `local_density_congruence` - Computes local density $\alpha_p(m,Q)$ via congruence-counting formulas modulo powers of $p$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_density_congruence_matches_local_density]
- [ ] `local_good_density_congruence_even` - Computes even-prime good-type contribution for local density in the $p=2$ congruence decomposition. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_good_density_congruence_even_zero_at_sample]
- [ ] `local_good_density_congruence_odd` - Computes odd-prime good-type contribution in local congruence-density decomposition. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_good_density_congruence_odd_zero_at_sample]
- [ ] `local_primitive_density_congruence` - Computes primitive local density via congruence-counting formulas (primitive-vector restriction). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_primitive_density_congruence_zero_at_sample]

### Genus prime support
Computes the finite set of primes where local genus data are nontrivial (typically primes dividing the discriminant together with additional bad primes).

- [ ] `primes` - Returns the finite set of primes at which local genus/lattice invariants are nontrivial (support primes). [sources: julia_doc/test_zzgenus.jl::\"primes: list of primes in genus\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_primes]

### Genus spinor data
Computes spinor generators and spinor-norm invariants for the genus/spinor genus.

- [ ] `spinor_generators` - Returns generators for spinor-kernel/spinor-class computations in the genus (proper/improper mode according to flag). [source: sage_doc/test_genus_static.py::test_genus_spinor_generators_nonempty_for_proper_and_improper]

### Representation predicates
Tests solvability of $q(x)=m$: global solvability over $\mathbf Z$ and local solvability over $\mathbf Z_p$ / completions.

- [ ] `represents` - Representation predicate: decides whether the target integer/form is represented by the source genus/lattice in the tested sense. [sources: julia_doc/test_zzgenus.jl::\"represents: genus representation\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_represents]
- [ ] `is_locally_represented_number` - Decides whether $Q(x)=n$ is solvable over every local completion (all $\mathbf Q_p$ and $\mathbf R$ as applicable). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_representation_methods_agree_on_sample]
- [ ] `is_locally_represented_number_at_place` - Decides solvability of $Q(x)=n$ over the specified local place $p$ (typically $\mathbf Q_p$). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_locally_represented_number_at_place_true_sample]
- [ ] `is_locally_universal_at_prime` - Tests whether every local class/number is represented at fixed prime $p$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_locally_universal_at_prime_true_sample]
- [ ] `is_locally_universal_at_all_primes` - Tests universality at every finite prime $p$, i.e. local representability of all classes at all $p$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_universality_methods_detect_nonuniversal_case]
- [ ] `is_locally_universal_at_all_places` - Tests universality at all places (finite primes and archimedean place). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_locally_universal_at_all_places_false_example]

### Anisotropy/isotropy predicates
Tests whether $q(x)=0$ has nonzero solutions and computes places where the quadratic space is anisotropic.

- [ ] `is_anisotropic` - Local anisotropy predicate: no nonzero vector solves $Q(x)=0$ over the specified local field. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_anisotropic_and_is_isotropic_complement_at_prime]
- [ ] `is_isotropic` - Local isotropy predicate: existence of nonzero $x$ with $Q(x)=0$ over the specified local field/place. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_isotropic_true_at_two]
- [ ] `anisotropic_primes` - Returns finite primes where the local form is anisotropic (fails local isotropy). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_anisotropic_primes_contains_three]

## Hyperbolic lattices and root data

### Hyperbolicity predicate
Tests whether the quadratic space is Witt-trivial (equivalently, isometric to an orthogonal sum of hyperbolic planes over the base field).

- [ ] `is_hyperbolic` - Tests whether the local quadratic space is hyperbolic (orthogonal sum of hyperbolic planes) at place/prime $p$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_hyperbolic_false_at_two_for_example]

### Root-system scalar product and roots
Computes root pairings $(\alpha,\beta)$, root subsets (positive/highest), and morphisms to ambient/coroot realizations.

- [ ] `scalar` - Root-coroot pairing $\langle \alpha_i,\alpha_j^\vee\rangle = a_{ji}$, yielding Cartan-matrix entries. [source: sage_doc/test_rootsystem_static.py::test_rootsystem_simple_root_scalar_recovers_cartan_entry]
- [ ] `positive_roots` - Returns $\Phi^+=\{\sum_i c_i\alpha_i\in\Phi: c_i\ge0\}$ in the chosen root-lattice realization. [source: sage_doc/test_rootsystem_static.py::test_rootsystem_positive_roots_count_matches_type_a2]
- [ ] `highest_root` - Returns maximal element of $\Phi^+$ under root-poset order (dominance by nonnegative simple-root combinations). [source: sage_doc/test_rootsystem_static.py::test_rootsystem_highest_root_is_positive]
- [ ] `to_ambient_space_morphism` - Canonical morphism $Q\to V_{\mathrm{amb}}$ from root lattice to ambient realization preserving root data embeddings. [source: sage_doc/test_rootsystem_static.py::test_rootsystem_to_ambient_space_morphism_preserves_parent]
- [ ] `to_coroot_space_morphism` - Canonical map from root lattice to coroot lattice/space induced by the root datum pairing. [source: sage_doc/test_rootsystem_static.py::test_rootsystem_to_coroot_space_morphism_preserves_parent]

## Finite quadratic modules

### Finite quadratic module cardinality and generators
Computes $|A|$ and generating systems for a finite quadratic module $A$.

- [ ] `cardinality` - Returns $|A|$, the order of the finite quadratic module/discriminant group. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_cardinality_matches_rank_one_discriminant]
- [ ] `gens` - Returns a generating set of elements (or matrices in group context) for the ambient algebraic object. [source: sage_doc/test_groupofisometries_static.py::test_groupofisometries_generators_are_isometries]
- [ ] `element_class` - Runtime Python/Sage class type used for elements of the parent structure. [source: sage_doc/test_rootsystem_static.py::test_rootsystem_element_class_matches_element_parent]
- [ ] `Element` - Parent-level element-constructor class used to instantiate elements with parent-attached coordinates/data. [source: sage_doc/test_rootsystem_static.py::test_rootsystem_Element_constructor_builds_parent_element]

### Finite quadratic module Gram forms
Computes bilinear/quadratic pairings $b_A$, $q_A$ on the discriminant module.

- [ ] `gram_matrix_bilinear` - Returns matrix $(b(g_i,g_j))$ of the induced bilinear form on chosen generators $g_i$ of the finite module. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_gram_matrix_bilinear_is_square]
- [ ] `gram_matrix_quadratic` - Returns matrix encoding quadratic values/interactions in the same generator basis used for the finite quadratic module. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_gram_matrix_quadratic_has_same_shape_as_bilinear]
- [ ] `value_module` - Returns codomain module for bilinear values (typically a quotient such as $\mathbf Q/\mathbf Z$ in finite quadratic-module context). [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_value_modules_are_defined]
- [ ] `value_module_qf` - Returns codomain module for quadratic-form values (normalization inherited from finite quadratic-module convention). [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_value_module_qf_defined]

### Finite quadratic module decomposition
Constructs orthogonal and primary decompositions $A\cong\bigoplus_p A_p$.

- [ ] `primary_part` - Returns $p$-primary (or specified primary) component, i.e. subgroup of elements annihilated by a power of the chosen prime/ideal. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_primary_part_of_two_group_is_itself]
- [ ] `all_submodules` - Enumerates all submodules/subgroups compatible with the ambient finite-module structure. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_all_submodules_nonempty]
- [ ] `orthogonal_submodule_to` - Returns orthogonal complement $S^\perp=\{x:b(x,s)=0\ \forall s\in S\}$ in the finite bilinear module. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_orthogonal_submodule_to_self_is_nonempty]
- [ ] `submodule_with_gens` - Returns submodule generated by supplied elements: $\langle g_1,\dots,g_r\rangle$. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_submodule_with_gens_cardinality_bound]
- [ ] `normal_form` - Returns a canonical/normalized representative of the isomorphism class of the finite quadratic module. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_normal_form_returns_module]

### Finite quadratic module Brown invariant
Computes the Brown invariant $\operatorname{Br}(A,q)\in\mathbf Z/8\mathbf Z$.

- [ ] `brown_invariant` - Returns Brown invariant $\operatorname{Br}(A,q)\in \mathbf Z/8\mathbf Z$ of the finite quadratic module. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_brown_invariant_is_defined_mod_8]

### Finite quadratic module structure invariants
Computes invariants classifying the finite quadratic module $(A,q)$ up to isomorphism.

- [ ] `invariants` - Returns invariant-factor decomposition data of the underlying finite abelian group. [source: sage_doc/test_torsionquadraticmodule_static.py::test_tqm_invariants_rank_one_even_lattice]

### Primary/elementary p-component predicates
Checks $p$-primary decomposition and elementary type in finite quadratic modules.

- [ ] `is_primary_with_prime` - Tests whether the module is $p$-primary (all element orders are powers of specified prime $p$). [sources: julia_doc/test_zzlat_attributes.jl::\"is_primary_with_prime\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_is_primary_with_prime]
- [ ] `is_elementary_with_prime` - Tests whether the $p$-primary part is elementary abelian (vector space over $\mathbf F_p$). [sources: julia_doc/test_zzlat_attributes.jl::\"is_elementary_with_prime\", julia_pytest/test_oscar_bridge_static.py::test_julia_bridge_is_elementary_with_prime]

### Matrix/FQM ring-change operations
Performs base change $R\to S$ for matrix and finite quadratic-module structures.

- [ ] `base_ring` - Returns the coefficient ring over which the object/matrix/module is defined. [source: sage_doc/test_matrix_methods_static.py::test_matrix_base_ring_is_zz]
- [ ] `change_ring` - Extends/coerces coefficients to ring $R$, producing the base-changed object over $R$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_change_ring_to_qq_preserves_dimension]

## Quadratic forms over $\mathbf{Z}$

### Quadratic form matrix alias
matrix() returns Hessian_matrix(), i.e. the matrix $A$ such that $Q(X)=\frac12 X^tAX$.

- [ ] `matrix` - Returns Hessian/symmetric matrix $A$ satisfying $Q(x)=\frac12 x^T A x$; equivalently $A=2G$ for Gram matrix $G$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_gram_and_hessian_relation]

### Quadratic form Gram matrix
Returns a symmetric matrix $A$ over the base ring such that $Q(x)=x^tAx$; raises TypeError if no such base-ring Gram matrix exists.

- [ ] `Gram_matrix` - Returns Gram matrix $G$ with $Q(x)=x^T G x$ and $A=2G$ for Hessian matrix $A=\texttt{matrix()}$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_Gram_matrix_half_of_matrix]

### Quadratic form Hessian matrix
Returns the matrix $A$ characterized in Sage by $Q(X)=\frac12 X^tAX$; in coordinates, diagonal entries are $2Q_{ii}$ and off-diagonal entries are $Q_{ij}$.

- [ ] `Hessian_matrix` - Returns the symmetric Hessian matrix model $A$ (identical accessor to `matrix()` in tested implementation). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_Hessian_matrix_matches_matrix_method]

### Rational Gram matrix
Returns a symmetric Gram matrix over the fraction field with $Q(x)=x^tAx$; in Sage this is $\frac12\,\mathrm{matrix()}$.

- [ ] `Gram_matrix_rational` - Returns Gram matrix viewed in $\mathbf Q$ (entries coerced to rational field). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_Gram_matrix_rational_has_expected_entries]

### Rational diagonalization of a quadratic form
Computes a diagonal form over $\mathbf Q$ equivalent to $q$, i.e. $q\sim\langle a_1,\dots,a_n\rangle$ in the rational equivalence class.

- [ ] `rational_diagonal_form` - Produces diagonal form over $\mathbf Q$ in the same rational isometry class, $Q \sim_{\mathbf Q} \langle a_1,\dots,a_n\rangle$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_rational_diagonal_form_preserves_rank]

### Integrality of Gram matrix
Returns True iff Gram_matrix() succeeds over the base ring (equivalently, the base-ring Gram matrix exists).

- [ ] `has_integral_Gram_matrix` - Predicate that Gram matrix entries lie in $\mathbf Z$ (integral bilinear model). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_has_integral_gram_matrix_true_for_integer_form]

### Quadratic-form real signature invariants
For a real quadratic form, records inertia data $(p,n,z)$ with positive/negative/zero counts.

- [ ] `signature_vector` - Returns $(p,n,z)$, the inertia multiplicities of a real symmetric model of the form (positive, negative, and zero eigenvalue counts). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_signature_vector_counts_eigenvalue_signs]

### Quadratic-form discriminant invariants
Records discriminant-type invariants for ternary and binary quadratic forms.

- [ ] `det` - det() is the Hessian determinant and Gram_det() is the Gram determinant. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_discriminant_equals_gram_det]
- [ ] `Gram_det` - Gram_det() equals det()/2^n where n is dimension. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_Gram_det_scales_det_by_power_of_two]
- [ ] `disc` - In the tested ternary-form convention, $\operatorname{disc}(q)=\det(H_q)/2$ where $H_q$ is the Hessian/symmetric matrix model returned by `matrix()`. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_disc_matches_hessian_det_half]
- [ ] `has_fundamental_discriminant` - Tests whether the form discriminant $D$ is a fundamental discriminant, i.e. $D\equiv 1\pmod 4$ and squarefree, or $D=4m$ with $m\equiv 2,3\pmod 4$ squarefree. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_has_fundamental_discriminant_true_example]

### Quadratic-form level invariants
Computes level normalizations attached to quadratic forms.

- [ ] `level_ideal` - Ideal-theoretic version of level: returns the ideal $(N)$ generated by the level integer in the base ring (tested over $\mathbf Z$). [sources: sage/quadratic_forms/quadratic_form.py::level_ideal, sage_doc/test_quadraticform_static.py::test_quadraticform_level_ideal_matches_level_generator]
- [ ] `level__Tornaria` - Tornaria level normalization: if $2Q(x)=x^T B x$, returns $\operatorname{level}(B)$ in even dimension and $\operatorname{level}(B)/4$ in odd dimension (equivalently implemented as $|\operatorname{disc}(Q)|/(\omega(Q)\,\operatorname{content}(Q)^{\dim Q})$). [sources: sage/quadratic_forms/quadratic_form__ternary_Tornaria.py::level__Tornaria, sage_doc/test_quadraticform_static.py::test_quadraticform_level_Tornaria_is_positive]

### Quadratic-form parity predicates
Determines parity class via the quadratic-form parity routine over $\mathbf Z$.

- [ ] `is_odd` - In the tested quadratic-form API over $\mathbf Z$, returns `True` exactly when `parity(...)` is `"odd"` (optionally after the method's documented rescaling convention). [sources: sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py::is_odd, sage_doc/test_quadraticform_static.py::test_quadraticform_is_odd_true_example]
- [ ] `parity` - Returns the parity class label (`even`/`odd`) corresponding to the predicates above on $q(L)\subseteq \mathbf Z$. [sources: sage/quadratic_forms/quadratic_form__mass__Conway_Sloane_masses.py::parity, sage_doc/test_quadraticform_static.py::test_quadraticform_parity_matches_is_odd]

### Quadratic-form singularity and zero-locus predicates
Tests degeneracy and singular/nonsingular points on $Q(v)=0$ (global or modulo $p$).

- [ ] `is_singular` - Returns `True` iff the associated symmetric matrix is degenerate (equivalently $\det(G)=0$, so the radical is nonzero). [sources: sage/quadratic_forms/binary_qf.py::is_singular, sage_doc/test_binaryqf_static.py::test_binaryqf_is_singular_false_for_nonzero_discriminant]
- [ ] `is_nonsingular` - Predicate for nondegeneracy: equivalent to $\det(G)\neq 0$ (and in tests, logical negation of `is_singular`). [sources: sage/quadratic_forms/binary_qf.py::is_nonsingular, sage_doc/test_binaryqf_static.py::test_binaryqf_nonsingular_is_logical_negation_of_singular]
- [ ] `is_zero_nonsingular` - For ternary-form routine, tests $Q(v)\equiv 0\pmod p$ (or exactly if $p=0$) and nonvanishing gradient condition $v^TM_Q\not\equiv 0\pmod p$. [sources: sage/quadratic_forms/quadratic_form__ternary_Tornaria.py::is_zero_nonsingular, sage_doc/test_quadraticform_static.py::test_quadraticform_is_zero_nonsingular_false_for_zero_vector]
- [ ] `is_zero_singular` - For ternary-form routine, tests $Q(v)\equiv 0\pmod p$ (or exactly if $p=0$) and singularity condition $v^TM_Q\equiv 0\pmod p$. [sources: sage/quadratic_forms/quadratic_form__ternary_Tornaria.py::is_zero_singular, sage_doc/test_quadraticform_static.py::test_quadraticform_is_zero_singular_true_for_zero_vector]
- [ ] `is_zero` - Tests $Q(v)=0$ (or $Q(v)\equiv 0\pmod p$ in the optional local variant). [sources: sage/quadratic_forms/quadratic_form__ternary_Tornaria.py::is_zero, sage_doc/test_quadraticform_static.py::test_quadraticform_is_zero_on_zero_vector]

### Quadratic form polynomial model
Represents $q$ as homogeneous polynomial and accesses coefficients.

- [ ] `polynomial` - Returns polynomial expression $f(x)$ representing the same quadratic map as the form/matrix model. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_polynomial_evaluates_like_form]
- [ ] `from_polynomial` - Constructs quadratic form $Q$ whose polynomial model equals the given homogeneous degree-$2$ polynomial $f$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_from_polynomial_roundtrip]
- [ ] `coefficients` - Returns coefficient tuple/list in the implementation's fixed monomial ordering for the ternary quadratic form. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_coefficients_length_is_six]
- [ ] `coefficient` - Returns the indexed coefficient with respect to the same monomial ordering as `coefficients()`. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_coefficient_matches_coefficients_entry]

### Quadratic form content and primitiveness
Computes $\operatorname{cont}(q):=\gcd$ of coefficients and tests primitivity ($\operatorname{cont}(q)=1$).

- [ ] `content` - Returns $\gcd$ of all integral coefficients of the quadratic form. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_content_matches_coefficient_gcd]
- [ ] `is_primitive` - For the tested ternary-form method, returns whether $\gcd$ of all coefficients is $1$ (primitive integral form). [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_is_primitive_matches_content_one]
- [ ] `primitive` - Returns primitive form $Q/\operatorname{content}(Q)$ with coefficient gcd equal to $1$. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_primitive_has_unit_content_after_normalization]
- [ ] `divisor` - Returns a common divisor invariant of coefficients (in tested usage, dividing each coefficient). [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_divisor_divides_all_coefficients]

### Quadratic form local neighbors
Constructs and traverses $p$-neighbors in genus graphs.

- [ ] `find_p_neighbors` - Computes $p$-neighbor forms/lattices adjacent in the Kneser $p$-neighbor graph. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_find_p_neighbors_returns_requested_count_or_more]
- [ ] `find_p_neighbor_from_vec` - Constructs a $p$-neighbor using an isotropic vector modulo $p$ as seed data. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_find_p_neighbor_from_vec_preserves_discriminant]
- [ ] `neighbor_iteration` - Iterative traversal of the $p$-neighbor graph from seed forms, subject to iteration/class limits. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_neighbor_iteration_returns_seed_under_class_limit]
- [ ] `find_primitive_p_divisible_vector__random` - Randomized search for primitive vector satisfying required $p$-divisibility/congruence condition for neighbor construction. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_find_primitive_p_divisible_vector_random_is_p_divisible]
- [ ] `find_primitive_p_divisible_vector__next` - Deterministic "next-candidate" iterator for primitive vectors satisfying the same $p$-divisibility constraints. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_find_primitive_p_divisible_vector_next_returns_candidate]

### Quadratic form reductions
Computes reduced representatives in the relevant equivalence class (binary/ternary reduction, Minkowski reduction, and local normal forms).

- [ ] `reduced_form` - Returns Gauss-reduced representative in the proper equivalence class of a binary quadratic form. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_reduced_form_preserves_discriminant]
- [ ] `is_reduced` - Predicate for Gauss reduction inequalities/congruence conditions in binary quadratic forms. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_is_reduced_on_simple_posdef_example]
- [ ] `reduced_binary_form` - Binary reduction routine returning reduced representative (and associated transform data in implementation-specific output). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_reduced_binary_form_preserves_discriminant]
- [ ] `reduced_binary_form1` - Variant binary reduction routine yielding an equivalent reduced binary form. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_reduced_binary_form1_on_binary_input_preserves_discriminant]
- [ ] `reduced_ternary_form__Dickson` - Dickson ternary reduction routine (implementation availability may be conditional in current build/backend). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_reduced_ternary_form_Dickson_notimplemented_here]
- [ ] `reduced_form_eisenstein` - Returns Eisenstein-reduced representative (with accompanying transformation data in implementation output). [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_reduced_form_eisenstein_preserves_discriminant]
- [ ] `is_eisenstein_reduced` - Predicate verifying Eisenstein ternary reduction inequalities/conditions. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_is_eisenstein_reduced_returns_boolean]
- [ ] `minkowski_reduction` - Computes Minkowski-reduced equivalent form (with transformation matrix data in implementation output). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_minkowski_reduction_preserves_discriminant]
- [ ] `minkowski_reduction_for_4vars__SP` - Schiemann-Pohst specialized Minkowski-reduction algorithm for quaternary forms. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_minkowski_reduction_for_4vars_sp_preserves_discriminant]
- [ ] `local_normal_form` - Returns a form equivalent over $\mathbf Z_p$ in local normal/Jordan form at prime $p$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_local_normal_form_preserves_discriminant_at_two]

### Quadratic form variable transformations
Applies linear substitutions $x\mapsto Tx$ and variable operations (swap/multiply/divide/extract) on $q$.

- [ ] `swap_variables` - Applies permutation matrix exchanging coordinates $x_i$ and $x_j$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_swap_variables_preserves_discriminant]
- [ ] `multiply_variable` - Substitution $x_i\mapsto c\,x_i$ (diagonal linear change in variable $i$). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_multiply_variable_by_zero_forces_zero_coefficient]
- [ ] `divide_variable` - divide_variable(c,i) divides variable i by scalar c. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_divide_variable_by_one_is_identity]
- [ ] `extract_variables` - extract_variables(idx) extracts subform in selected variables. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_extract_variables_dimension_matches_selection]
- [ ] `elementary_substitution` - elementary_substitution(c,i,j) applies elementary variable substitution. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_elementary_substitution_preserves_dimension]
- [ ] `add_symmetric` - add_symmetric(c,i,j) performs symmetric elementary update. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_add_symmetric_changes_selected_coefficients]
- [ ] `complementary_subform_to_vector` - complementary_subform_to_vector(v) returns orthogonal complement subform. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_complementary_subform_reduces_dimension_by_one]

### Quadratic-form isometry/equivalence predicates
Tests rational, integral, and local equivalence relations of quadratic forms.

- [ ] `is_rationally_isometric` - Decides isometry over $\mathbf Q$: existence of $T\in GL_n(\mathbf Q)$ with $T G_1 T^T = G_2$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_rationally_isometric_detects_discriminant_change]
- [ ] `is_globally_equivalent_to` - Tests integral global equivalence: existence of $U\in GL_n(\mathbf Z)$ with $U G_1 U^T = G_2$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_globally_equivalent_to_reflexive_and_detects_change]
- [ ] `is_locally_equivalent_to` - Tests local equivalence at every place ($\mathbf R$ and all $\mathbf Q_p$): $Q_1\otimes \mathbf Q_v \cong Q_2\otimes \mathbf Q_v$ for all $v$. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_locally_equivalent_to_reflexive_and_detects_change]

### Quadratic-form bilinearization map
Computes polarization $B_q(x,y)=q(x+y)-q(x)-q(y)$.

- [ ] `bilinear_map` - bilinear_map(v,w) is the polarization B(v,w)=(Q(v+w)-Q(v)-Q(w))/2. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_bilinear_map_polarization_identity]

### Quadratic-form Cholesky algorithm
Computes Cholesky factorization in the positive-definite symmetric case.

- [ ] `cholesky_decomposition` - cholesky_decomposition() returns positive factor in Gram convention. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_cholesky_decomposition_reconstructs_matrix]

### Quadratic form theta series
Computes the theta series $\Theta_L(t)=\sum_{x\in L}t^{(x,x)/2}$ and the degree-$2$ theta variant.

- [ ] `theta_series` - theta_series(prec) counts representation numbers with constant term from the zero vector. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_theta_series_leading_coefficient_one]
- [ ] `theta_series_degree_2` - theta_series_degree_2(prec) returns dictionary of degree-2 theta coefficients. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_theta_series_degree_2_has_constant_term_one]
- [ ] `theta_by_cholesky` - theta_by_cholesky(q_prec) computes theta coefficients. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_theta_by_cholesky_starts_with_one_constant_term]
- [ ] `theta_by_pari` - theta_by_pari(Max) computes theta coefficients via PARI. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_theta_by_pari_starts_with_one_constant_term]

### Quadratic form representations enumeration
Enumerates representation sets and counts (e.g., $r_q(m)=|\{x:q(x)=m\}|$) under prescribed bounds.

- [ ] `representation_number_list` - representation_number_list(B) lists counts up to bound. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_representation_number_list_constant_term_one]
- [ ] `representation_vector_list` - representation_vector_list(B) lists representing vectors by value. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_representation_vector_list_contains_zero_vector_for_zero]

### Quadratic form automorphism count/state
Computes $|\operatorname{Aut}(q)|$ and updates/reads its cached value.

- [ ] `number_of_automorphisms` - number_of_automorphisms() returns cardinality of automorphism group. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_number_of_automorphisms_matches_list_size]
- [ ] `set_number_of_automorphisms` - set_number_of_automorphisms(n) sets cached automorphism count. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_set_number_of_automorphisms_updates_cached_value]

### Quadratic form Clifford invariants
Computes Clifford-conductor and Clifford-invariant quantities attached to $C(q)$.

- [ ] `clifford_conductor` - clifford_conductor() returns conductor-like invariant. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_clifford_conductor_positive]
- [ ] `clifford_invariant` - clifford_invariant(p) is local Clifford invariant at p. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_clifford_invariant_is_hilbert_symbol_value]

### Quadratic form adjoint family
Computes adjoint and antiadjoint constructions and tests adjointness predicates.

- [ ] `adjoint` - adjoint() returns the classical adjoint ternary form. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_adjoint_is_ternary_form]
- [ ] `adjoint_primitive` - adjoint_primitive() normalizes adjoint to primitive form. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_adjoint_primitive_is_primitive]
- [ ] `adjoint_classical` - adjoint_classical() returns classical adjoint matrix. [source: sage_doc/test_matrix_methods_static.py::test_matrix_adjoint_classical_times_matrix_equals_det_identity]
- [ ] `adjugate` - adjugate() is the classical adjoint. [source: sage_doc/test_matrix_methods_static.py::test_matrix_adjugate_equals_adjoint_classical]
- [ ] `antiadjoint` - antiadjoint() inverts adjoint construction on adjoint forms. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_antiadjoint_inverts_adjoint]
- [ ] `is_adjoint` - is_adjoint() detects adjoint forms. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_is_adjoint_true_on_adjoint_form]

### Classical quadratic-form invariants and class data
Computes classical arithmetic invariants and class-theoretic data for quadratic forms (including $\delta,\omega,\xi,\xi_{\mathrm{rec}}$, form classes, cycles, and solution data).

- [ ] `delta` - delta() is determinant-based invariant. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_delta_equals_disc_for_odd_dimension]
- [ ] `omega` - omega() returns an arithmetic genus character value. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_omega_positive]
- [ ] `xi` - xi(p) evaluates a genus character when defined. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_xi_invalid_character_raises_value_error]
- [ ] `xi_rec` - xi_rec(p) evaluates reciprocal character when defined. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_xi_rec_defined_for_prime_three]
- [ ] `reciprocal` - reciprocal() returns reciprocal quadratic form. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_reciprocal_is_same_dimension]
- [ ] `reciprocal_reduced` - reciprocal_reduced() returns reduced reciprocal representative. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_reciprocal_reduced_preserves_discriminant]
- [ ] `symmetry` - symmetry(v) returns reflection matrix associated to vector v. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_symmetry_matrix_has_determinant_minus_one]
- [ ] `form_class` - form_class() maps to the class-group element of the form. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_form_class_preserves_discriminant]
- [ ] `principal` - principal(D) returns the principal form of discriminant D. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_principal_has_requested_discriminant]
- [ ] `small_prime_value` - small_prime_value() returns a represented prime (or small value) for primitive forms. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_small_prime_value_is_represented]
- [ ] `complex_point` - complex_point() gives a complex root of ax^2+bxy+cy^2 at y=1. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_complex_point_is_root_of_specialization]
- [ ] `cycle` - cycle() returns a reduction cycle for reduced indefinite forms. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_cycle_contains_equivalent_forms]
- [ ] `solve_integer` - solve_integer(n) returns integer coordinates representing n when possible. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_solve_integer_returns_exact_representation]

### Jordan/genus block combinatorics
Computes $p$-adic Jordan decompositions and the combinatorial factors entering local-density and mass formulas.

- [ ] `collect_small_blocks` - collect_small_blocks(G) recovers 1x1/2x2 blocks from a block-diagonal matrix. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_collect_small_blocks_recovers_block_structure]
- [ ] `jordan_blocks_by_scale_and_unimodular` - jordan_blocks_by_scale_and_unimodular(p) returns local Jordan blocks. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_jordan_blocks_by_scale_and_unimodular_nonempty]
- [ ] `jordan_blocks_in_unimodular_list_by_scale_power` - jordan_blocks_in_unimodular_list_by_scale_power(p) returns unimodular block list. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_jordan_blocks_unimodular_list_nonempty]
- [ ] `has_equivalent_Jordan_decomposition_at_prime` - has_equivalent_Jordan_decomposition_at_prime(other,p) is true iff self and other have equivalent p-adic Jordan decomposition at prime p. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_has_equivalent_jordan_decomposition_at_prime_detects_change]
- [ ] `find_entry_with_minimal_scale_at_prime` - find_entry_with_minimal_scale_at_prime(p) returns matrix index pair. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_find_entry_with_minimal_scale_returns_valid_index_pair]
- [ ] `count_all_local_good_types_normal_form` - count_all_local_good_types_normal_form counts good-type local solutions. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_all_local_good_types_normal_form_matches_reference_values]
- [ ] `count_congruence_solutions` - count_congruence_solutions decomposes into good/bad/zero contributions. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_congruence_solution_decomposition_at_basic_input]
- [ ] `count_congruence_solutions__bad_type` - bad_type decomposes into type I and II contributions. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_congruence_bad_type_splits_I_II]
- [ ] `count_congruence_solutions_as_vector` - count_congruence_solutions_as_vector returns component counts vector. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_congruence_solutions_as_vector_length_six]
- [ ] `count_modp_solutions__by_Gauss_sum` - count_modp_solutions__by_Gauss_sum(p,m) requires nonzero determinant modulo p. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_modp_solutions_by_gauss_sum_raises_on_singular_case]
- [ ] `count_congruence_solutions__bad_type_I` - count_congruence_solutions__bad_type_I computes type-I bad contribution. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_congruence_type_I_zero_on_basic_input]
- [ ] `count_congruence_solutions__bad_type_II` - count_congruence_solutions__bad_type_II computes type-II bad contribution. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_congruence_type_II_zero_on_basic_input]
- [ ] `count_congruence_solutions__good_type` - count_congruence_solutions__good_type computes good contribution. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_congruence_good_type_zero_on_basic_input]
- [ ] `count_congruence_solutions__zero_type` - count_congruence_solutions__zero_type computes zero-type contribution. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_count_congruence_zero_type_zero_on_basic_input]
- [ ] `conway_cross_product_doubled_power` - conway_cross_product_doubled_power(p) contributes to Conway p-mass. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_cross_product_doubled_power_nonnegative]
- [ ] `conway_diagonal_factor` - conway_diagonal_factor(p) is Conway diagonal correction. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_diagonal_factor_positive]
- [ ] `conway_octane_of_this_unimodular_Jordan_block_at_2` - Returns the Conway octane invariant for a 2-adic unimodular Jordan block; raises RuntimeError when the methods preconditions are not satisfied (as in the documented counterexample). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_octane_requires_odd_unimodular_block]
- [ ] `conway_species_list_at_2` - conway_species_list_at_2() returns the Conway species decomposition list at $p=2$ (nonempty in the documented example). [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_species_lists_have_expected_lengths]
- [ ] `conway_species_list_at_odd_prime` - conway_species_list_at_odd_prime(p) returns the Conway species list for odd prime p. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_species_list_at_odd_prime_length_two]
- [ ] `conway_type_factor` - conway_type_factor() is combinatorial type multiplier. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_conway_type_factor_positive_integer]

### Quadratic form solver and transformations
Solves representation equations and executes constructive transformation routines used in local and neighbor computations.

- [ ] `solve` - solve(n) finds rational vector with Q(v)=n over QQ. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_solve_over_qq_returns_exact_value]
- [ ] `sum_by_coefficients_with` - sum_by_coefficients_with(R) adds forms coefficient-wise. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_sum_by_coefficients_with_adds_forms]
- [ ] `discrec` - discrec() returns reciprocal discriminant-style invariant. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_discrec_positive_for_positive_definite_example]
- [ ] `basiclemma` - basiclemma(M) computes local representation helper count. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_basiclemma_zero_case_returns_zero]
- [ ] `basiclemmavec` - basiclemmavec(M) returns auxiliary vector for local computations. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_basiclemmavec_has_expected_dimension]
- [ ] `basic_lemma` - basic_lemma(p) returns a local character value at prime p. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_basic_lemma_returns_modular_class]
- [ ] `orbits_lines_mod_p` - orbits_lines_mod_p(p) returns line-orbit representatives mod p. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_orbits_lines_mod_p_nonempty]
- [ ] `find_zeros_mod_p` - find_zeros_mod_p(p) enumerates nontrivial zeros modulo p. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_find_zeros_mod_p_returns_zero_values]
- [ ] `pseudorandom_primitive_zero_mod_p` - pseudorandom_primitive_zero_mod_p(p) returns primitive zero modulo p. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_pseudorandom_zero_is_indeed_zero_mod_p]
- [ ] `split_local_cover` - split_local_cover() returns a locally equivalent split cover form. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_split_local_cover_preserves_discriminant]
- [ ] `list_external_initializations` - list_external_initializations() reports backend initialization hints. [source: sage_doc/test_quadraticform_static.py::test_quadraticform_list_external_initializations_empty_for_internal_example]

### Binary quadratic form reducibility predicates
Tests binary-form reducibility and weak reduction conditions.

- [ ] `is_reducible` - is_reducible() tests reducibility over Z. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_is_reducible_false_for_primitive_nonsquare_discriminant]
- [ ] `is_weakly_reduced` - is_weakly_reduced() checks weak reduction conditions. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_is_weakly_reduced_true_for_simple_reduced_form]

### Binary quadratic form linear-change actions
Applies left/right $GL_2$-actions to binary forms.

- [ ] `matrix_action_left` - matrix_action_left(M) applies left linear change by M. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_matrix_action_left_identity_fixes_form]
- [ ] `matrix_action_right` - matrix_action_right(M) applies right linear change by M. [source: sage_doc/test_binaryqf_static.py::test_binaryqf_matrix_action_right_identity_fixes_form]

### Ternary-to-QuadraticForm equivalence map
For a ternary form $Q\in\mathbf{Z}[x,y,z]_2$, quadratic_form returns a quadratic form $\widetilde Q$ with $\widetilde Q(v)=Q(v)$ for all $v\in\mathbf{Z}^3$.

- [ ] `quadratic_form` - quadratic_form() converts a TernaryQF to an equivalent QuadraticForm. [source: sage_doc/test_ternaryqf_static.py::test_ternaryqf_quadratic_form_conversion_preserves_values]

## Matrix algorithms

### Determinant invariant
Given a matrix $M$, computes determinant-type matrix invariants.

- [ ] `qdet` - qdet() produces a quantum determinant polynomial. [source: sage_doc/test_matrix_methods_static.py::test_matrix_qdet_specializes_to_determinant_for_commutative_ring]

### Matrix rank and shape invariants
Computes row/column rank and the shape $(m,n)$ of a matrix.

- [ ] `rank` - For a matrix $A$, returns $\operatorname{rank}(A)$, implemented as the number of pivot columns (`len(self.pivots())`), equivalently row/column rank over the base domain where echelon methods apply. [sources: sage/matrix/matrix0.pyx::rank, sage_doc/test_matrix_methods_static.py::test_matrix_rank_full_for_positive_definite_example]
- [ ] `nrows` - Matrix row-count accessor returning stored `_nrows` (for $A\in M_{m,n}$ this is $m$). [sources: sage/matrix/matrix0.pyx::nrows, sage_doc/test_matrix_methods_static.py::test_matrix_nrows_returns_row_count]
- [ ] `ncols` - For $A\in M_{m,n}$, returns $n$. [source: sage_doc/test_matrix_methods_static.py::test_matrix_ncols_returns_column_count]
- [ ] `dimensions` - For $A\in M_{m,n}$, returns the ordered pair $(m,n)=(\texttt{nrows}(A),\texttt{ncols}(A))$. [source: sage_doc/test_matrix_methods_static.py::test_matrix_dimensions_matches_nrows_ncols]

### Matrix kernel/nullity algorithms
Computes kernels and nullities of linear maps over the base ring/field.

- [ ] `kernel` - kernel() returns nullspace over base ring/field context. [source: sage_doc/test_matrix_methods_static.py::test_matrix_kernel_rank_zero_for_invertible_over_Q]
- [ ] `left_kernel` - left_kernel() returns left nullspace. [source: sage_doc/test_matrix_methods_static.py::test_matrix_left_kernel_rank_zero]
- [ ] `right_kernel` - right_kernel() returns right nullspace. [source: sage_doc/test_matrix_methods_static.py::test_matrix_right_kernel_rank_zero]
- [ ] `integer_kernel` - integer_kernel() computes kernel over integers. [source: sage_doc/test_matrix_methods_static.py::test_matrix_integer_kernel_dimension_matches_nullity]
- [ ] `left_kernel_matrix` - left_kernel_matrix() basis matrix rows equal left nullity. [source: sage_doc/test_matrix_methods_static.py::test_matrix_left_kernel_matrix_row_count_equals_left_nullity]
- [ ] `right_kernel_matrix` - right_kernel_matrix() basis matrix rows equal right nullity. [source: sage_doc/test_matrix_methods_static.py::test_matrix_right_kernel_matrix_row_count_equals_right_nullity]
- [ ] `left_nullity` - left_nullity() equals left kernel rank. [source: sage_doc/test_matrix_methods_static.py::test_matrix_left_nullity_matches_left_kernel_rank]
- [ ] `right_nullity` - right_nullity() equals right kernel rank. [source: sage_doc/test_matrix_methods_static.py::test_matrix_right_nullity_matches_right_kernel_rank]

### Matrix row-reduction algorithms
Computes row-echelon and reduced row-echelon forms together with pivot index sets.

- [ ] `echelon_form` - echelon_form() row-reduces matrix over base ring. [source: sage_doc/test_matrix_methods_static.py::test_matrix_echelon_form_preserves_rank]
- [ ] `echelonize` - echelonize() performs in-place row-echelon reduction. [source: sage_doc/test_matrix_methods_static.py::test_matrix_echelonize_mutates_to_echelon_form]
- [ ] `rref` - rref() computes reduced row echelon form over fraction field. [source: sage_doc/test_matrix_methods_static.py::test_matrix_rref_is_identity_for_invertible_over_Q]
- [ ] `extended_echelon_form` - extended_echelon_form() computes echelon-like normal form. [source: sage_doc/test_matrix_methods_static.py::test_matrix_extended_echelon_form_preserves_rank]
- [ ] `pivot_rows` - pivot_rows() returns pivot row indices. [source: sage_doc/test_matrix_methods_static.py::test_matrix_pivot_rows_length_equals_rank]
- [ ] `pivots` - pivots() returns pivot column indices. [source: sage_doc/test_matrix_methods_static.py::test_matrix_pivots_length_equals_rank]

### Matrix eigen/spectral algorithms
Computes spectral data $\{\lambda\}$, eigenspaces, and spectral polynomials $\chi_M(t)$ and $\mu_M(t)$.

- [ ] `eigenvalues` - eigenvalues() returns algebraic eigenvalue multiset. [source: sage_doc/test_matrix_methods_static.py::test_matrix_eigenvalues_sum_equals_trace]
- [ ] `eigenvectors_right` - eigenvectors_right() returns right eigenpairs grouped by eigenvalue. [source: sage_doc/test_matrix_methods_static.py::test_matrix_eigenvectors_right_contains_eigenvalue_three]
- [ ] `eigenvectors_left` - eigenvectors_left() returns left eigenpairs grouped by eigenvalue. [source: sage_doc/test_matrix_methods_static.py::test_matrix_eigenvectors_left_contains_eigenvalue_one]
- [ ] `eigenmatrix_right` - eigenmatrix_right() returns a right eigenvector matrix compatible with diagonalization in the documented symmetric example. [source: sage_doc/test_matrix_methods_static.py::test_matrix_eigenmatrix_right_diagonalizes_symmetric_example]
- [ ] `eigenspaces_right` - eigenspaces_right() returns eigenspace decomposition. [source: sage_doc/test_matrix_methods_static.py::test_matrix_eigenspaces_right_dimensions_sum_to_size]
- [ ] `eigenvalue_multiplicity` - eigenvalue_multiplicity(lam) returns algebraic multiplicity. [source: sage_doc/test_matrix_methods_static.py::test_matrix_eigenvalue_multiplicity_for_distinct_eigenvalue_is_one]
- [ ] `characteristic_polynomial` - characteristic_polynomial() encodes eigenvalues. [source: sage_doc/test_matrix_methods_static.py::test_matrix_characteristic_polynomial_has_expected_roots]
- [ ] `charpoly` - charpoly() aliases characteristic_polynomial(). [source: sage_doc/test_matrix_methods_static.py::test_matrix_charpoly_matches_characteristic_polynomial]
- [ ] `minimal_polynomial` - minimal_polynomial() divides characteristic polynomial. [source: sage_doc/test_matrix_methods_static.py::test_matrix_minimal_polynomial_divides_characteristic_polynomial]
- [ ] `minpoly` - minpoly() aliases minimal_polynomial(). [source: sage_doc/test_matrix_methods_static.py::test_matrix_minpoly_matches_minimal_polynomial]
- [ ] `hessenberg_form` - hessenberg_form() is similar to original matrix. [source: sage_doc/test_matrix_methods_static.py::test_matrix_hessenberg_form_preserves_characteristic_polynomial]
- [ ] `frobenius_form` - frobenius_form() returns a rational canonical form matrix similar to the original matrix, hence preserving characteristic polynomial. [source: sage_doc/test_matrix_methods_static.py::test_matrix_frobenius_form_preserves_characteristic_polynomial]
- [ ] `singular_values` - singular_values() returns singular-value list. [source: sage_doc/test_matrix_methods_static.py::test_matrix_singular_values_count_equals_min_dimension]

### Matrix decomposition algorithms
Computes standard decompositions (LU, Cholesky for suitable symmetric positive-definite input, and Gram-Schmidt orthogonalization).

- [ ] `LU` - LU() returns factors (with permutation) whose product reconstructs the original matrix. [source: sage_doc/test_matrix_methods_static.py::test_matrix_lu_reconstructs_original_matrix]
- [ ] `cholesky` - cholesky() returns factor R with R^T R = A for positive-definite A. [source: sage_doc/test_matrix_methods_static.py::test_matrix_cholesky_reconstructs_positive_definite_matrix]
- [ ] `gram_schmidt` - gram_schmidt() orthogonalizes row vectors. [source: sage_doc/test_matrix_methods_static.py::test_matrix_gram_schmidt_returns_two_orthogonal_vectors]
- [ ] `decomposition` - decomposition() returns decomposition of the ambient module. [source: sage_doc/test_matrix_methods_static.py::test_matrix_decomposition_direct_sum_dimensions_match]

### Matrix inversion/unit predicates
Computes inverses and tests unit/invertibility conditions.

- [ ] `inverse` - inverse() computes matrix inverse over fraction field. [source: sage_doc/test_matrix_methods_static.py::test_matrix_inverse_is_rational_inverse]
- [ ] `inverse_of_unit` - inverse_of_unit() inverts matrix units over base ring. [source: sage_doc/test_matrix_methods_static.py::test_matrix_inverse_of_unit_identity_fixed]
- [ ] `is_invertible` - is_invertible() over ZZ means determinant is a unit. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_invertible_matches_unit_condition_over_ZZ]
- [ ] `is_unit` - is_unit() checks invertibility in matrix ring over base ring. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_unit_true_exactly_for_identity_over_ZZ]
- [ ] `is_one` - is_one() checks multiplicative identity matrix. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_one_true_for_identity]

### Matrix space predicates
Tests structural predicates: square/non-square, symmetry/Hermitianity, and storage structure (dense versus sparse).

- [ ] `is_square` - is_square() checks nrows == ncols. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_square_true_for_two_by_two]
- [ ] `is_symmetric` - is_symmetric() checks M == M^T. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_symmetric_true_for_symmetric_input]
- [ ] `is_diagonal` - is_diagonal() checks off-diagonal zeros. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_diagonal_false_for_off_diagonal_nonzero]
- [ ] `is_dense` - is_dense() checks storage type. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_dense_true_for_dense_constructor]
- [ ] `is_sparse` - is_sparse() checks sparse storage representation. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_sparse_false_for_dense_constructor]
- [ ] `is_hermitian` - is_hermitian() generalizes symmetry over involutive rings. [source: sage_doc/test_matrix_methods_static.py::test_matrix_is_hermitian_true_for_symmetric_integer_matrix]

### Matrix spaces and images
Computes $\operatorname{Row}(M)$, $\operatorname{Col}(M)$, $\operatorname{Im}(M)$, and ambient matrix-space constructions.

- [ ] `column_space` - column_space() returns span of columns. [source: sage_doc/test_matrix_methods_static.py::test_matrix_column_space_dimension_equals_rank]
- [ ] `row_space` - row_space() returns subspace spanned by rows. [source: sage_doc/test_matrix_methods_static.py::test_matrix_row_space_dimension_equals_rank]
- [ ] `image` - image() is column-space image of linear map. [source: sage_doc/test_matrix_methods_static.py::test_matrix_image_dimension_equals_rank]
- [ ] `matrix_space` - matrix_space() returns parent matrix space. [source: sage_doc/test_matrix_methods_static.py::test_matrix_space_dimensions_match_parent_shape]
- [ ] `matrix_over_field` - matrix_over_field() coerces matrix to base field. [source: sage_doc/test_matrix_methods_static.py::test_matrix_over_field_changes_base_ring_to_fraction_field]

### Matrix mutation operations
Performs elementary row/column operations for matrix equivalence transformations.

- [ ] `swap_rows` - swap_rows(i,j) swaps rows in place. [source: sage_doc/test_matrix_methods_static.py::test_matrix_swap_rows_changes_row_order_in_place]
- [ ] `swap_columns` - swap_columns(i,j) swaps columns in place. [source: sage_doc/test_matrix_methods_static.py::test_matrix_swap_columns_changes_column_order_in_place]
- [ ] `with_swapped_rows` - with_swapped_rows(i,j) returns swapped-row copy. [source: sage_doc/test_matrix_methods_static.py::test_matrix_with_swapped_rows_returns_new_matrix_with_swapped_order]
- [ ] `with_swapped_columns` - with_swapped_columns(i,j) returns swapped-column copy. [source: sage_doc/test_matrix_methods_static.py::test_matrix_with_swapped_columns_returns_new_matrix_with_swapped_order]
- [ ] `with_added_multiple_of_row` - with_added_multiple_of_row(i,j,c) returns updated copy. [source: sage_doc/test_matrix_methods_static.py::test_matrix_with_added_multiple_of_row_matches_in_place_update]
- [ ] `with_added_multiple_of_column` - with_added_multiple_of_column(i,j,c) returns updated copy. [source: sage_doc/test_matrix_methods_static.py::test_matrix_with_added_multiple_of_column_matches_in_place_update]
- [ ] `with_rescaled_row` - with_rescaled_row(i,c) returns copy with one row scaled. [source: sage_doc/test_matrix_methods_static.py::test_matrix_with_rescaled_row_matches_in_place_update]
- [ ] `with_rescaled_col` - with_rescaled_col(j,c) returns copy with one column scaled. [source: sage_doc/test_matrix_methods_static.py::test_matrix_with_rescaled_col_matches_in_place_update]
- [ ] `add_multiple_of_row` - add_multiple_of_row(i,j,c) performs row_i += c*row_j in place. [source: sage_doc/test_matrix_methods_static.py::test_matrix_add_multiple_of_row_updates_target_row]
- [ ] `add_multiple_of_column` - add_multiple_of_column(i,j,c) performs col_i += c*col_j in place. [source: sage_doc/test_matrix_methods_static.py::test_matrix_add_multiple_of_column_updates_target_column]
- [ ] `add_to_entry` - add_to_entry(i,j,c) increments one entry in place. [source: sage_doc/test_matrix_methods_static.py::test_matrix_add_to_entry_changes_single_entry]
- [ ] `insert_row` - insert_row(i,row) inserts a row at index i. [source: sage_doc/test_matrix_methods_static.py::test_matrix_insert_row_increases_row_count_by_one]
- [ ] `delete_rows` - delete_rows(indices) removes selected rows. [source: sage_doc/test_matrix_methods_static.py::test_matrix_delete_rows_reduces_row_count]
- [ ] `delete_columns` - delete_columns(indices) removes selected columns. [source: sage_doc/test_matrix_methods_static.py::test_matrix_delete_columns_reduces_column_count]
- [ ] `reverse_rows_and_columns` - reverse_rows_and_columns() reverses row and column order in place. [source: sage_doc/test_matrix_methods_static.py::test_matrix_reverse_rows_and_columns_is_involution]
- [ ] `linear_combination_of_rows` - linear_combination_of_rows(c) forms sum c_i * row_i. [source: sage_doc/test_matrix_methods_static.py::test_matrix_linear_combination_of_rows_matches_manual_combination]
- [ ] `linear_combination_of_columns` - linear_combination_of_columns(c) forms sum c_j * col_j. [source: sage_doc/test_matrix_methods_static.py::test_matrix_linear_combination_of_columns_matches_manual_combination]
- [ ] `apply_map` - apply_map(f) applies map entrywise. [source: sage_doc/test_matrix_methods_static.py::test_matrix_apply_map_adds_one_entrywise]

### Matrix block/assembly operations
Builds matrices from rows/columns/blocks and extracts submatrices.

- [ ] `block_sum` - For matrices $A,B$, returns $\begin{pmatrix}A&0\\0&B\end{pmatrix}$, so row and column counts add componentwise. [source: sage_doc/test_matrix_methods_static.py::test_matrix_block_sum_has_additive_dimensions]
- [ ] `augment` - augment(N) concatenates matrices by columns. [source: sage_doc/test_matrix_methods_static.py::test_matrix_augment_increases_column_count_by_other_columns]
- [ ] `stack` - stack(N) concatenates matrices by rows. [source: sage_doc/test_matrix_methods_static.py::test_matrix_stack_increases_row_count_by_other_rows]
- [ ] `matrix_from_rows` - matrix_from_rows(idx) extracts rows by index. [source: sage_doc/test_matrix_methods_static.py::test_matrix_matrix_from_rows_selects_requested_rows]
- [ ] `matrix_from_columns` - matrix_from_columns(idx) extracts columns by index. [source: sage_doc/test_matrix_methods_static.py::test_matrix_matrix_from_columns_selects_requested_columns]
- [ ] `matrix_from_rows_and_columns` - matrix_from_rows_and_columns(rows, cols) extracts a submatrix. [source: sage_doc/test_matrix_methods_static.py::test_matrix_from_rows_and_columns_extracts_expected_entry]
- [ ] `submatrix` - submatrix(r,c,nr,nc) extracts a rectangular block. [source: sage_doc/test_matrix_methods_static.py::test_matrix_submatrix_extracts_requested_block_shape]

### Matrix accessors and layout
Extracts coordinates, row/column slices, and support sets $\{(i,j):a_{ij}\neq 0\}$ in dense/sparse representations.

- [ ] `rows` - rows() returns list of row vectors. [source: sage_doc/test_matrix_methods_static.py::test_matrix_rows_length_matches_nrows]
- [ ] `columns` - columns() returns list of column vectors. [source: sage_doc/test_matrix_methods_static.py::test_matrix_columns_length_matches_ncols]
- [ ] `row` - row(i) returns i-th row vector. [source: sage_doc/test_matrix_methods_static.py::test_matrix_row_accessor_matches_rows_list_entry]
- [ ] `column` - column(j) returns j-th column vector. [source: sage_doc/test_matrix_methods_static.py::test_matrix_column_accessor_matches_columns_list_entry]
- [ ] `diagonal` - diagonal() returns diagonal entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_diagonal_entries_match_constructor]
- [ ] `dense_rows` - dense_rows() returns the matrix rows as dense vectors; its list length equals nrows(). [source: sage_doc/test_matrix_methods_static.py::test_matrix_dense_rows_length_matches_nrows]
- [ ] `dense_columns` - dense_columns() returns the matrix columns as dense vectors; its list length equals ncols(). [source: sage_doc/test_matrix_methods_static.py::test_matrix_dense_columns_length_matches_ncols]
- [ ] `dense_matrix` - dense_matrix() returns dense representation with same entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_dense_matrix_preserves_entries]
- [ ] `sparse_matrix` - sparse_matrix() returns sparse representation with same entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_sparse_matrix_preserves_entries]
- [ ] `list` - list() returns flattened entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_list_length_equals_entry_count]
- [ ] `items` - items() returns dictionary-style iterator over nonzero entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_items_count_equals_nonzero_positions]
- [ ] `numpy` - numpy() exports to NumPy array. [source: sage_doc/test_matrix_methods_static.py::test_matrix_numpy_export_preserves_shape]
- [ ] `nonzero_positions` - nonzero_positions() lists coordinates of nonzero entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_nonzero_positions_cardinality_equals_nonzero_entries_count]
- [ ] `nonzero_positions_in_row` - nonzero_positions_in_row(i) gives support of row i. [source: sage_doc/test_matrix_methods_static.py::test_matrix_nonzero_positions_in_row_matches_row_support]
- [ ] `nonzero_positions_in_column` - nonzero_positions_in_column(j) gives support of column j. [source: sage_doc/test_matrix_methods_static.py::test_matrix_nonzero_positions_in_column_matches_column_support]

### Matrix bilinear and commutator operations
Computes $M^T$, $M^\ast$, commutators $[A,B]=AB-BA$, anticommutators $\{A,B\}=AB+BA$, and trace pairings.

- [ ] `anticommutator` - anticommutator(B) equals AB + BA. [source: sage_doc/test_matrix_methods_static.py::test_matrix_anticommutator_definition_matches_sum]
- [ ] `antitranspose` - antitranspose() is an involution. [source: sage_doc/test_matrix_methods_static.py::test_matrix_antitranspose_involution]
- [ ] `commutator` - commutator(B) equals AB - BA. [source: sage_doc/test_matrix_methods_static.py::test_matrix_commutator_definition_matches_difference]
- [ ] `conjugate_transpose` - conjugate_transpose() reduces to transpose over real/integer entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_conjugate_transpose_equals_transpose_over_integers]
- [ ] `trace_of_product` - trace_of_product(B) computes tr(A*B) efficiently. [source: sage_doc/test_matrix_methods_static.py::test_matrix_trace_of_product_matches_direct_trace]
- [ ] `trace` - trace() is sum of diagonal entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_trace_equals_sum_of_diagonal]
- [ ] `transpose` - transpose() swaps row/column positions. [source: sage_doc/test_matrix_methods_static.py::test_matrix_transpose_swaps_off_diagonal_entries]

### Matrix arithmetic invariants
Computes arithmetic invariants and reconstruction/saturation outputs (e.g., permanent, fitting ideal, saturation, rational reconstruction).

- [ ] `gcd` - For integer matrix entries, returns their greatest common divisor. [source: sage_doc/test_matrix_methods_static.py::test_matrix_gcd_divides_all_entries]
- [ ] `permanent` - permanent() computes sum over permutation products without sign. [source: sage_doc/test_matrix_methods_static.py::test_matrix_permanent_known_value_for_2x2]
- [ ] `rook_vector` - rook_vector() returns rook polynomial coefficients. [source: sage_doc/test_matrix_methods_static.py::test_matrix_rook_vector_length_matches_min_dimension_plus_one]
- [ ] `prod_of_row_sums` - prod_of_row_sums(cols) multiplies row sums restricted to selected columns. [source: sage_doc/test_matrix_methods_static.py::test_matrix_prod_of_row_sums_matches_manual_product]
- [ ] `height` - height() is maximum absolute value of entries for integer matrix. [source: sage_doc/test_matrix_methods_static.py::test_matrix_height_equals_max_abs_entry]
- [ ] `index_in_saturation` - index_in_saturation() measures finite index to saturation. [source: sage_doc/test_matrix_methods_static.py::test_matrix_index_in_saturation_for_scaled_identity]
- [ ] `saturation` - saturation() computes saturated lattice generated by rows. [source: sage_doc/test_matrix_methods_static.py::test_matrix_saturation_of_scaled_identity_is_identity]
- [ ] `rational_reconstruction` - rational_reconstruction(N) lifts entries from residue representatives modulo N. [source: sage_doc/test_matrix_methods_static.py::test_matrix_rational_reconstruction_recovers_integer_matrix_for_large_modulus]
- [ ] `fitting_ideal` - fitting_ideal(0) for square full-rank matrix is generated by determinant. [source: sage_doc/test_matrix_methods_static.py::test_matrix_fitting_ideal_zero_has_generator_determinant_for_full_rank]
- [ ] `null_ideal` - null_ideal() consists of integer polynomials annihilating the matrix. [source: sage_doc/test_matrix_methods_static.py::test_matrix_null_ideal_generator_annihilates_matrix]
- [ ] `p_minimal_polynomials` - p_minimal_polynomials(p) returns the dictionary s  minimal polynomial modulo p^s. [source: sage_doc/test_matrix_methods_static.py::test_matrix_p_minimal_polynomials_returns_dict]
- [ ] `integer_valued_polynomials_generators` - integer_valued_polynomials_generators() returns generators for null ideal over Z. [source: sage_doc/test_matrix_methods_static.py::test_matrix_integer_valued_polynomials_generators_annihilate_mod_z]
- [ ] `symplectic_form` - symplectic_form() returns an alternating form together with a basis change to standard symplectic shape. [source: sage_doc/test_matrix_methods_static.py::test_matrix_symplectic_form_returns_standard_form_for_basis]
- [ ] `randomize` - randomize(density=0) performs no entry modifications. [source: sage_doc/test_matrix_methods_static.py::test_matrix_randomize_density_zero_preserves_entries]

### Matrix Smith-type divisor data
Computes elementary divisors $(d_i)$ in Smith-theoretic decomposition.

- [ ] `elementary_divisors` - elementary_divisors() are invariant factors over PID. [source: sage_doc/test_matrix_methods_static.py::test_matrix_elementary_divisors_multiply_to_determinant_absolute]

### Matrix zero-pattern extraction
Computes the support pattern $\{(i,j):a_{ij}\neq 0\}$.

- [ ] `zero_pattern_matrix` - zero_pattern_matrix() returns indicator matrix for zero entries. [source: sage_doc/test_matrix_methods_static.py::test_matrix_zero_pattern_matrix_marks_nonzero_support]

### Linear system solving
Solves linear systems $Ax=b$ over the base ring/field of $A$.

- [ ] `solve_right` - solve_right(b) solves A x = b. [source: sage_doc/test_matrix_methods_static.py::test_matrix_solve_right_solves_linear_system]

## Number fields $K/\mathbf{Q}$

### Number field defining data
Computes defining generators/polynomials and conversion maps between absolute and relative presentations of $K$.

- [ ] `base_field` - base_field() of absolute number field is QQ. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_base_field_is_rational_field]
- [ ] `gen` - gen() returns distinguished generator a of K=QQ[a]. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_gen_is_root_of_defining_polynomial]
- [ ] `ngens` - ngens() returns number of abstract generators. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_ngens_is_one]
- [ ] `defining_polynomial` - defining_polynomial() returns defining polynomial of extension. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_defining_polynomial_matches_constructor]
- [ ] `absolute_polynomial` - absolute_polynomial() returns defining polynomial over Q. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_absolute_polynomial_matches_polynomial]
- [ ] `absolute_polynomial_ntl` - absolute_polynomial_ntl() returns the absolute defining polynomial represented in NTL format. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_absolute_polynomial_ntl_degree_matches_degree]
- [ ] `relative_polynomial` - relative_polynomial() is defining polynomial over base field. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_relative_polynomial_matches_defining_polynomial]
- [ ] `polynomial_ntl` - polynomial_ntl() returns the defining polynomial in NTL representation, with degree equal to the field degree. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_polynomial_ntl_degree_matches_degree]
- [ ] `polynomial_ring` - polynomial_ring() is the ambient polynomial ring over QQ. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_polynomial_ring_base_is_rational_field]
- [ ] `polynomial_quotient_ring` - polynomial_quotient_ring() realizes K as QQ[x]/(f). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_polynomial_quotient_ring_modulus_matches_defining_polynomial]
- [ ] `construction` - construction() returns functor and base. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_construction_base_is_rational_field]
- [ ] `extension` - extension(f,name) adjoins root of polynomial over K. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_extension_degree_multiplies_for_quadratic_over_quadratic]
- [ ] `absolute_field` - absolute_field(name) returns absolute field model. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_absolute_field_preserves_degree]
- [ ] `absolute_generator` - absolute_generator() returns chosen generator in absolute model. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_absolute_generator_satisfies_defining_polynomial]
- [ ] `primitive_element` - primitive_element() returns an element generating the field. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_primitive_element_generates_field]
- [ ] `change_generator` - change_generator(b) returns an isomorphic presentation. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_change_generator_preserves_degree]
- [ ] `change_names` - change_names(new) renames field generator. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_change_names_preserves_polynomial]
- [ ] `relativize` - relativize(alpha,names) returns relative model over Q(alpha). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_relativize_preserves_absolute_degree]

### Number field degree invariants (absolute/relative)
Computes $[K:\mathbf Q]$ and relative degree invariants.

- [ ] `degree` - Returns `self.polynomial().degree()`, i.e. $[K:\mathbf Q]$ for absolute fields. [sources: sage/rings/number_field/number_field.py::degree, sage_doc/test_numberfield_bridge_static.py::test_numberfield_degree_matches_polynomial_degree]
- [ ] `absolute_degree` - absolute_degree() returns [K:Q] for absolute fields. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_absolute_degree_matches_degree]
- [ ] `relative_degree` - relative_degree() equals degree in absolute case. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_relative_degree_matches_degree_for_absolute_field]

### Number field characteristic invariant
Computes $\operatorname{char}(K)$ (for number fields, $\operatorname{char}(K)=0$).

- [ ] `characteristic` - characteristic() of number fields is always zero. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_characteristic_zero]

### Number field absoluteness/relativity predicates
Tests whether $K$ is presented as an absolute extension of $\mathbf Q$ or as a relative extension over a proper subfield.

- [ ] `is_absolute` - is_absolute() detects absolute number fields. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_is_absolute_true_for_absolute_field]
- [ ] `is_relative` - is_relative() distinguishes relative extensions from absolute ones. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_is_relative_false_for_absolute_field]
- [ ] `is_field` - is_field() checks field property. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_is_field_true]

### Number field real/imaginary signature-type predicates
Tests total reality/imaginarity via the signature $(r_1,r_2)$ of archimedean embeddings.

- [ ] `is_totally_real` - is_totally_real()/is_totally_imaginary classify embeddings. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_real_imaginary_status_totally_real]
- [ ] `is_totally_imaginary` - is_totally_imaginary() checks whether all archimedean places are complex. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_is_totally_imaginary_false_for_real_quadratic]

### Number field Galois/abelian/CM predicates
Tests Galois, abelian, and CM-type properties.

- [ ] `is_galois` - is_galois() checks normal/separable over Q. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_is_galois_true_for_quadratic_extension]
- [ ] `is_abelian` - is_abelian() checks whether Galois group over Q is abelian. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_is_abelian_true_for_quadratic_extension]
- [ ] `is_CM` - is_CM() tests whether field is a CM field. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_is_cm_false_for_real_quadratic_field]

### Number field embeddings and places
Computes field embeddings $K\hookrightarrow\mathbf R,\mathbf C$, places, and local completions $K_v$.

- [ ] `embeddings` - embeddings(L) returns embeddings into target field L. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_embeddings_count_matches_automorphisms]
- [ ] `real_embeddings` - real_embeddings() returns real field embeddings. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_real_embeddings_count_matches_signature]
- [ ] `complex_embeddings` - complex_embeddings() lists complex embeddings. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_complex_embeddings_count_matches_degree]
- [ ] `specified_complex_embedding` - specified_complex_embedding() returns the designated complex embedding when fixed; otherwise it returns None (documented default case). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_specified_complex_embedding_is_none_without_choice]
- [ ] `real_places` - real_places() lists real archimedean places. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_real_places_count_matches_real_embeddings]
- [ ] `places` - places() lists infinite places. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_places_count_matches_signature_real_plus_complex]
- [ ] `completion` - completion(infinity, prec) gives archimedean completion. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_completion_archimedean_has_requested_precision]
- [ ] `gen_embedding` - gen_embedding() returns image of generator if embedding was specified. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_gen_embedding_none_without_specified_embedding]
- [ ] `minkowski_embedding` - minkowski_embedding() returns embedding matrix into R^r x C^s. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_minkowski_embedding_matrix_has_degree_rows]
- [ ] `logarithmic_embedding` - logarithmic_embedding() sends products to sums. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_logarithmic_embedding_is_homomorphism_on_multiplication]
- [ ] `absolute_vector_space` - absolute_vector_space() returns absolute vector-space model tuple. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_absolute_vector_space_dimension_matches_degree]
- [ ] `relative_vector_space` - relative_vector_space() returns vector-space model over base field. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_relative_vector_space_dimension_matches_degree]

### Number field Galois and subfield algorithms
Computes automorphism and Galois-group structures, plus subfield and compositum constructions.

- [ ] `is_isomorphic` - For number fields $K,L$, decides existence of a $\mathbf Q$-algebra isomorphism $K\cong L$. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_is_isomorphic_true_to_itself]
- [ ] `complex_conjugation` - complex_conjugation() returns involution on embeddings. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_complex_conjugation_has_order_two]
- [ ] `galois_group` - galois_group() returns automorphism group of the splitting field. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_galois_group_order_equals_two_for_quadratic]
- [ ] `galois_closure` - galois_closure() returns normal closure over Q. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_galois_closure_degree_matches_quadratic_degree]
- [ ] `subfield` - subfield(alpha) returns generated subfield and embeddings. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_subfield_generated_by_generator_has_same_degree]
- [ ] `subfields` - subfields() enumerates intermediate subfields. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_subfields_contains_rational_subfield]
- [ ] `subfield_from_elements` - subfield_from_elements([alpha_i]) builds generated subfield. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_subfield_from_elements_recovers_full_field_degree]
- [ ] `composite_fields` - composite_fields(L) lists composita with L. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_composite_fields_contains_self_for_self_compositum]
- [ ] `maximal_totally_real_subfield` - maximal_totally_real_subfield() returns largest totally real subfield with embedding. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_maximal_totally_real_subfield_has_same_degree]
- [ ] `hilbert_class_field` - hilbert_class_field(name) returns unramified abelian extension. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_hilbert_class_field_degree_matches_base_for_class_number_one]
- [ ] `hilbert_class_field_defining_polynomial` - hilbert_class_field_defining_polynomial() defines maximal unramified abelian extension. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_hilbert_class_field_defining_polynomial_degree_one_for_class_number_one]
- [ ] `hilbert_class_polynomial` - hilbert_class_polynomial() has degree equal to class number for imaginary quadratic fields. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_hilbert_class_polynomial_degree_matches_class_number]
- [ ] `hilbert_conductor` - hilbert_conductor(a,b) is reduced discriminant ideal of quaternion algebra (a,b). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_hilbert_conductor_divides_discriminant]

### Number field optimized defining models
Computes isomorphic presentations of $K$ with optimized defining polynomials, together with forward and inverse isomorphisms.

- [ ] `optimized_representation` - optimized_representation() returns equivalent presentation with potentially better defining polynomial. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_optimized_representation_preserves_absolute_degree]
- [ ] `optimized_subfields` - optimized_subfields() returns optimized intermediate subfields. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_optimized_subfields_contains_rational_subfield]

### Number field algebraic closure embedding
Returns the embedding of $K$ into $\overline{\mathbf Q}$ (realized as QQbar).

- [ ] `algebraic_closure` - algebraic_closure() returns an algebraic closure of characteristic zero. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_algebraic_closure_has_characteristic_zero]

### PARI NF/BNF interface data
Computes PARI structures attached to $K$ (nfinit, bnf, zk basis, PARI defining polynomial, and relative norm-init data).

- [ ] `pari_nf` - pari_nf() returns PARI nf structure associated to field. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_pari_nf_has_matching_polynomial_degree]
- [ ] `pari_bnf` - pari_bnf() returns PARI bnf structure. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_pari_bnf_class_number_matches_sage_class_number]
- [ ] `pari_polynomial` - pari_polynomial(var) exports defining polynomial to PARI. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_pari_polynomial_degree_matches_field_degree]
- [ ] `pari_zk` - pari_zk() returns PARI integral basis list. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_pari_zk_length_matches_degree]
- [ ] `pari_rnfnorm_data` - pari_rnfnorm_data(L) returns PARI rnfisnorminit structure for the extension L/K. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_pari_rnfnorm_data_has_eight_components]

### Number field structure maps
Returns stored isomorphism/embedding structure maps attached to the field object.

- [ ] `structure` - structure() returns mutually inverse structure maps. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_structure_maps_generator_to_itself]

### Number field absolute values and heights
Computes local absolute values $|x|_v$ (finite and infinite places) and enumerates elements with bounded relative multiplicative height.

- [ ] `abs_val` - abs_val(v, iota) evaluates absolute value at a place. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_abs_val_matches_archimedean_absolute_value]
- [ ] `elements_of_bounded_height` - elements_of_bounded_height() enumerates algebraic numbers by height. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_elements_of_bounded_height_contains_zero_and_one]

### Dirichlet characters attached to abelian fields
For abelian $K/\mathbf Q$, returns Dirichlet characters matching $\operatorname{Gal}(K/\mathbf Q)$.

- [ ] `dirichlet_group` - dirichlet_group() returns Dirichlet characters attached to field. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_dirichlet_group_contains_trivial_character]

### Selmer groups $K(S,m)$
Computes $K(S,m)\subset K^\times/(K^\times)^m$ (generators, iterators, and $GF(p)$-vector-space model for $m=p$ prime).

- [ ] `selmer_generators` - selmer_generators(S,m) returns generators of Selmer quotient K(S,m). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_selmer_generators_generate_expected_rank_mod_squares]
- [ ] `selmer_group_iterator` - selmer_group_iterator(S,m) iterates distinct elements of K(S,m). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_selmer_group_iterator_contains_identity]
- [ ] `selmer_space` - selmer_space(S,p) returns vector space with map to K*. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_selmer_space_maps_zero_to_identity]

### Number field LMFDB identification
Maps the field to its LMFDB entry determined by its arithmetic invariants.

- [ ] `lmfdb_page` - lmfdb_page() resolves the field to an LMFDB NumberField URL and opens that endpoint. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_lmfdb_page_uses_lmfdb_url]

## Rings of integers $\mathcal{O}_K$ and ideal arithmetic

### Number field orders and bases
Computes orders $\mathcal O\subseteq K$, integral bases, trace-dual bases, and reduced basis variants.

- [ ] `order` - order() is multiplicative order as a group element API on parents. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_order_matches_ring_of_integers]
- [ ] `maximal_order` - maximal_order() returns ring of integers. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_maximal_order_matches_ring_of_integers]
- [ ] `ring_of_integers` - ring_of_integers() returns the maximal order with a Z-basis of full degree. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_ring_of_integers_basis_rank]
- [ ] `OK` - OK() aliases ring_of_integers(). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_ok_alias_matches_ring_of_integers]
- [ ] `integral_basis` - integral_basis() returns a Z-basis of the ring of integers. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_integral_basis_has_field_degree_length]
- [ ] `free_module` - free_module() returns the underlying free Z-module of an ideal. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_ideal_free_module_has_expected_rank]
- [ ] `power_basis` - power_basis() returns 1,a,...,a^(n-1). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_power_basis_length_matches_degree]
- [ ] `trace_dual_basis` - trace_dual_basis(B) returns dual basis for trace pairing. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_trace_dual_basis_has_field_degree_length]
- [ ] `trace_pairing` - trace_pairing(B) returns Gram matrix of trace bilinear form on basis B. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_trace_pairing_is_symmetric_matrix]
- [ ] `reduced_basis` - reduced_basis() returns a reduced $\mathbf Z$-basis of full field degree. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_reduced_basis_has_field_degree_length]
- [ ] `reduced_gram_matrix` - reduced_gram_matrix() gives Gram matrix of reduced integral basis. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_reduced_gram_matrix_has_correct_determinant]

### Number field ideal arithmetic
Computes ideal arithmetic in $\mathcal O_K$: prime factorization of ideals, residue fields $\mathcal O_K/\mathfrak p$, valuations, and CRT constructions.

- [ ] `ideal` - ideal(a) and fractional_ideal(a) agree on principal ideal norms. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_ideal_and_fractional_ideal_have_same_norm_for_two]
- [ ] `fractional_ideal` - fractional_ideal(a) constructs principal fractional ideal. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_fractional_ideal_norm_matches_principal_norm]
- [ ] `prime_above` - prime_above(p) returns a prime ideal over rational prime p. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_prime_above_has_residue_characteristic]
- [ ] `primes_above` - primes_above(p) lists prime ideals above p. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_primes_above_2_total_residue_degree_equals_degree]
- [ ] `prime_factors` - prime_factors(n) factors principal ideal (n) into prime ideals. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_prime_factors_norms_multiply_to_integer_norm]
- [ ] `primes_of_bounded_norm` - primes_of_bounded_norm(B) lists prime ideals with norm <= B. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_primes_of_bounded_norm_respect_bound]
- [ ] `primes_of_bounded_norm_iter` - primes_of_bounded_norm_iter(B) iterates same primes as list API. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_primes_of_bounded_norm_iter_matches_list_method]
- [ ] `primes_of_degree_one_list` - primes_of_degree_one_list(n) gives first n degree-one primes. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_primes_of_degree_one_list_matches_iterator_prefix]
- [ ] `primes_of_degree_one_iter` - primes_of_degree_one_iter() yields prime ideals of residue degree one. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_primes_of_degree_one_iter_yields_degree_one_primes]
- [ ] `completely_split_primes` - completely_split_primes(B) lists rational primes splitting completely below B. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_completely_split_primes_contain_11_below_30]
- [ ] `ideals_of_bdd_norm` - ideals_of_bdd_norm(B) groups ideals by absolute norm up to B. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_ideals_of_bdd_norm_contains_unit_ideal_at_norm_one]
- [ ] `decomposition_type` - decomposition_type(p) returns splitting data of rational prime p in $\mathcal O_K$ (residue degrees and ramification exponents). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_decomposition_type_ramification_identity_for_11]
- [ ] `residue_field` - residue_field(P) returns finite field O_K/P. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_residue_field_size_matches_prime_norm]
- [ ] `uniformizer` - uniformizer(P) returns an element of valuation one at P. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_uniformizer_has_positive_valuation_at_prime]
- [ ] `valuation` - valuation(P) returns p-adic valuation on K at prime ideal P. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_valuation_of_uniformizer_is_one]
- [ ] `idealchinese` - idealchinese(ideals, residues) solves CRT for ideals. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_idealchinese_satisfies_two_congruences]
- [ ] `solve_CRT` - solve_CRT(residues, ideals) solves simultaneous ideal congruences. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_solve_crt_satisfies_congruences]
- [ ] `elements_of_norm` - elements_of_norm(n) lists elements with relative norm n. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_elements_of_norm_contains_one]

### Principal ideal factorization in $\mathcal O_K$
Factors the principal ideal $(x)$ into prime ideals of $\mathcal O_K$.

- [ ] `factor` - factor(n) factors principal ideal (n) in O_K. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_factor_ideal_norm_matches_integer_norm]

### Number field class groups and units
Computes class groups, unit groups, $S$-unit structures, and regulators.

- [ ] `class_group` - class_group() cardinality is the class number. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_class_group_order_matches_class_number]
- [ ] `class_number` - class_number() gives ideal class number. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_class_number_for_qsqrt5_is_one]
- [ ] `narrow_class_group` - narrow_class_group() computes strict ideal class group. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_narrow_class_group_is_trivial_for_qsqrt5]
- [ ] `S_class_group` - S_class_group([]) matches ordinary class-group order. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_s_class_group_empty_set_matches_class_group_order]
- [ ] `unit_group` - unit_group() satisfies Dirichlet rank r+s-1. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_unit_group_rank_matches_dirichlet_for_signature]
- [ ] `units` - units() returns fundamental units tuple. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_units_generate_nontrivial_free_part]
- [ ] `S_units` - S_units([]) returns generators of the ordinary unit group. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_s_units_empty_set_contains_fundamental_unit]
- [ ] `S_unit_group` - S_unit_group(S) generalizes unit group by inverting primes in S. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_s_unit_group_empty_set_rank_matches_unit_group]
- [ ] `S_unit_solutions` - S_unit_solutions(S) solves x+y=1 in S-units. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_s_unit_solutions_contains_classical_solution]
- [ ] `regulator` - regulator() is positive for fields with positive unit rank. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_regulator_positive_for_real_quadratic]
- [ ] `roots_of_unity` - roots_of_unity() lists roots of unity in K. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_roots_of_unity_matches_count]
- [ ] `number_of_roots_of_unity` - number_of_roots_of_unity() counts torsion units. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_number_of_roots_of_unity_is_two]
- [ ] `primitive_root_of_unity` - primitive_root_of_unity() returns generator of roots of unity subgroup. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_primitive_root_of_unity_has_zeta_order]
- [ ] `zeta` - zeta() returns distinguished root of unity. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_zeta_is_root_of_unity]
- [ ] `zeta_order` - zeta_order() returns order of chosen primitive root of unity. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_zeta_order_equals_number_of_roots_of_unity]
- [ ] `zeta_coefficients` - zeta_coefficients(n) returns initial coefficients of the Dedekind zeta series expansion; documented constant term equals 1. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_zeta_coefficients_nonzero_constant_term]

### Number field discriminant/different/conductor algorithms
Computes different and conductor invariants together with Hilbert-symbol quantities.

- [ ] `discriminant` - For a basis $(b_i)$ of an order in $K$, returns $\Delta_K=\det\!\big(\operatorname{Tr}_{K/\mathbf Q}(b_i b_j)\big)$ (independent of chosen integral basis up to the order/field convention). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_trace_gram_matches_discriminant]
- [ ] `absolute_discriminant` - In the tested Sage number-field API, `absolute_discriminant()` is a synonym for `discriminant()` (same signed value in examples). [sources: sage/rings/number_field/number_field.py::absolute_discriminant, sage_doc/test_numberfield_bridge_static.py::test_numberfield_absolute_discriminant_matches_discriminant]
- [ ] `relative_discriminant` - In the tested Sage number-field API, `relative_discriminant()` is a synonym for `discriminant()`. [sources: sage/rings/number_field/number_field.py::relative_discriminant, sage_doc/test_numberfield_bridge_static.py::test_numberfield_relative_discriminant_equals_discriminant_over_q]
- [ ] `different` - different() ideal norm equals absolute discriminant in quadratic fields. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_different_norm_matches_discriminant_absolute_value]
- [ ] `absolute_different` - absolute_different() equals different() in an absolute field. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_absolute_different_equals_different]
- [ ] `relative_different` - relative_different() over base Q equals different(). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_relative_different_equals_different_over_q]
- [ ] `conductor` - conductor() for Q(sqrt(5)) equals 5. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_conductor_for_fundamental_discriminant_field]
- [ ] `order_of_conductor` - order_of_conductor(f) builds order with given conductor. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_order_of_conductor_has_requested_conductor]
- [ ] `quadratic_defect` - quadratic_defect(a,p) measures valuation defect of represented squares. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_quadratic_defect_of_one_is_infinite]
- [ ] `hilbert_symbol` - hilbert_symbol(a,b,P) is local norm-residue symbol in {+1,-1}. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_hilbert_symbol_is_pm_one_for_nonzero_inputs]
- [ ] `hilbert_symbol_negative_at_S` - hilbert_symbol_negative_at_S(S,b) returns a with negative Hilbert symbol on S. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_hilbert_symbol_negative_at_s_realizes_requested_negative_set]

### Number field ideal-class bounds
Computes class-group search bounds: Minkowski bound $B_M$ and (under GRH) Bach bound $B_B$ such that every ideal class has a representative of norm $\le B$.

- [ ] `bach_bound` - bach_bound() returns the GRH Bach bound for class-group ideal representatives (documented value $12\log(5)^2$ for $\mathbf Q(\sqrt{5})$). [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_bach_bound_is_positive]
- [ ] `minkowski_bound` - minkowski_bound() gives class-group search bound. [source: sage_doc/test_numberfield_bridge_static.py::test_numberfield_minkowski_bound_positive]

# GAP Lattice Methods Reference
## Lattice functionality in GAP: core integer-lattice methods + package ecosystem

---

## Tag Legend

| Tag | Meaning |
|-----|---------|
| `[CORE]` | Part of core GAP functionality |
| `[PKG]` | Provided by a GAP package |
| `[ZZMOD]` | Works at the level of $\mathbb{Z}$-modules / integer matrices |
| `[EUCLID]` | Euclidean-lattice algorithmic setting |
| `[PD]` | Effectively positive-definite assumptions/setting |
| `[INDEF]` | Intended for indefinite forms/signatures |
| `[HYP]` | Hyperbolic periodic-cell workflow |
| `[POLY]` | Polyhedral / cone / affine-monoid setting |
| `[TORIC]` | Toric/lattice-point algebraic-geometry setting |
| `[FFORM]` | Finite-field forms (no real-signature definiteness notion) |
| `[GRP]` | Matrix-group action / preserved-form setting |
| `[DECOMP]` | Orthogonal decomposition or Witt-index workflow |

---

## 1. Core GAP

### 1.1 Normal forms and $\mathbb{Z}$-module structure

These are lattice operations in the $\mathbb{Z}$-module sense (integer row/column modules), not quadratic-form classification methods.

| Function | Description | Tags |
|----------|-------------|------|
| `NullspaceIntMat(mat)` | Basis of integral nullspace of an integer matrix | `[CORE, ZZMOD]` |
| `SolutionIntMat(mat, vec)` | Integral solution `x` of `x * mat = vec` (or `fail`) | `[CORE, ZZMOD]` |
| `SolutionNullspaceIntMat(mat, vec)` | Combined integral solution + nullspace computation | `[CORE, ZZMOD]` |
| `BaseIntMat(mat)` | Basis of integral row module spanned by rows of `mat` | `[CORE, ZZMOD]` |
| `BaseIntersectionIntMats(m, n)` | Basis of intersection of integral row modules of `m` and `n` | `[CORE, ZZMOD]` |
| `HermiteNormalFormIntegerMat(M)` | Hermite normal form of an integer matrix | `[CORE, ZZMOD]` |
| `HermiteNormalFormIntegerMatTransform(M)` | Hermite normal form plus transformation data | `[CORE, ZZMOD]` |
| `SmithNormalFormIntegerMat(M)` | Smith normal form / invariant factor decomposition | `[CORE, ZZMOD]` |
| `SmithNormalFormIntegerMatTransforms(M)` | Smith normal form plus row/column transformation data | `[CORE, ZZMOD]` |
| `TriangulizedIntegerMat(mat)` | Upper-triangular integer-matrix normal-form helper | `[CORE, ZZMOD]` |
| `TriangulizedIntegerMatTransform(mat)` | Triangularization with transformation data | `[CORE, ZZMOD]` |
| `TriangulizeIntegerMat(mat)` | In-place triangularization helper | `[CORE, ZZMOD]` |
| `DiagonalizeIntMat(mat)` | Integer diagonalization helper in normal-form workflows | `[CORE, ZZMOD]` |
| `NormalFormIntMat(...)` | Workhorse routine behind HNF/SNF computations | `[CORE, ZZMOD]` |
| `AbelianInvariantsOfList(list)` | Invariant-factor style abelian invariants helper | `[CORE, ZZMOD]` |
| `ComplementIntMat(full, sub)` | Complementary sublattice/direct-summand data for `sub` inside module generated by `full` | `[CORE, ZZMOD]` |
| `DeterminantIntMat(mat)` | Determinant of an integer matrix | `[CORE, ZZMOD]` |
| `Decomposition(...)` | Decomposition helper for integer/cyclotomic matrix contexts | `[CORE, ZZMOD]` |
| `IntegralizedMat(A[, inforec])` | Compatible integral encoding of cyclotomic matrix columns | `[CORE, ZZMOD]` |
| `DecompositionInt(A, B, depth)` | Integer-specialized decomposition routine | `[CORE, ZZMOD]` |

Definiteness note:
- Not applicable here; these methods do not require a quadratic form.

### 1.2 LLL reduction

| Function | Description | Tags |
|----------|-------------|------|
| `LLLReducedBasis(...)` | LLL-reduced basis computation | `[CORE, EUCLID]` |
| `LLLReducedGramMat(G[, y])` | LLL-style reduction on Gram matrix, returning reduction record (remainder/relations/transformation, etc.) | `[CORE, EUCLID]` |

Definiteness note:
- LLL is an algorithmic Euclidean reduction procedure.
- When used through a Gram matrix input, interpretation depends on the provided matrix/model; this is not a full general-purpose indefinite-lattice classification API.

### 1.3 Short vectors and embedding routines

| Function | Description | Tags |
|----------|-------------|------|
| `ShortestVectors(G, m[, "positive"])` | Enumerates `x` with `x * G * x^tr <= m` for regular symmetric `G` | `[CORE, EUCLID, PD]` |
| `OrthogonalEmbeddings(gram[, "positive"][, maxdim])` | Solves `X^tr * X = gram` and returns encoded solution data | `[CORE, EUCLID, PD]` |

Definiteness note:
- `ShortestVectors` is mathematically finite in the standard setting only for positive-definite quadratic constraints (up to sign convention).
- `OrthogonalEmbeddings` is naturally compatible with positive-semidefinite/definite Gram constraints in the real Euclidean model.

---

## 2. Package Ecosystem

### 2.1 Crystallographic lattice stack

| Package | Role | Tags |
|---------|------|------|
| `Cryst` | Affine crystallographic groups, space-group and Wyckoff workflows | `[PKG, EUCLID, PD, GRP]` |
| `CARATInterface` | CARAT-backed class and normalizer workflows for integral matrix groups | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `CrystCat` | Catalog/index support for crystallographic classes and data | `[PKG, EUCLID, PD, ZZMOD, GRP]` |

Representative `Cryst` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `AffineCrystGroupOnRight(S)` | Convert `S` to an affine crystallographic group with right-action convention | `[PKG, EUCLID, PD, GRP]` |
| `AsAffineCrystGroupOnRight(S)` | Coerce to right-action affine crystallographic representation when possible | `[PKG, EUCLID, PD, GRP]` |
| `IsAffineCrystGroupOnRight(S)` | Predicate for right-action affine crystallographic objects | `[PKG, EUCLID, PD, GRP]` |
| `AffineCrystGroupOnLeft(S)` | Convert `S` to an affine crystallographic group with left-action convention | `[PKG, EUCLID, PD, GRP]` |
| `PointGroup(S)` | Point-group object of crystallographic object `S` | `[PKG, EUCLID, PD, GRP]` |
| `TranslationsCrystGroup(S)` | Translation subgroup/lattice part of crystallographic object `S` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `SpaceGroupsByPointGroupOnRight(P[, normedQclass[, orbitsQclass]])` | Enumerate/classify space groups with point-group data `P` | `[PKG, EUCLID, PD, GRP]` |
| `WyckoffPositions(S)` | Compute Wyckoff-position classes for space group `S` | `[PKG, EUCLID, PD, GRP]` |
| `WyckoffOrbit(G, p)` | Return Wyckoff orbit of point `p` under group `G` | `[PKG, EUCLID, PD, GRP]` |
| `WyckoffLattice(G, p)` | Return lattice/stabilizer data attached to Wyckoff computation at `(G, p)` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `WyckoffNormalClosure(G, p)` | Compute normal-closure object in the Wyckoff workflow for `(G, p)` | `[PKG, EUCLID, PD, GRP]` |

Representative `CARAT/Bravais` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `BravaisGroup(R)` | Compute Bravais group for matrix-group object `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `PointGroupsBravaisClass(R)` | Point-group data for the Bravais class associated to `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `BravaisSubgroups(R)` | Enumerate Bravais subgroups of class/group input `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `BravaisSupergroups(R)` | Enumerate Bravais supergroups of class/group input `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `NormalizerInGLnZ(R)` | Compute normalizer of the Bravais/class object `R` in `GL(n,Z)` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `CentralizerInGLnZ(R)` | Compute centralizer of `R` in `GL(n,Z)` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `IsBravaisEquivalent(R, S)` | Decide Bravais equivalence of class/group objects `R`, `S` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `CaratZClass(R)` / `CaratZClassNumber(R)` | CARAT Z-class object and class index for `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `CaratQClass(R)` / `CaratQClassNumber(R)` | CARAT Q-class object and class index for `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `RationalClassesMaximalSubgroups(R)` | Rational-class maximal-subgroup representatives from input `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `ZClassRepsQClass(R)` | Z-class representatives inside the Q-class of `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `MaximalSubgroupsRepresentatives(R)` | Maximal subgroup representatives in the CARAT class workflow | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `AffineNormalizer(R)` | Affine normalizer associated with the class/group object `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `IsCaratZClass(R)` / `IsCaratQClass(R)` | Predicates for CARAT class-object types | `[PKG, EUCLID, PD, ZZMOD, GRP]` |

Definiteness note:
- Intrinsically Euclidean/crystallographic; not a general indefinite quadratic-lattice framework.
- For `SpaceGroupsByPointGroupOnRight(P[, normedQclass[, orbitsQclass]])`, `normedQclass` is `false`
  or a normalizer-element list in `GL(d,Z)`, and `orbitsQclass` is boolean.
- Selector arguments `f`, `s`, and `k` are not treated as active canonical CARAT parameters in this surface.
- Legacy alias names `CrystCatZClass(...)`, `CrystCatQClass(...)`, and `CrystCatQClasses(...)` are triaged
  out of the active canonical method surface.
- Canonical signature anchors are maintained in:
  `docs/crystallographic_stack/lattice/crystallographic_stack_lattice_reference.md` and
  `docs/crystallographic_stack/upstream/crystallographic_stack_online_provenance_2026-02-17.md`.

### 2.2 Archived out-of-scope polyhedral/toric surfaces

- The umbrella sections for `4ti2Interface`, `NormalizInterface`, `toric`, `NConvex`, and polyhedral `CddInterface`
  were moved out of active scope and archived at:
  `docs/archive/scope_violations/gap/lattice/gap_lattice_methods_reference_polyhedral_sections_2026-02-18.md`.
- Package-level archived references remain under `docs/archive/scope_violations/`.

### 2.3 Float package fplll hooks

| Function | Description | Tags |
|----------|-------------|------|
| `FPLLLReducedBasis` | fplll-backed basis reduction | `[PKG, EUCLID]` |
| `FPLLLShortestVector` | fplll-backed shortest-vector routine | `[PKG, EUCLID]` |

### 2.4 Forms package

| Package | Role | Tags |
|---------|------|------|
| `Forms` | Bilinear/sesquilinear/quadratic forms and isometry groups over finite fields | `[PKG, FFORM]` |

Representative `Forms` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `AsSesquilinearForm(obj[, field][, antiautomorphism])` / `AsQuadraticForm(obj[, field])` | Coercion constructors for sesquilinear/quadratic form objects | `[PKG, FFORM]` |
| `SesquilinearFormByMatrix(matrix[, field][, antiautomorphism])` / `QuadraticFormByMatrix(matrix[, field])` | Matrix-backed form constructors | `[PKG, FFORM]` |
| `MatrixOfSesquilinearForm(form)` / `MatrixOfQuadraticForm(form)` / `RankOfForm(form)` / `BaseField(form)` | Core structural attributes/invariants | `[PKG, FFORM]` |
| `IsometricForms(form1, form2)` / `SimilarityForms(form1, form2)` | Form equivalence checks | `[PKG, FFORM]` |
| `IsometryGroup(form)` / `SimilarityGroup(form)` | Isometry/similarity group constructors | `[PKG, FFORM]` |
| `InvariantBilinearForm(G[, involution][, isom])` / `InvariantQuadraticForm(G[, involution][, isom])` | Matrix-group invariant form extraction | `[PKG, FFORM]` |
| `PreservedSesquilinearForms(G)` / `PreservedQuadraticForms(G)` | Preserved-form families for matrix groups | `[PKG, FFORM, GRP]` |
| `OrthogonalSubgroups(G, n[, s])` / `OrthogonalSubgroupsAsList(G, n[, s])` | Orthogonal subgroup decomposition helpers | `[PKG, FFORM, DECOMP]` |
| `OrthogonalComponents(G, n)` / `OrthogonalComponentsOfSubgroup(U, n)` / `WittIndex(form)` | Orthogonal component and Witt-index workflows | `[PKG, FFORM, DECOMP]` |

Detailed method inventory is maintained in `docs/forms_methods_checklist.md` and `docs/forms/lattice/forms_lattice_reference.md`.

Definiteness note:
- Real-signature PD/INDEF language is not applicable in the finite-field setting.

### 2.5 HyperCells package

| Package | Role | Tags |
|---------|------|------|
| `HyperCells` | Hyperbolic/Euclidean periodic cell-complex methods via triangle-group and supercell workflows | `[PKG, HYP, EUCLID]` |

Representative methods:

| Function | Description | Tags |
|----------|-------------|------|
| `TGCell(...)` / `TGSuperCell(...)` / `TGSuperCellModelGraph(...)` | Core constructors for primitive cells, supercells, and supercell model graphs | `[PKG, HYP, EUCLID]` |
| `HyperCell(...)` | Constructor for regular compact primitive cells in dimensions 2-4 from modified SNF data | `[PKG, HYP, EUCLID]` |
| `TGCellGraph(...)` / `TGCellModelGraph(...)` | Cell-graph and model-graph construction workflows | `[PKG, HYP, EUCLID]` |
| `IsomorphicCell(...)` / `IsomorphicCellGraph(...)` / `IsomorphicSuperCellModelGraph(...)` | Isomorphism/equivalence workflows for cells and model graphs | `[PKG, HYP, EUCLID]` |
| `TGSuperCellModelGraphQClass*`, `TGSuperCellQClass*`, `TGSuperCellModelGraphZClass*`, `TGSuperCellZClass*` | Supercell Q-class and Z-class classification/enumeration methods | `[PKG, HYP, EUCLID]` |
| `TGCellMSNFsByType*`, `TGCellModelGraphsByType*`, `TGCellGraphsByType*` | Database extraction methods by type/species/genus/length | `[PKG, HYP, EUCLID]` |
| `TGCellPointGroup*` family | Point-group representation, class, family, and genus workflows | `[PKG, HYP, EUCLID]` |

Detailed method-level inventory is maintained in `docs/hypercells_methods_checklist.md` and `docs/hypercells/lattice/hypercells_lattice_reference.md`.

Definiteness note:
- HyperCells focuses on periodic cell-complex geometry over translation/point-group actions (Euclidean and hyperbolic regimes), not arithmetic PD-vs-INDEF genus classification contracts.

### 2.6 Subgroup lattices (terminology warning)

GAP also uses “lattice” to mean subgroup lattice (poset), which is unrelated to geometric/integer lattices and basis-reduction or Gram-matrix workflows.

---

## 3. Definiteness Regime Summary

| Area | PD / INDEF relevance |
|------|----------------------|
| Core HNF/SNF/complement methods | Not applicable (pure $\mathbb{Z}$-module algebra) |
| Core LLL methods | Euclidean algorithmic setting; not a full indefinite form-classification framework |
| Core short-vector / embedding methods | Effectively positive-definite/finite-enumeration regime |
| Cryst/CARAT/CrystCat | Euclidean crystallographic (PD setting) |
| 4ti2/Normaliz/toric/NConvex/Cdd | Archived out-of-scope polyhedral/toric surfaces |
| Forms | Finite-field forms (no real-signature definiteness notion) |
| HyperCells | Hyperbolic/Euclidean periodic cell-complex workflows; not an arithmetic genus/discriminant-form API |

---

## 4. Consolidated Method Index

### 4.1 Core GAP methods

- `AbelianInvariantsOfList`
- `BaseIntMat`
- `BaseIntersectionIntMats`
- `ComplementIntMat`
- `Decomposition`
- `DecompositionInt`
- `DeterminantIntMat`
- `DiagonalizeIntMat`
- `HermiteNormalFormIntegerMat`
- `HermiteNormalFormIntegerMatTransform`
- `IntegralizedMat`
- `LLLReducedBasis`
- `LLLReducedGramMat`
- `NormalFormIntMat`
- `NullspaceIntMat`
- `OrthogonalEmbeddings`
- `SolutionIntMat`
- `SolutionNullspaceIntMat`
- `ShortestVectors`
- `SmithNormalFormIntegerMat`
- `SmithNormalFormIntegerMatTransforms`
- `TriangulizeIntegerMat`
- `TriangulizedIntegerMat`
- `TriangulizedIntegerMatTransform`

### 4.2 Float (fplll hooks)

- `FPLLLReducedBasis`
- `FPLLLShortestVector`

### 4.3 Package names (lattice-related)

- `CARATInterface`
- `Cryst`
- `CrystCat`
- `Forms`
- `HyperCells`
- Archived out-of-scope package families: `4ti2Interface`, `CddInterface`, `NConvex`, `NormalizInterface`, `toric`
  (see `docs/archive/scope_violations/gap/lattice/gap_lattice_methods_reference_polyhedral_sections_2026-02-18.md`).

### 4.4 Cryst/CARAT methods (canonical)

- `AffineCrystGroupOnLeft`
- `AffineCrystGroupOnRight`
- `AsAffineCrystGroupOnRight`
- `AffineNormalizer`
- `BravaisGroup`
- `BravaisSubgroups`
- `BravaisSupergroups`
- `CaratQClass`
- `CaratQClassNumber`
- `CaratZClass`
- `CaratZClassNumber`
- `CentralizerInGLnZ`
- `IsAffineCrystGroupOnRight`
- `IsBravaisEquivalent`
- `IsCaratQClass`
- `IsCaratZClass`
- `MaximalSubgroupsRepresentatives`
- `PointGroup`
- `PointGroupsBravaisClass`
- `RationalClassesMaximalSubgroups`
- `NormalizerInGLnZ`
- `SpaceGroupsByPointGroupOnRight`
- `TranslationsCrystGroup`
- `WyckoffLattice`
- `WyckoffNormalClosure`
- `WyckoffOrbit`
- `WyckoffPositions`
- `ZClassRepsQClass`

### 4.5 Forms methods

- `AsSesquilinearForm`
- `AsQuadraticForm`
- `SesquilinearFormByMatrix`
- `QuadraticFormByMatrix`
- `IsSesquilinearForm`
- `IsQuadraticForm`
- `UnderlyingVectorSpace`
- `MatrixOfSesquilinearForm`
- `MatrixOfQuadraticForm`
- `RankOfForm`
- `BaseField`
- `IsReflexiveForm`
- `IsSymmetricForm`
- `IsAlternatingForm`
- `IsDegenerateForm`
- `RadicalOfForm`
- `IsometricForms`
- `SimilarityForms`
- `IsometryGroup`
- `SimilarityGroup`
- `InvariantBilinearForm`
- `InvariantQuadraticForm`
- `PreservedSesquilinearForms`
- `PreservedQuadraticForms`
- `OrthogonalSubgroups`
- `OrthogonalSubgroupsAsList`
- `OrthogonalComponents`
- `OrthogonalComponentsOfSubgroup`
- `WittIndex`

### 4.6 HyperCells methods (top-level entry points)

- `HyperCell`
- `TGCell`
- `TGCellGraph`
- `TGCellModelGraph`
- `TGSuperCell`
- `TGSuperCellModelGraph`
- `IsomorphicCell`
- `IsomorphicCellGraph`
- `IsomorphicSuperCellModelGraph`
- `TGSuperCells`
- `TGSuperCellModelGraphQClasses`
- `TGSuperCellQClasses`
- `TGSuperCellModelGraphZClasses`
- `TGSuperCellZClasses`
- `TGCellMSNFsByType`
- `TGCellMSNFsByTypeAndSpeciesAndGenus`
- `TGCellModelGraphsByType`
- `TGCellGraphsByType`
- `TGCellPointGroupReps`
- `TGCellPointGroupQClasses`
- `TGCellPointGroupZClasses`
- `TGCellPointGroupFamilies`
- `TGCellPointGroupGenera`

# GAP Lattice Methods Reference
## Lattice functionality in GAP: core integer-lattice methods + package ecosystem

---

## Tag Legend

| Tag | Meaning |
|-----|---------|
| `[CORE]` | Part of core GAP functionality |
| `[PKG]` | Provided by a GAP package |
| `[ZZMOD]` | Works at the level of $\mathbb{Z}$-modules / integer matrices |
| `[EUCLID]` | Euclidean-lattice algorithmic setting |
| `[PD]` | Effectively positive-definite assumptions/setting |
| `[INDEF]` | Intended for indefinite forms/signatures |
| `[HYP]` | Hyperbolic periodic-cell workflow |
| `[POLY]` | Polyhedral / cone / affine-monoid setting |
| `[TORIC]` | Toric/lattice-point algebraic-geometry setting |
| `[FFORM]` | Finite-field forms (no real-signature definiteness notion) |
| `[GRP]` | Matrix-group action / preserved-form setting |
| `[DECOMP]` | Orthogonal decomposition or Witt-index workflow |

---

## 1. Core GAP

### 1.1 Normal forms and $\mathbb{Z}$-module structure

These are lattice operations in the $\mathbb{Z}$-module sense (integer row/column modules), not quadratic-form classification methods.

| Function | Description | Tags |
|----------|-------------|------|
| `NullspaceIntMat(mat)` | Basis of integral nullspace of an integer matrix | `[CORE, ZZMOD]` |
| `SolutionIntMat(mat, vec)` | Integral solution `x` of `x * mat = vec` (or `fail`) | `[CORE, ZZMOD]` |
| `SolutionNullspaceIntMat(mat, vec)` | Combined integral solution + nullspace computation | `[CORE, ZZMOD]` |
| `BaseIntMat(mat)` | Basis of integral row module spanned by rows of `mat` | `[CORE, ZZMOD]` |
| `BaseIntersectionIntMats(m, n)` | Basis of intersection of integral row modules of `m` and `n` | `[CORE, ZZMOD]` |
| `HermiteNormalFormIntegerMat(M)` | Hermite normal form of an integer matrix | `[CORE, ZZMOD]` |
| `HermiteNormalFormIntegerMatTransform(M)` | Hermite normal form plus transformation data | `[CORE, ZZMOD]` |
| `SmithNormalFormIntegerMat(M)` | Smith normal form / invariant factor decomposition | `[CORE, ZZMOD]` |
| `SmithNormalFormIntegerMatTransforms(M)` | Smith normal form plus row/column transformation data | `[CORE, ZZMOD]` |
| `TriangulizedIntegerMat(mat)` | Upper-triangular integer-matrix normal-form helper | `[CORE, ZZMOD]` |
| `TriangulizedIntegerMatTransform(mat)` | Triangularization with transformation data | `[CORE, ZZMOD]` |
| `TriangulizeIntegerMat(mat)` | In-place triangularization helper | `[CORE, ZZMOD]` |
| `DiagonalizeIntMat(mat)` | Integer diagonalization helper in normal-form workflows | `[CORE, ZZMOD]` |
| `NormalFormIntMat(...)` | Workhorse routine behind HNF/SNF computations | `[CORE, ZZMOD]` |
| `AbelianInvariantsOfList(list)` | Invariant-factor style abelian invariants helper | `[CORE, ZZMOD]` |
| `ComplementIntMat(full, sub)` | Complementary sublattice/direct-summand data for `sub` inside module generated by `full` | `[CORE, ZZMOD]` |
| `DeterminantIntMat(mat)` | Determinant of an integer matrix | `[CORE, ZZMOD]` |
| `Decomposition(...)` | Decomposition helper for integer/cyclotomic matrix contexts | `[CORE, ZZMOD]` |
| `IntegralizedMat(A[, inforec])` | Compatible integral encoding of cyclotomic matrix columns | `[CORE, ZZMOD]` |
| `DecompositionInt(A, B, depth)` | Integer-specialized decomposition routine | `[CORE, ZZMOD]` |

Definiteness note:
- Not applicable here; these methods do not require a quadratic form.

### 1.2 LLL reduction

| Function | Description | Tags |
|----------|-------------|------|
| `LLLReducedBasis(...)` | LLL-reduced basis computation | `[CORE, EUCLID]` |
| `LLLReducedGramMat(G[, y])` | LLL-style reduction on Gram matrix, returning reduction record (remainder/relations/transformation, etc.) | `[CORE, EUCLID]` |

Definiteness note:
- LLL is an algorithmic Euclidean reduction procedure.
- When used through a Gram matrix input, interpretation depends on the provided matrix/model; this is not a full general-purpose indefinite-lattice classification API.

### 1.3 Short vectors and embedding routines

| Function | Description | Tags |
|----------|-------------|------|
| `ShortestVectors(G, m[, "positive"])` | Enumerates `x` with `x * G * x^tr <= m` for regular symmetric `G` | `[CORE, EUCLID, PD]` |
| `OrthogonalEmbeddings(gram[, "positive"][, maxdim])` | Solves `X^tr * X = gram` and returns encoded solution data | `[CORE, EUCLID, PD]` |

Definiteness note:
- `ShortestVectors` is mathematically finite in the standard setting only for positive-definite quadratic constraints (up to sign convention).
- `OrthogonalEmbeddings` is naturally compatible with positive-semidefinite/definite Gram constraints in the real Euclidean model.

---

## 2. Package Ecosystem

### 2.1 Crystallographic lattice stack

| Package | Role | Tags |
|---------|------|------|
| `Cryst` | Affine crystallographic groups, space-group and Wyckoff workflows | `[PKG, EUCLID, PD, GRP]` |
| `CARATInterface` | CARAT-backed class and normalizer workflows for integral matrix groups | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `CrystCat` | Catalog/index support for crystallographic classes and data | `[PKG, EUCLID, PD, ZZMOD, GRP]` |

Representative `Cryst` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `AffineCrystGroupOnRight(S)` | Convert `S` to an affine crystallographic group with right-action convention | `[PKG, EUCLID, PD, GRP]` |
| `AsAffineCrystGroupOnRight(S)` | Coerce to right-action affine crystallographic representation when possible | `[PKG, EUCLID, PD, GRP]` |
| `IsAffineCrystGroupOnRight(S)` | Predicate for right-action affine crystallographic objects | `[PKG, EUCLID, PD, GRP]` |
| `AffineCrystGroupOnLeft(S)` | Convert `S` to an affine crystallographic group with left-action convention | `[PKG, EUCLID, PD, GRP]` |
| `PointGroup(S)` | Point-group object of crystallographic object `S` | `[PKG, EUCLID, PD, GRP]` |
| `TranslationsCrystGroup(S)` | Translation subgroup/lattice part of crystallographic object `S` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `SpaceGroupsByPointGroupOnRight(P[, normedQclass[, orbitsQclass]])` | Enumerate/classify space groups with point-group data `P` | `[PKG, EUCLID, PD, GRP]` |
| `WyckoffPositions(S)` | Compute Wyckoff-position classes for space group `S` | `[PKG, EUCLID, PD, GRP]` |
| `WyckoffOrbit(G, p)` | Return Wyckoff orbit of point `p` under group `G` | `[PKG, EUCLID, PD, GRP]` |
| `WyckoffLattice(G, p)` | Return lattice/stabilizer data attached to Wyckoff computation at `(G, p)` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `WyckoffNormalClosure(G, p)` | Compute normal-closure object in the Wyckoff workflow for `(G, p)` | `[PKG, EUCLID, PD, GRP]` |

Representative `CARAT/Bravais` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `BravaisGroup(R)` | Compute Bravais group for matrix-group object `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `PointGroupsBravaisClass(R)` | Point-group data for the Bravais class associated to `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `BravaisSubgroups(R)` | Enumerate Bravais subgroups of class/group input `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `BravaisSupergroups(R)` | Enumerate Bravais supergroups of class/group input `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `NormalizerInGLnZ(R)` | Compute normalizer of the Bravais/class object `R` in `GL(n,Z)` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `CentralizerInGLnZ(R)` | Compute centralizer of `R` in `GL(n,Z)` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `IsBravaisEquivalent(R, S)` | Decide Bravais equivalence of class/group objects `R`, `S` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `CaratZClass(R)` / `CaratZClassNumber(R)` | CARAT Z-class object and class index for `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `CaratQClass(R)` / `CaratQClassNumber(R)` | CARAT Q-class object and class index for `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `RationalClassesMaximalSubgroups(R)` | Rational-class maximal-subgroup representatives from input `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `ZClassRepsQClass(R)` | Z-class representatives inside the Q-class of `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `MaximalSubgroupsRepresentatives(R)` | Maximal subgroup representatives in the CARAT class workflow | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `AffineNormalizer(R)` | Affine normalizer associated with the class/group object `R` | `[PKG, EUCLID, PD, ZZMOD, GRP]` |
| `IsCaratZClass(R)` / `IsCaratQClass(R)` | Predicates for CARAT class-object types | `[PKG, EUCLID, PD, ZZMOD, GRP]` |

Definiteness note:
- Intrinsically Euclidean/crystallographic; not a general indefinite quadratic-lattice framework.
- For `SpaceGroupsByPointGroupOnRight(P[, normedQclass[, orbitsQclass]])`, `normedQclass` is `false`
  or a normalizer-element list in `GL(d,Z)`, and `orbitsQclass` is boolean.
- Selector arguments `f`, `s`, and `k` are not treated as active canonical CARAT parameters in this surface.
- Legacy alias names `CrystCatZClass(...)`, `CrystCatQClass(...)`, and `CrystCatQClasses(...)` are triaged
  out of the active canonical method surface.
- Canonical signature anchors are maintained in:
  `docs/crystallographic_stack/lattice/crystallographic_stack_lattice_reference.md` and
  `docs/crystallographic_stack/upstream/crystallographic_stack_online_provenance_2026-02-17.md`.

### 2.2 NormalizInterface

Interface to Normaliz for affine monoids, vector configurations, lattice polytopes, and rational cones.

| Package | Role | Tags |
|---------|------|------|
| `NormalizInterface` | Polyhedral/lattice-point computations in cones/polytopes/monoids | `[PKG, POLY]` |

Representative `NormalizInterface` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `NmzCone(list)` | Construct a Normaliz cone object from typed input matrices | `[PKG, POLY]` |
| `NmzCompute(cone[, props])` | Trigger computation of requested cone properties/options | `[PKG, POLY]` |
| `NmzConeProperty(cone, property)` | Query/compute a specific property by name | `[PKG, POLY]` |
| `NmzKnownConeProperties(cone)` | List already computed properties on a cone object | `[PKG, POLY]` |
| `NmzHasConeProperty(cone, property)` | Check if a property is already available | `[PKG, POLY]` |
| `NmzGenerators(cone)` / `NmzExtremeRays(cone)` / `NmzSupportHyperplanes(cone)` | Core geometric generators/rays/facet-description accessors | `[PKG, POLY]` |
| `NmzHilbertBasis(cone)` / `NmzHilbertSeries(cone)` / `NmzHilbertQuasiPolynomial(cone)` | Hilbert-basis and degreewise counting invariants | `[PKG, POLY]` |
| `NmzTriangulation(cone)` / `NmzTriangulationSize(cone)` / `NmzTriangulationDetSum(cone)` | Triangulation-level combinatorial output | `[PKG, POLY]` |
| `NmzLatticePoints(cone)` / `NmzVerticesOfPolyhedron(cone)` | Lattice-point and vertex extraction in polyhedral regimes | `[PKG, POLY]` |

Definiteness note:
- Not a quadratic-form lattice package; no PD/INDEF signature regime is central.

### 2.3 4ti2Interface

Integer relation, toric ideal, Hilbert basis, and semigroup workflows.

| Function | Description | Tags |
|----------|-------------|------|
| `4ti2Interface_groebner_matrix` | Gröbner/toric ideal matrix-side routine | `[PKG, TORIC]` |
| `4ti2Interface_groebner_basis` | Gröbner basis routine for toric/integer relation systems | `[PKG, TORIC]` |
| `4ti2Interface_hilbert_inequalities` | Hilbert basis from inequality descriptions | `[PKG, POLY, TORIC]` |
| `4ti2Interface_hilbert_equalities_in_positive_orthant` | Hilbert basis under equalities with positive orthant constraints | `[PKG, POLY, TORIC]` |
| `4ti2Interface_hilbert_equalities_and_inequalities` | Hilbert basis from mixed equality/inequality systems | `[PKG, POLY, TORIC]` |
| `4ti2Interface_zsolve_equalities_and_inequalities` | Integer solution enumeration/structure for mixed systems | `[PKG, ZZMOD, TORIC]` |
| `4ti2Interface_graver_equalities` | Graver basis from equality constraints | `[PKG, ZZMOD, TORIC]` |

Definiteness note:
- These are integer-algebraic/polyhedral methods, not real-signature quadratic-form methods.

### 2.4 toric

| Package | Role | Tags |
|---------|------|------|
| `toric` | Toric varieties over fixed lattices/fans/cones; divisor-polytopes and lattice-point operations | `[PKG, TORIC, POLY]` |

Representative `toric` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `InsideCone(...)` | Membership test for a cone | `[PKG, TORIC, POLY]` |
| `InDualCone(...)` | Membership test in dual cone | `[PKG, TORIC, POLY]` |
| `PolytopeLatticePoints(...)` | Lattice points of a polytope | `[PKG, TORIC, POLY]` |
| `Faces(...)` / `ConesOfFan(...)` / `NumberOfConesOfFan(...)` | Face/fan combinatorics | `[PKG, TORIC, POLY]` |
| `ToricStar(...)` | Star construction in fan geometry | `[PKG, TORIC, POLY]` |
| `DualSemigroupGenerators(...)` | Semigroup generators from dual cone data | `[PKG, TORIC, POLY]` |
| `EmbeddingAffineToricVariety(...)` | Construct affine toric variety embedding ideal data | `[PKG, TORIC]` |
| `DivisorPolytope(...)` / `DivisorPolytopeLatticePoints(...)` / `RiemannRochBasis(...)` | Divisor polytope and Riemann-Roch space computations | `[PKG, TORIC, POLY]` |
| `EulerCharacteristic(...)` / `BettiNumberToric(...)` / `CardinalityOfToricVariety(...)` | Topological and finite-field invariants | `[PKG, TORIC]` |

Definiteness note:
- Lattice is combinatorial (`\mathbb{Z}^n` data), not a PD/INDEF bilinear-form lattice object.

### 2.5 Convex/polyhedral interfaces

| Package | Role | Tags |
|---------|------|------|
| `NConvex` | Polyhedra/polyhedral complex support and backend conversions | `[PKG, POLY]` |
| `CddInterface` | Interface to cdd/cddlib for H/V polyhedral conversion workflows | `[PKG, POLY]` |

Representative `CddInterface` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `Cdd_PolyhedronByInequalities(...)` / `Cdd_PolyhedronByGenerators(...)` | Build polyhedra from H-representation or V-representation input | `[PKG, POLY]` |
| `Cdd_Canonicalize(P)` | Remove redundant constraints/generators in representation | `[PKG, POLY]` |
| `Cdd_V_Rep(P)` / `Cdd_H_Rep(P)` | Convert between reduced V- and H-representations | `[PKG, POLY]` |
| `Cdd_AmbientSpaceDimension(P)` / `Cdd_Dimension(P)` | Ambient and intrinsic dimension attributes | `[PKG, POLY]` |
| `Cdd_GeneratingVertices(P)` / `Cdd_GeneratingRays(P)` | Extract vertex/ray generators | `[PKG, POLY]` |
| `Cdd_Equalities(P)` / `Cdd_Inequalities(P)` | Retrieve linear equalities/inequalities | `[PKG, POLY]` |
| `Cdd_Faces(P)` / `Cdd_FacesWithFixedDimension(P, d)` / `Cdd_Facets(P)` | Face lattice and facet-level queries | `[PKG, POLY]` |
| `Cdd_InteriorPoint(P)` / `Cdd_FacesWithInteriorPoints(P)` / `Cdd_FacesWithFixedDimensionAndInteriorPoints(P, d)` | Interior-point-aware face extraction methods | `[PKG, POLY]` |
| `Cdd_ExtendLinearity(P, V)` / `Cdd_Lines(P)` / `Cdd_Vertices(P)` | Lineality/vertex extraction and linearity-extension helpers | `[PKG, POLY]` |
| `Cdd_IsEmpty(P)` / `Cdd_IsCone(P)` / `Cdd_IsLinSpace(P)` / `Cdd_IsPointed(P)` | Basic geometric predicates | `[PKG, POLY]` |
| `Cdd_IsContained(P1, P2)` / `Cdd_Intersection(P1, P2)` | Polyhedral containment/intersection operations | `[PKG, POLY]` |
| `Cdd_LinearProgram(P, b)` / `Cdd_FourierProjection(P, var)` | LP and projection/elimination workflows for polyhedral models | `[PKG, POLY]` |

Representative `NConvex` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `ConeByInequalities(L)` / `ConeByEqualitiesAndInequalities(Eq, Ineq)` / `ConeByGenerators(L)` | Cone constructors from inequality/equality/generator data. | `[PKG, POLY]` |
| `Cone(L)` / `Cone(cdd_cone)` / `DualCone(C)` / `HilbertBasis(C)` | Core cone conversion and Hilbert-basis workflows. | `[PKG, POLY]` |
| `Fan(R, C)` / `FansFromTriangulation(R)` / `FanFromTriangulation(R)` | Fan construction and triangulation-derived fan workflows. | `[PKG, POLY]` |
| `PolyhedronByInequalities(L)` / `Polyhedron(P, C)` / `TailCone(P)` | Polyhedron constructors and tail-cone extraction. | `[PKG, POLY]` |
| `SolveLinearProgram(P, max_or_min, target_func)` | Linear programming on NConvex polyhedra/polytopes. | `[PKG, POLY]` |
| `PolytopeByInequalities(L)` / `Polytope(L)` / `LatticePoints(P)` / `NormalFan(P)` | Polytope construction, lattice-point extraction, and fan conversion. | `[PKG, POLY]` |
| `IntersectionOfCones(...)` / `IntersectionOfPolytopes(P1, P2)` / `FourierProjection(...)` | Intersection and projection operations across cone/polytope surfaces. | `[PKG, POLY]` |
| `SolveEqualitiesAndInequalitiesOverIntergers(...)` | Integer equalities/inequalities solver returning polytope+cone decomposition data. | `[PKG, POLY]` |

Detailed inventory note:

- Full NConvex method-level checklist/reference surfaces are in `docs/nconvex_methods_checklist.md` and `docs/nconvex/lattice/nconvex_lattice_reference.md`.
- Full CddInterface checklist/reference surfaces are archived at `docs/archive/scope_violations/cddinterface_methods_checklist.md` and `docs/archive/scope_violations/cddinterface/lattice/cddinterface_lattice_reference.md` (out of active bilinear-form lattice scope).

### 2.6 Float package fplll hooks

| Function | Description | Tags |
|----------|-------------|------|
| `FPLLLReducedBasis` | fplll-backed basis reduction | `[PKG, EUCLID]` |
| `FPLLLShortestVector` | fplll-backed shortest-vector routine | `[PKG, EUCLID]` |

### 2.7 Forms package

| Package | Role | Tags |
|---------|------|------|
| `Forms` | Bilinear/sesquilinear/quadratic forms and isometry groups over finite fields | `[PKG, FFORM]` |

Representative `Forms` methods:

| Function | Description | Tags |
|----------|-------------|------|
| `AsSesquilinearForm(obj[, field][, antiautomorphism])` / `AsQuadraticForm(obj[, field])` | Coercion constructors for sesquilinear/quadratic form objects | `[PKG, FFORM]` |
| `SesquilinearFormByMatrix(matrix[, field][, antiautomorphism])` / `QuadraticFormByMatrix(matrix[, field])` | Matrix-backed form constructors | `[PKG, FFORM]` |
| `MatrixOfSesquilinearForm(form)` / `MatrixOfQuadraticForm(form)` / `RankOfForm(form)` / `BaseField(form)` | Core structural attributes/invariants | `[PKG, FFORM]` |
| `IsometricForms(form1, form2)` / `SimilarityForms(form1, form2)` | Form equivalence checks | `[PKG, FFORM]` |
| `IsometryGroup(form)` / `SimilarityGroup(form)` | Isometry/similarity group constructors | `[PKG, FFORM]` |
| `InvariantBilinearForm(G[, involution][, isom])` / `InvariantQuadraticForm(G[, involution][, isom])` | Matrix-group invariant form extraction | `[PKG, FFORM]` |
| `PreservedSesquilinearForms(G)` / `PreservedQuadraticForms(G)` | Preserved-form families for matrix groups | `[PKG, FFORM, GRP]` |
| `OrthogonalSubgroups(G, n[, s])` / `OrthogonalSubgroupsAsList(G, n[, s])` | Orthogonal subgroup decomposition helpers | `[PKG, FFORM, DECOMP]` |
| `OrthogonalComponents(G, n)` / `OrthogonalComponentsOfSubgroup(U, n)` / `WittIndex(form)` | Orthogonal component and Witt-index workflows | `[PKG, FFORM, DECOMP]` |

Detailed method inventory is maintained in `docs/forms_methods_checklist.md` and `docs/forms/lattice/forms_lattice_reference.md`.

Definiteness note:
- Real-signature PD/INDEF language is not applicable in the finite-field setting.

### 2.8 HyperCells package

| Package | Role | Tags |
|---------|------|------|
| `HyperCells` | Hyperbolic/Euclidean periodic cell-complex methods via triangle-group and supercell workflows | `[PKG, HYP, EUCLID]` |

Representative methods:

| Function | Description | Tags |
|----------|-------------|------|
| `TGCell(...)` / `TGSuperCell(...)` / `TGSuperCellModelGraph(...)` | Core constructors for primitive cells, supercells, and supercell model graphs | `[PKG, HYP, EUCLID]` |
| `HyperCell(...)` | Constructor for regular compact primitive cells in dimensions 2-4 from modified SNF data | `[PKG, HYP, EUCLID]` |
| `TGCellGraph(...)` / `TGCellModelGraph(...)` | Cell-graph and model-graph construction workflows | `[PKG, HYP, EUCLID]` |
| `IsomorphicCell(...)` / `IsomorphicCellGraph(...)` / `IsomorphicSuperCellModelGraph(...)` | Isomorphism/equivalence workflows for cells and model graphs | `[PKG, HYP, EUCLID]` |
| `TGSuperCellModelGraphQClass*`, `TGSuperCellQClass*`, `TGSuperCellModelGraphZClass*`, `TGSuperCellZClass*` | Supercell Q-class and Z-class classification/enumeration methods | `[PKG, HYP, EUCLID]` |
| `TGCellMSNFsByType*`, `TGCellModelGraphsByType*`, `TGCellGraphsByType*` | Database extraction methods by type/species/genus/length | `[PKG, HYP, EUCLID]` |
| `TGCellPointGroup*` family | Point-group representation, class, family, and genus workflows | `[PKG, HYP, EUCLID]` |

Detailed method-level inventory is maintained in `docs/hypercells_methods_checklist.md` and `docs/hypercells/lattice/hypercells_lattice_reference.md`.

Definiteness note:
- HyperCells focuses on periodic cell-complex geometry over translation/point-group actions (Euclidean and hyperbolic regimes), not arithmetic PD-vs-INDEF genus classification contracts.

### 2.9 Subgroup lattices (terminology warning)

GAP also uses “lattice” to mean subgroup lattice (poset), which is unrelated to geometric/integer lattices and basis-reduction or Gram-matrix workflows.

---

## 3. Definiteness Regime Summary

| Area | PD / INDEF relevance |
|------|----------------------|
| Core HNF/SNF/complement methods | Not applicable (pure $\mathbb{Z}$-module algebra) |
| Core LLL methods | Euclidean algorithmic setting; not a full indefinite form-classification framework |
| Core short-vector / embedding methods | Effectively positive-definite/finite-enumeration regime |
| Cryst/CARAT/CrystCat | Euclidean crystallographic (PD setting) |
| Normaliz/4ti2/toric/NConvex/Cdd | Polyhedral/combinatorial, not signature-based |
| Forms | Finite-field forms (no real-signature definiteness notion) |
| HyperCells | Hyperbolic/Euclidean periodic cell-complex workflows; not an arithmetic genus/discriminant-form API |

---

## 4. Consolidated Method Index

### 4.1 Core GAP methods

- `AbelianInvariantsOfList`
- `BaseIntMat`
- `BaseIntersectionIntMats`
- `ComplementIntMat`
- `Decomposition`
- `DecompositionInt`
- `DeterminantIntMat`
- `DiagonalizeIntMat`
- `HermiteNormalFormIntegerMat`
- `HermiteNormalFormIntegerMatTransform`
- `IntegralizedMat`
- `LLLReducedBasis`
- `LLLReducedGramMat`
- `NormalFormIntMat`
- `NullspaceIntMat`
- `OrthogonalEmbeddings`
- `SolutionIntMat`
- `SolutionNullspaceIntMat`
- `ShortestVectors`
- `SmithNormalFormIntegerMat`
- `SmithNormalFormIntegerMatTransforms`
- `TriangulizeIntegerMat`
- `TriangulizedIntegerMat`
- `TriangulizedIntegerMatTransform`

### 4.2 4ti2Interface methods

- `4ti2Interface_groebner_basis`
- `4ti2Interface_groebner_matrix`
- `4ti2Interface_graver_equalities`
- `4ti2Interface_hilbert_equalities_and_inequalities`
- `4ti2Interface_hilbert_equalities_in_positive_orthant`
- `4ti2Interface_hilbert_inequalities`
- `4ti2Interface_zsolve_equalities_and_inequalities`

### 4.3 Float (fplll hooks)

- `FPLLLReducedBasis`
- `FPLLLShortestVector`

### 4.4 Package names (lattice-related)

- `CARATInterface`
- `CddInterface`
- `Cryst`
- `CrystCat`
- `Forms`
- `HyperCells`
- `NConvex`
- `NormalizInterface`
- `toric`

### 4.5 Cryst/CARAT methods (canonical)

- `AffineCrystGroupOnLeft`
- `AffineCrystGroupOnRight`
- `AsAffineCrystGroupOnRight`
- `AffineNormalizer`
- `BravaisGroup`
- `BravaisSubgroups`
- `BravaisSupergroups`
- `CaratQClass`
- `CaratQClassNumber`
- `CaratZClass`
- `CaratZClassNumber`
- `CentralizerInGLnZ`
- `IsAffineCrystGroupOnRight`
- `IsBravaisEquivalent`
- `IsCaratQClass`
- `IsCaratZClass`
- `MaximalSubgroupsRepresentatives`
- `PointGroup`
- `PointGroupsBravaisClass`
- `RationalClassesMaximalSubgroups`
- `NormalizerInGLnZ`
- `SpaceGroupsByPointGroupOnRight`
- `TranslationsCrystGroup`
- `WyckoffLattice`
- `WyckoffNormalClosure`
- `WyckoffOrbit`
- `WyckoffPositions`
- `ZClassRepsQClass`

### 4.6 NormalizInterface methods

- `NmzCompute`
- `NmzCone`
- `NmzConeProperty`
- `NmzExtremeRays`
- `NmzGenerators`
- `NmzHasConeProperty`
- `NmzHilbertBasis`
- `NmzHilbertQuasiPolynomial`
- `NmzHilbertSeries`
- `NmzKnownConeProperties`
- `NmzLatticePoints`
- `NmzSupportHyperplanes`
- `NmzTriangulation`
- `NmzTriangulationDetSum`
- `NmzTriangulationSize`
- `NmzVerticesOfPolyhedron`

### 4.7 toric methods

- `BettiNumberToric`
- `CardinalityOfToricVariety`
- `ConesOfFan`
- `DivisorPolytope`
- `DivisorPolytopeLatticePoints`
- `DualSemigroupGenerators`
- `EmbeddingAffineToricVariety`
- `EulerCharacteristic`
- `Faces`
- `InDualCone`
- `InsideCone`
- `NumberOfConesOfFan`
- `PolytopeLatticePoints`
- `RiemannRochBasis`
- `ToricStar`

### 4.8 NConvex methods

- `AmbientSpaceDimension`
- `BasisOfLinealitySpace`
- `Cone`
- `ConeByEqualitiesAndInequalities`
- `ConeByGenerators`
- `ConeByInequalities`
- `Contains`
- `DefiningInequalities`
- `DualCone`
- `EqualitiesOfCone`
- `EqualitiesOfPolytope`
- `ExternalCddCone`
- `ExternalCddPolyhedron`
- `ExternalCddPolytope`
- `ExternalNmzCone`
- `ExternalNmzPolyhedron`
- `FacesOfCone`
- `Fan`
- `FanFromTriangulation`
- `FansFromTriangulation`
- `FourierProjection`
- `GridGeneratedByCone`
- `HilbertBasis`
- `IntersectionOfCones`
- `IntersectionOfPolytopes`
- `IsFullDimensional`
- `IsInteriorPoint`
- `IsLatticePolytope`
- `IsRegularCone`
- `LatticePoints`
- `LatticePointsGenerators`
- `MainPolytope`
- `MainRatPolytope`
- `NormalFan`
- `Polyhedron`
- `PolyhedronByInequalities`
- `Polytope`
- `PolytopeByInequalities`
- `RandomInteriorPoint`
- `SolveEqualitiesAndInequalitiesOverIntergers`
- `SolveLinearProgram`
- `Vertices`
- `VerticesOfPolytope`
- plus source-only declared helper/auxiliary surfaces tracked in `docs/nconvex_methods_checklist.md`.

### 4.9 CddInterface methods

- `Cdd_AmbientSpaceDimension`
- `Cdd_Canonicalize`
- `Cdd_Dimension`
- `Cdd_Equalities`
- `Cdd_ExtendLinearity`
- `Cdd_Faces`
- `Cdd_FacesWithFixedDimensionAndInteriorPoints`
- `Cdd_FacesWithFixedDimension`
- `Cdd_FacesWithInteriorPoints`
- `Cdd_Facets`
- `Cdd_FourierProjection`
- `Cdd_GeneratingRays`
- `Cdd_GeneratingVertices`
- `Cdd_H_Rep`
- `Cdd_InteriorPoint`
- `Cdd_Intersection`
- `Cdd_Inequalities`
- `Cdd_IsCone`
- `Cdd_IsEmpty`
- `Cdd_IsContained`
- `Cdd_IsLinSpace`
- `Cdd_IsPointed`
- `Cdd_LinearProgram`
- `Cdd_Lines`
- `Cdd_PolyhedronByGenerators`
- `Cdd_PolyhedronByInequalities`
- `Cdd_V_Rep`
- `Cdd_Vertices`

### 4.10 Forms methods

- `AsSesquilinearForm`
- `AsQuadraticForm`
- `SesquilinearFormByMatrix`
- `QuadraticFormByMatrix`
- `IsSesquilinearForm`
- `IsQuadraticForm`
- `UnderlyingVectorSpace`
- `MatrixOfSesquilinearForm`
- `MatrixOfQuadraticForm`
- `RankOfForm`
- `BaseField`
- `IsReflexiveForm`
- `IsSymmetricForm`
- `IsAlternatingForm`
- `IsDegenerateForm`
- `RadicalOfForm`
- `IsometricForms`
- `SimilarityForms`
- `IsometryGroup`
- `SimilarityGroup`
- `InvariantBilinearForm`
- `InvariantQuadraticForm`
- `PreservedSesquilinearForms`
- `PreservedQuadraticForms`
- `OrthogonalSubgroups`
- `OrthogonalSubgroupsAsList`
- `OrthogonalComponents`
- `OrthogonalComponentsOfSubgroup`
- `WittIndex`

### 4.11 HyperCells methods (top-level entry points)

- `HyperCell`
- `TGCell`
- `TGCellGraph`
- `TGCellModelGraph`
- `TGSuperCell`
- `TGSuperCellModelGraph`
- `IsomorphicCell`
- `IsomorphicCellGraph`
- `IsomorphicSuperCellModelGraph`
- `TGSuperCells`
- `TGSuperCellModelGraphQClasses`
- `TGSuperCellQClasses`
- `TGSuperCellModelGraphZClasses`
- `TGSuperCellZClasses`
- `TGCellMSNFsByType`
- `TGCellMSNFsByTypeAndSpeciesAndGenus`
- `TGCellModelGraphsByType`
- `TGCellGraphsByType`
- `TGCellPointGroupReps`
- `TGCellPointGroupQClasses`
- `TGCellPointGroupZClasses`
- `TGCellPointGroupFamilies`
- `TGCellPointGroupGenera`

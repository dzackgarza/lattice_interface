# NTL Lattice and Integer-Matrix Reference
## Core `ZZ` matrix reduction and normal-form APIs

---

## Tag Legend

| Tag | Meaning |
|-----|---------|
| `[ZZMOD]` | Integer matrix / `ZZ`-module model |
| `[RED]` | Reduction workflow |
| `[SOLVE]` | Integer linear solve workflow |
| `[NF]` | Normal-form algorithm |
| `[CPP]` | C++ API surface |

---

## 1. Scope

NTL exposes lattice-relevant routines through integer matrix APIs over `ZZ`, especially:

- LLL/BKZ-style basis reduction,
- image/kernel and integer-solution helpers tied to reduced bases,
- Hermite normal form.

Representation convention in these APIs: lattice/module bases are given by matrix rows.

---

## 2. Exact LLL and Integer Solve Surface

| API | Description | Tags |
|-----|-------------|------|
| `LLL(ZZ& det2, mat_ZZ& B, long verbose=0)` | Exact LLL reduction; computes a reduced basis in-place and returns rank. | `[ZZMOD, RED, CPP]` |
| `LLL(ZZ& det2, mat_ZZ& B, mat_ZZ& U, long verbose=0)` | Exact LLL with unimodular transform matrix output. | `[ZZMOD, RED, CPP]` |
| `LLL_plus(ZZ& det2, mat_ZZ& B, mat_ZZ& U, long verbose=0)` | LLL variant exposing extra transformation/image structure for downstream solve/image routines. | `[ZZMOD, RED, CPP]` |
| `image(ZZ& det2, mat_ZZ& B, mat_ZZ& U, long verbose=0)` | Computes image/lattice basis data from integer matrix input using LLL-driven workflow. | `[ZZMOD, RED, CPP]` |
| `LatticeSolve(vec_ZZ& x, const mat_ZZ& A, const vec_ZZ& y, long reduce=0)` | Solves `x*A = y` over integers when possible; returns `0` if unsolvable, otherwise returns image determinant. | `[ZZMOD, SOLVE, CPP]` |

---

## 3. Floating LLL and BKZ Surface

| API family | Description | Tags |
|------------|-------------|------|
| `[G_]LLL_{FP,QP,XD,RR}(mat_ZZ& B[, mat_ZZ& U], double delta=0.99, long deep=0, LLLCheckFct check=0, long verbose=0)` | Floating-point LLL family over integer-basis input (`FP/QP/XD/RR` variants). | `[ZZMOD, RED, CPP]` |
| `[G_]BKZ_{FP,QP,QP1,XD,RR}(mat_ZZ& B[, mat_ZZ& U], double delta=0.99, long BlockSize=10, long prune=0, LLLCheckFct check=0, long verbose=0)` | BKZ family over the same integer-basis model, with configurable block size and pruning. | `[ZZMOD, RED, CPP]` |

Important caveats from upstream docs:

- `deep` is documented as deprecated in modern NTL usage.
- `BlockSize` and `prune` materially affect BKZ quality/runtime tradeoffs.
- APIs operate on row-basis matrices over `ZZ`; these are Euclidean reduction routines, not indefinite genus/isometry classification APIs.

---

## 4. Hermite Normal Form Surface

| API | Description | Tags |
|-----|-------------|------|
| `HNF(mat_ZZ& W, const mat_ZZ& A, const ZZ& D)` | Computes Hermite normal form for full-column-rank integer matrix input under documented determinant multiple precondition. | `[ZZMOD, NF, CPP]` |

Upstream preconditions summarized:

- `A` is `n x m` with rank `m` and `n >= m`,
- `D` is a positive multiple of the determinant of the lattice generated by columns of `A`.

---

## 5. Domain Caveat

NTL's lattice-reduction APIs here are integer-matrix and Euclidean-reduction oriented. They do not provide high-level indefinite arithmetic-form classification contracts (genus/discriminant-form/isometry-class APIs).

---

## 6. Sources

- NTL module map (LLL + HNF listed): `https://libntl.org/doc/tour-modules.html`
- NTL LLL/BKZ and solve API docs: `https://libntl.org/doc/LLL.cpp.html`
- NTL HNF API docs: `https://libntl.org/doc/HNF.cpp.html`
- NTL lattice-reduction tutorial examples: `https://libntl.org/doc/tour-ex4.html`


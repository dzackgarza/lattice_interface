
Launching Codex with minimax-m2.5:cloud...
OpenAI Codex v0.104.0 (research preview)
--------
workdir: /home/dzack/lattice_interface
model: minimax-m2.5:cloud
provider: ollama
approval: never
sandbox: danger-full-access
reasoning effort: none
reasoning summaries: auto
session id: 019c7372-82a2-7301-b27e-2ea81025b93c
--------
user
# Documentation Coverage Worker Prompt

## Role

You are a documentation worker for this repository.

## Job

Bring project documentation into alignment with what this project’s documentation is supposed to be.
The core task is complete documentation coverage of lattice-theory methods in the strict sense used by this project.

## Scope Definition (Mandatory)

In this project, "lattice theory" means:

- free `R`-modules of finite rank,
- equipped with a symmetric nondegenerate bilinear form,
- with methods that explicitly operate on that bilinear-form lattice structure (for example: Gram matrices/forms, discriminant groups/forms, genus/spinor genus, isometry/equivalence, local-global invariants, signatures, integral quadratic form workflows).

Out of scope:

- polyhedral, cone, toric, or (semi)linear programming tooling that does not explicitly address lattices as free modules with symmetric nondegenerate bilinear forms.
- documentation surfaces centered on H/V representations, convex hull/cone conversion, Ehrhart counting, generic LP/MIP, or triangulation/enumeration unless they include explicit bilinear-form lattice APIs matching the in-scope definition.

## FIRST GOAL (MANDATORY)

Perform a cursory maintenance check for missing in-scope package surfaces.

Current-phase interpretation:

- green-fielding new package checklists is largely complete,
- only check briefly whether any truly relevant bilinear-form lattice-theoretic package/algorithm is still missing,
- open a new package surface only when a clear, source-backed, in-scope gap is found.

## SECOND GOAL (MANDATORY)

Completeness and provable correctness of all documented methods:

- method coverage,
- argument surfaces,
- types,
- assumptions and constraints.

If any of the above is missing or unsupported for any method, triage that gap immediately.

Current-phase focus:

- Goal 2 and beyond are the active emphasis for this phase.
- Prioritize deepening correctness/completeness of existing in-scope surfaces over expanding package count.

Scope gate for all edits:

- before adding or expanding a package surface, verify the package actually provides APIs for lattices as free modules with symmetric nondegenerate bilinear forms.
- if a package does not satisfy that criterion, do not add/expand it as a lattice-theory target.

## MINOR GOAL (ONLY AFTER FIRST AND SECOND GOALS ARE CLEARLY SATISFIED)

Precision/clarity refinement work, including:

- fine-tuning wording,
- disambiguation,
- structural polish.

## What The Docs Are Supposed To Be

- Coverage of all in-scope bilinear-form lattice methods and contracts known in the active ecosystem.
- Mathematically precise statements, assumptions, domains, and caveats.
- Source-backed claims tied to canonical upstream docs and local snapshots.
- Cohesive, navigable structure across checklists and detailed references.
- Reliable continuity for future workers.

## Process Guidelines

- Serena is the continuity system:
  - activate the project,
  - read relevant memories,
  - write/update continuity and handoff memories before finishing.
- `docs/TODO.md` is the execution queue for outstanding documentation work:
  - review it at the start of each run,
  - complete relevant outstanding items within scope,
  - check off completed items (`- [x]`) as part of the same change.
- Git is the change ledger:
  - if documentation changes are made, commit them.
- Dirty git states are normal:
  - never discard/reset/revert/checkout unrelated existing changes,
  - stage and commit only files changed by your assignment.

## References

- `docs/documentation_coverage_audit_playbook.md`
- `AGENTS.md`
- `TEST_QUALITY.md`
- repository docs and local snapshots under `docs/**/upstream/`
- relevant upstream docs/repositories discovered via internet survey

## Output Format (Mandatory)

Your final output must be 2-3 plain sentences. No headers, no bullets, no markdown. Answer only: what was wrong or missing, what is now correct or known, and why it matters for the project. Skip mechanical details (file names, checklist items, commit hashes). Example: "The `genus` discriminant constraint in OSCAR was previously undocumented; it only applies to even lattices and silently fails on odd ones. This is now recorded with the exact source reference."

mcp: serena starting
warning: Model metadata for `minimax-m2.5:cloud` not found. Defaulting to fallback metadata; this can degrade performance and cause issues.
mcp: serena ready
mcp startup: ready: serena
thinking
Let me understand this task:

1. I'm a documentation worker for the lattice_interface repository
2. The job is to bring project documentation into alignment with what the project is supposed to be
3. "Lattice theory" in this project means:
   - free R-modules of finite rank
   - equipped with a symmetric nondegenerate bilinear form
   - methods that explicitly operate on that bilinear-form lattice structure

4. Goals:
   - FIRST: Cursory maintenance check for missing in-scope package surfaces
   - SECOND: Completeness and provable correctness of all documented methods
   - MINOR: Precision/clarity refinement (only after first two goals are satisfied)

5. I should:
   - Activate the project
   - Read relevant memories
   - Review docs/TODO.md
   - Make documentation changes
   - Commit them

Let me start by activating the project and checking the current state.
tool serena.activate_project({"project":"/home/dzack/lattice_interface"})
serena.activate_project({"project":"/home/dzack/lattice_interface"}) success in 39ms:
{
  "content": [
    {
      "type": "text",
      "text": "The project with name 'lattice_interface' at /home/dzack/lattice_interface is activated.\nProgramming languages: python; file encoding: utf-8\nAvailable project memories: [\"doc_coverage_audit_2026-02-18_gap_umbrella_polyhedral_archive\", \"doc_coverage_audit_2026-02-18_julia_isometry_map_return_contracts\", \"doc_coverage_audit_2026-02-17_crystallographic_toric_checklist_surfaces\", \"doc_coverage_audit_2026-02-18_torquadmodule_submodule_signatures_and_constructor_type_union\", \"doc_coverage_audit_2026-02-18_julia_genus_constructor_signature_fidelity\", \"doc_coverage_audit_2026-02-18_sage_is_genus_odd_contract_fidelity\", \"doc_coverage_audit_2026-02-18_fpylll_signature_fidelity_and_archive_scaffold\", \"doc_coverage_audit_2026-02-17_group_action_overloads_round3\", \"doc_coverage_audit_2026-02-17_palp_checklist_surface\", \"doc_coverage_audit_2026-02-18_crystallographic_signature_fidelity_round2\", \"doc_coverage_audit_2026-02-18_zzlatwithisom_order_contract_fidelity\", \"doc_coverage_audit_2026-02-17_minor_julia_package_signature_closure\", \"doc_coverage_audit_2026-02-18_fpylll_bkz_placeholder_signature_fidelity\", \"doc_coverage_audit_2026-02-18_torquadmodwithisom_submodules_signature_fidelity\", \"doc_coverage_audit_2026-02-18_gap_umbrella_crystallographic_signature_reconcile\", \"doc_coverage_audit_2026-02-18_polyhedral_scope_migration_completion\", \"project_overview\", \"doc_coverage_audit_2026-02-18_cddlib_cddinterface_archive_migration\", \"doc_coverage_audit_2026-02-17_topcom_checklist_surface\", \"doc_coverage_audit_2026-02-17_isom_signatures_round2\", \"doc_coverage_audit_2026-02-17_cddlib_pycddlib_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_hypercells_checklist_surface\", \"doc_coverage_audit_2026-02-17_lrslib_polymake_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_4ti2_normaliz_checklist_surfaces\", \"doc_coverage_audit_2026-02-18_sage_toric_archive_scope_cleanup\", \"doc_coverage_audit_2026-02-17_cdd_nconvex_checklist_surfaces\", \"style_and_conventions\", \"doc_coverage_audit_2026-02-17_isom_contracts\", \"doc_coverage_audit_2026-02-18_automorphism_group_definiteness_contract_fidelity\", \"doc_coverage_audit_2026-02-18_pycddlib_archive_and_sage_is_genus_contract\", \"doc_coverage_audit_2026-02-17_nconvex_method_inventory_closure\", \"doc_coverage_audit_2026-02-17_fingrpact_stabilizer_signature_fidelity\", \"doc_coverage_audit_2026-02-18_torquadmodwithisom_submodules_quotype_drift\", \"codex_serena_smoketest\", \"test_coverage_alignment_2026-02-18_checklist_tags_round1\", \"suggested_commands\", \"doc_coverage_audit_2026-02-17_ntl_flint_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_forms_checklist_surface\", \"doc_coverage_audit_2026-02-18_gap_normalformintmat_decomposition_signature_fidelity\", \"doc_coverage_audit_2026-02-18_sage_orthogonal_group_definiteness_contract_fidelity\", \"doc_coverage_audit_2026-02-18_kernel_lattice_signatures_and_image_centralizer_even_constraint\", \"doc_coverage_audit_2026-02-17_g6k_flatter_latte_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_pari_gp_signature_surface_closure\", \"doc_coverage_audit_2026-02-17_missing_package_checklist_surfaces\", \"task_completion\", \"doc_coverage_audit_2026-02-17_pycddlib_checklist_surface\", \"doc_coverage_audit_2026-02-17_package_surface_expansion_fplll_julia\", \"doc_coverage_audit_2026-02-18_crystallographic_selector_domain_closure\"]\nUse the `read_memory` tool to read these memories later if they are relevant to the task.\nIMPORTANT: If you have not yet read the 'Serena Instructions Manual', do it now before continuing!"
    }
  ],
  "structuredContent": {
    "result": "The project with name 'lattice_interface' at /home/dzack/lattice_interface is activated.\nProgramming languages: python; file encoding: utf-8\nAvailable project memories: [\"doc_coverage_audit_2026-02-18_gap_umbrella_polyhedral_archive\", \"doc_coverage_audit_2026-02-18_julia_isometry_map_return_contracts\", \"doc_coverage_audit_2026-02-17_crystallographic_toric_checklist_surfaces\", \"doc_coverage_audit_2026-02-18_torquadmodule_submodule_signatures_and_constructor_type_union\", \"doc_coverage_audit_2026-02-18_julia_genus_constructor_signature_fidelity\", \"doc_coverage_audit_2026-02-18_sage_is_genus_odd_contract_fidelity\", \"doc_coverage_audit_2026-02-18_fpylll_signature_fidelity_and_archive_scaffold\", \"doc_coverage_audit_2026-02-17_group_action_overloads_round3\", \"doc_coverage_audit_2026-02-17_palp_checklist_surface\", \"doc_coverage_audit_2026-02-18_crystallographic_signature_fidelity_round2\", \"doc_coverage_audit_2026-02-18_zzlatwithisom_order_contract_fidelity\", \"doc_coverage_audit_2026-02-17_minor_julia_package_signature_closure\", \"doc_coverage_audit_2026-02-18_fpylll_bkz_placeholder_signature_fidelity\", \"doc_coverage_audit_2026-02-18_torquadmodwithisom_submodules_signature_fidelity\", \"doc_coverage_audit_2026-02-18_gap_umbrella_crystallographic_signature_reconcile\", \"doc_coverage_audit_2026-02-18_polyhedral_scope_migration_completion\", \"project_overview\", \"doc_coverage_audit_2026-02-18_cddlib_cddinterface_archive_migration\", \"doc_coverage_audit_2026-02-17_topcom_checklist_surface\", \"doc_coverage_audit_2026-02-17_isom_signatures_round2\", \"doc_coverage_audit_2026-02-17_cddlib_pycddlib_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_hypercells_checklist_surface\", \"doc_coverage_audit_2026-02-17_lrslib_polymake_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_4ti2_normaliz_checklist_surfaces\", \"doc_coverage_audit_2026-02-18_sage_toric_archive_scope_cleanup\", \"doc_coverage_audit_2026-02-17_cdd_nconvex_checklist_surfaces\", \"style_and_conventions\", \"doc_coverage_audit_2026-02-17_isom_contracts\", \"doc_coverage_audit_2026-02-18_automorphism_group_definiteness_contract_fidelity\", \"doc_coverage_audit_2026-02-18_pycddlib_archive_and_sage_is_genus_contract\", \"doc_coverage_audit_2026-02-17_nconvex_method_inventory_closure\", \"doc_coverage_audit_2026-02-17_fingrpact_stabilizer_signature_fidelity\", \"doc_coverage_audit_2026-02-18_torquadmodwithisom_submodules_quotype_drift\", \"codex_serena_smoketest\", \"test_coverage_alignment_2026-02-18_checklist_tags_round1\", \"suggested_commands\", \"doc_coverage_audit_2026-02-17_ntl_flint_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_forms_checklist_surface\", \"doc_coverage_audit_2026-02-18_gap_normalformintmat_decomposition_signature_fidelity\", \"doc_coverage_audit_2026-02-18_sage_orthogonal_group_definiteness_contract_fidelity\", \"doc_coverage_audit_2026-02-18_kernel_lattice_signatures_and_image_centralizer_even_constraint\", \"doc_coverage_audit_2026-02-17_g6k_flatter_latte_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_pari_gp_signature_surface_closure\", \"doc_coverage_audit_2026-02-17_missing_package_checklist_surfaces\", \"task_completion\", \"doc_coverage_audit_2026-02-17_pycddlib_checklist_surface\", \"doc_coverage_audit_2026-02-17_package_surface_expansion_fplll_julia\", \"doc_coverage_audit_2026-02-18_crystallographic_selector_domain_closure\"]\nUse the `read_memory` tool to read these memories later if they are relevant to the task.\nIMPORTANT: If you have not yet read the 'Serena Instructions Manual', do it now before continuing!"
  },
  "isError": false
}
thinking
Let me read the documentation coverage audit playbook and the TODO.md file to understand the current state of work and what needs to be done.
tool serena.read_file({"relative_path":"docs/documentation_coverage_audit_playbook.md"})
serena.read_file({"relative_path":"docs/documentation_coverage_audit_playbook.md"}) success in 50ms:
{
  "content": [
    {
      "type": "text",
      "text": "# Documentation Coverage Audit Playbook\n\n## Role\n\nDocumentation worker for this mathematics project.\n\n## Job\n\nBring the current documentation into alignment with what the project documentation is supposed to be.\n\n## Scope Definition (Mandatory)\n\nFor this project, \"lattice theory\" is strictly:\n\n- free `R`-modules of finite rank,\n- equipped with a symmetric nondegenerate bilinear form,\n- and method surfaces that explicitly operate on that structure (for example: Gram/form operations, discriminant forms/groups, genus/spinor genus, local-global invariants, isometry/equivalence, signature, integral quadratic form workflows).\n\nOut of scope unless explicit bilinear-form lattice APIs are present:\n\n- polyhedral/cone/H-V representation tooling,\n- (semi)linear programming and generic optimization stacks,\n- toric/fan/polytope pipelines,\n- counting/enumeration stacks (for example Ehrhart/lattice-point pipelines) that do not operate on symmetric nondegenerate bilinear-form lattices,\n- packages using \"lattice\" in the physics sense (periodic atomic arrangements, moiré patterns) without bilinear-form structure.\n\n## In-Scope Package Registry\n\nEvery package with a checklist in this repository and the mathematical reason it is in scope:\n\n| Package | Scope justification |\n|---------|---------------------|\n| SageMath | Integral/rational lattice constructors, Gram/discriminant/genus/isometry APIs, quadratic forms over ℤ |\n| Oscar.jl / Hecke.jl / Nemo.jl | ℤ-lattice constructors, bilinear-form operations, genus/isometry/automorphism APIs |\n| GAP (core) | Integer-matrix normal forms (HNF/SNF), lattice-relevant matrix algebra |\n| Forms (GAP) | Sesquilinear and quadratic forms on free modules over finite fields — direct instances of R-modules with bilinear forms |\n| HyperCells (GAP) | Triangle-group tessellations as fundamental domains of reflection groups acting on $L \\otimes \\mathbf{R}$, tied to indefinite bilinear-form lattice structure |\n| Crystallographic stack (GAP) | Crystallographic groups as subgroups of $O(L)$, operating on lattices via their bilinear form |\n| fpylll | LLL/BKZ/SVP/CVP algorithms on Euclidean lattices with inner-product (bilinear-form) structure (Python interface to fplll) |\n| g6k | Sieving algorithms for SVP/BKZ on Euclidean lattices with inner-product structure |\n| flatter | Lattice basis reduction operating on bilinear-form structure |\n| FLINT | Integer-matrix reduction and normal-form algorithms (HNF/SNF/LLL) on ℤ-modules |\n| NTL | Integer-matrix LLL and normal-form algorithms on ℤ-modules |\n| PARI/GP | Explicit `qf*` quadratic-form APIs: reduction, equivalence, genus, representation |\n\nOut of scope (documented but not tracked for checklist completion):\n\n| Package | Reason |\n|---------|--------|\n| fplll | C++ backend; superseded by fpylll as the project's interface surface |\n| latticegen (fplll utility) | Benchmark instance generator with no bilinear-form API surface; covered by fpylll checklist |\n| latticegen (Python/moiré) | Physics \"lattice\" (periodic image patterns), not bilinear-form lattice |\n\n## FIRST GOAL (MANDATORY)\n\nEnsure checklist coverage exists for all known relevant in-scope bilinear-form lattice packages in the ecosystem.\nIf a known in-scope package lacks a checklist surface in this repository, creating that checklist surface is the first priority.\n\n## SECOND GOAL (MANDATORY)\n\nCompleteness and provable correctness of all documented methods:\n\n- method coverage,\n- argument surfaces,\n- types,\n- assumptions and constraints.\n\nIf any of the above is missing or unsupported for any method, triage that gap immediately.\n\nScope gate for every assignment:\n\n- before adding or expanding any package surface, verify that the package has explicit APIs for free-module lattices with symmetric nondegenerate bilinear forms.\n- if it does not, treat it as out-of-scope and do not prioritize or expand it as a lattice-theory target.\n\n## MINOR GOAL (ONLY AFTER FIRST AND SECOND GOALS ARE CLEARLY SATISFIED)\n\nPrecision/clarity refinement work, including:\n\n- fine-tuning wording,\n- disambiguation,\n- structural polish.\n\n## What The Docs Are Supposed To Be\n\n- Source-backed coverage of all in-scope bilinear-form lattice methods and contracts known in the active ecosystem.\n- Mathematically correct and explicit contracts, assumptions, domains, and caveats.\n- Clear organization and navigation across checklists and detailed references.\n- Durable continuity and handoffs for future workers.\n\n## Quality Questions\n\nTreat these as project-wide values to assess continuously:\n\n- Are there online packages/docs with lattice algorithms not yet represented in the documentation surfaces?\n- Are candidate packages truly in scope, i.e. do they explicitly implement lattices as free modules with symmetric nondegenerate bilinear forms?\n- Do the docs clearly help a human understand what methods/tools are available and when to use them?\n- Is the current organization cohesive and easy to navigate across checklists and detailed references?\n- Do older docs need restructuring/reorganization to improve mathematical clarity or discoverability?\n- Did any edit remove mathematically relevant information?\n- Did the git diff actually improve quality against these questions?\n- Were edits grounded in real source documents/snapshots rather than assumptions or innate knowledge?\n- Were any mathematical assumptions introduced that are not clearly evidenced in source docs?\n- Were critical assumptions omitted (for example, positive-definite-only or ring/domain constraints)?\n- Were differing definitions/assumptions of lattices across sources reconciled where needed?\n- Were restrictions, assumptions, constraints, or authoritative statements introduced without clear source evidence?\n- Is language anywhere in the touched documentation surface vague or mathematically imprecise?\n- Are improvements grounded in checkable/provable statements?\n- Were vague claims introduced (`usually`, `typically`, `often`, `most of the time`) where exact truth values are available?\n- Were weak deferrals left in place (`unknown`, `unverified`, `needs testing`) where questions are reasonably answerable through docs/source/web research?\n- Did this assignment improve project-wide alignment to complete known-method coverage, rather than only local wording?\n- Did this assignment avoid expanding out-of-scope polyhedral/LP/toric/counting stacks that do not expose bilinear-form lattice APIs?\n\n## Process Guidelines\n\n- Serena is the primary continuity and handoff system:\n  - activate project,\n  - read relevant memories,\n  - write/update memories with decisions, remaining gaps, and follow-up tasks.\n- `docs/TODO.md` is the outstanding work queue:\n  - review it at the start of each assignment,\n  - execute relevant in-scope open items,\n  - mark completed items as checked (`- [x]`) in the same assignment.\n- Git is the change ledger:\n  - commit documentation changes produced by the assignment.\n  - push those commits after completion, using `GITHUB_TOKEN` from `.env`.\n- Dirty git states are normal:\n  - never discard/revert/reset/checkout unrelated existing changes,\n  - never run destructive repo-wide cleanup,\n  - stage, commit, and push only files changed by the assignment.\n\n### Network Bailout Contingency (Mandatory)\n\n- If a known/canonical upstream URL is discovered via web results but direct shell retrieval fails (for example `curl` DNS/TLS/connectivity failure), do not keep looping broad web searches.\n- Retry the same URL a small fixed number of times (`<=2`) and record the exact failing command + error output in provenance/handoff notes.\n- Treat this as an environment access failure, not proof that upstream docs do not exist.\n- Earmark the blocked source task for explicit future follow-up with:\n  - URL(s),\n  - UTC timestamp,\n  - observed error class (`dns`, `timeout`, `tls`, etc.),\n  - exact remaining method-surface gap.\n- Then pivot the same run to substantial offline work (not meta-only churn), such as:\n  - improving source-backed contracts from local snapshots under `docs/**/upstream/`,\n  - correcting invalid/broken links and provenance mismatches,\n  - tightening argument/type/constraint tables for already available packages,\n  - reconciling checklist/reference consistency using existing local evidence.\n\n## References\n\nCore repository references:\n\n- `README.md`\n- `AGENTS.md`\n- `TEST_QUALITY.md`\n- `docs/sage_methods_checklist.md`\n- `docs/julia_methods_checklist.md`\n- `docs/gap_methods_checklist.md`\n- `docs/forms_methods_checklist.md`\n- `docs/hypercells_methods_checklist.md`\n- `docs/flint_methods_checklist.md`\n- `docs/fpylll_methods_checklist.md`\n- `docs/ntl_methods_checklist.md`\n- `docs/pari_gp_methods_checklist.md`\n- `docs/latticegen_methods_checklist.md`\n- `docs/lattice_wrapper_capability_checklist.md`\n- `docs/method_ground_truth_tracker.csv`\n- local upstream snapshots under `docs/**/upstream/`\n\nUpstream living map:\n\n- SageMath:\n  - source: `https://github.com/sagemath/sage`\n  - docs: `https://doc.sagemath.org`\n- Oscar.jl:\n  - source: `https://github.com/oscar-system/Oscar.jl`\n  - docs: `https://docs.oscar-system.org`\n- Hecke.jl:\n  - source: `https://github.com/thofma/Hecke.jl`\n  - docs: `https://docs.hecke.thofma.com`\n- Nemo.jl (official):\n  - source: `https://github.com/Nemocas/Nemo.jl`\n  - docs: `https://nemocas.github.io/Nemo.jl/stable/`\n- AbstractAlgebra.jl:\n  - source: `https://github.com/Nemocas/AbstractAlgebra.jl`\n  - docs: `https://nemocas.github.io/AbstractAlgebra.jl/stable/`\n- GAP:\n  - source: `https://github.com/gap-system/gap`\n  - docs hub: `https://www.gap-system.org/doc/`\n  - package docs/index: `https://gap-packages.github.io`\n- HyperCells (GAP package):\n  - package page: `https://gap-packages.github.io/HyperCells/`\n  - manual: `https://www.hypercells.net/chap0_mj.html`\n- CddInterface (GAP package):\n  - package page: `https://homalg-project.github.io/CddInterface/`\n  - manual: `https://homalg-project.github.io/CddInterface/doc/chap0_mj.html`\n- NConvex (GAP package):\n  - package page: `https://homalg-project.github.io/NConvex/`\n  - source: `https://github.com/homalg-project/NConvex`\n- Forms (GAP package):\n  - package page: `https://gap-packages.github.io/forms/`\n  - manual: `https://gap-packages.github.io/forms/doc/chap0_mj.html`\n- fpylll (Python interface to fplll):\n  - `https://github.com/fplll/fpylll`\n- NTL:\n  - source/docs: `https://libntl.org`\n- FLINT:\n  - source: `https://github.com/flintlib/flint`\n  - docs: `https://flintlib.org/doc/`\n- PARI/GP:\n  - `https://pari.math.u-bordeaux.fr`"
    }
  ],
  "structuredContent": {
    "result": "# Documentation Coverage Audit Playbook\n\n## Role\n\nDocumentation worker for this mathematics project.\n\n## Job\n\nBring the current documentation into alignment with what the project documentation is supposed to be.\n\n## Scope Definition (Mandatory)\n\nFor this project, \"lattice theory\" is strictly:\n\n- free `R`-modules of finite rank,\n- equipped with a symmetric nondegenerate bilinear form,\n- and method surfaces that explicitly operate on that structure (for example: Gram/form operations, discriminant forms/groups, genus/spinor genus, local-global invariants, isometry/equivalence, signature, integral quadratic form workflows).\n\nOut of scope unless explicit bilinear-form lattice APIs are present:\n\n- polyhedral/cone/H-V representation tooling,\n- (semi)linear programming and generic optimization stacks,\n- toric/fan/polytope pipelines,\n- counting/enumeration stacks (for example Ehrhart/lattice-point pipelines) that do not operate on symmetric nondegenerate bilinear-form lattices,\n- packages using \"lattice\" in the physics sense (periodic atomic arrangements, moiré patterns) without bilinear-form structure.\n\n## In-Scope Package Registry\n\nEvery package with a checklist in this repository and the mathematical reason it is in scope:\n\n| Package | Scope justification |\n|---------|---------------------|\n| SageMath | Integral/rational lattice constructors, Gram/discriminant/genus/isometry APIs, quadratic forms over ℤ |\n| Oscar.jl / Hecke.jl / Nemo.jl | ℤ-lattice constructors, bilinear-form operations, genus/isometry/automorphism APIs |\n| GAP (core) | Integer-matrix normal forms (HNF/SNF), lattice-relevant matrix algebra |\n| Forms (GAP) | Sesquilinear and quadratic forms on free modules over finite fields — direct instances of R-modules with bilinear forms |\n| HyperCells (GAP) | Triangle-group tessellations as fundamental domains of reflection groups acting on $L \\otimes \\mathbf{R}$, tied to indefinite bilinear-form lattice structure |\n| Crystallographic stack (GAP) | Crystallographic groups as subgroups of $O(L)$, operating on lattices via their bilinear form |\n| fpylll | LLL/BKZ/SVP/CVP algorithms on Euclidean lattices with inner-product (bilinear-form) structure (Python interface to fplll) |\n| g6k | Sieving algorithms for SVP/BKZ on Euclidean lattices with inner-product structure |\n| flatter | Lattice basis reduction operating on bilinear-form structure |\n| FLINT | Integer-matrix reduction and normal-form algorithms (HNF/SNF/LLL) on ℤ-modules |\n| NTL | Integer-matrix LLL and normal-form algorithms on ℤ-modules |\n| PARI/GP | Explicit `qf*` quadratic-form APIs: reduction, equivalence, genus, representation |\n\nOut of scope (documented but not tracked for checklist completion):\n\n| Package | Reason |\n|---------|--------|\n| fplll | C++ backend; superseded by fpylll as the project's interface surface |\n| latticegen (fplll utility) | Benchmark instance generator with no bilinear-form API surface; covered by fpylll checklist |\n| latticegen (Python/moiré) | Physics \"lattice\" (periodic image patterns), not bilinear-form lattice |\n\n## FIRST GOAL (MANDATORY)\n\nEnsure checklist coverage exists for all known relevant in-scope bilinear-form lattice packages in the ecosystem.\nIf a known in-scope package lacks a checklist surface in this repository, creating that checklist surface is the first priority.\n\n## SECOND GOAL (MANDATORY)\n\nCompleteness and provable correctness of all documented methods:\n\n- method coverage,\n- argument surfaces,\n- types,\n- assumptions and constraints.\n\nIf any of the above is missing or unsupported for any method, triage that gap immediately.\n\nScope gate for every assignment:\n\n- before adding or expanding any package surface, verify that the package has explicit APIs for free-module lattices with symmetric nondegenerate bilinear forms.\n- if it does not, treat it as out-of-scope and do not prioritize or expand it as a lattice-theory target.\n\n## MINOR GOAL (ONLY AFTER FIRST AND SECOND GOALS ARE CLEARLY SATISFIED)\n\nPrecision/clarity refinement work, including:\n\n- fine-tuning wording,\n- disambiguation,\n- structural polish.\n\n## What The Docs Are Supposed To Be\n\n- Source-backed coverage of all in-scope bilinear-form lattice methods and contracts known in the active ecosystem.\n- Mathematically correct and explicit contracts, assumptions, domains, and caveats.\n- Clear organization and navigation across checklists and detailed references.\n- Durable continuity and handoffs for future workers.\n\n## Quality Questions\n\nTreat these as project-wide values to assess continuously:\n\n- Are there online packages/docs with lattice algorithms not yet represented in the documentation surfaces?\n- Are candidate packages truly in scope, i.e. do they explicitly implement lattices as free modules with symmetric nondegenerate bilinear forms?\n- Do the docs clearly help a human understand what methods/tools are available and when to use them?\n- Is the current organization cohesive and easy to navigate across checklists and detailed references?\n- Do older docs need restructuring/reorganization to improve mathematical clarity or discoverability?\n- Did any edit remove mathematically relevant information?\n- Did the git diff actually improve quality against these questions?\n- Were edits grounded in real source documents/snapshots rather than assumptions or innate knowledge?\n- Were any mathematical assumptions introduced that are not clearly evidenced in source docs?\n- Were critical assumptions omitted (for example, positive-definite-only or ring/domain constraints)?\n- Were differing definitions/assumptions of lattices across sources reconciled where needed?\n- Were restrictions, assumptions, constraints, or authoritative statements introduced without clear source evidence?\n- Is language anywhere in the touched documentation surface vague or mathematically imprecise?\n- Are improvements grounded in checkable/provable statements?\n- Were vague claims introduced (`usually`, `typically`, `often`, `most of the time`) where exact truth values are available?\n- Were weak deferrals left in place (`unknown`, `unverified`, `needs testing`) where questions are reasonably answerable through docs/source/web research?\n- Did this assignment improve project-wide alignment to complete known-method coverage, rather than only local wording?\n- Did this assignment avoid expanding out-of-scope polyhedral/LP/toric/counting stacks that do not expose bilinear-form lattice APIs?\n\n## Process Guidelines\n\n- Serena is the primary continuity and handoff system:\n  - activate project,\n  - read relevant memories,\n  - write/update memories with decisions, remaining gaps, and follow-up tasks.\n- `docs/TODO.md` is the outstanding work queue:\n  - review it at the start of each assignment,\n  - execute relevant in-scope open items,\n  - mark completed items as checked (`- [x]`) in the same assignment.\n- Git is the change ledger:\n  - commit documentation changes produced by the assignment.\n  - push those commits after completion, using `GITHUB_TOKEN` from `.env`.\n- Dirty git states are normal:\n  - never discard/revert/reset/checkout unrelated existing changes,\n  - never run destructive repo-wide cleanup,\n  - stage, commit, and push only files changed by the assignment.\n\n### Network Bailout Contingency (Mandatory)\n\n- If a known/canonical upstream URL is discovered via web results but direct shell retrieval fails (for example `curl` DNS/TLS/connectivity failure), do not keep looping broad web searches.\n- Retry the same URL a small fixed number of times (`<=2`) and record the exact failing command + error output in provenance/handoff notes.\n- Treat this as an environment access failure, not proof that upstream docs do not exist.\n- Earmark the blocked source task for explicit future follow-up with:\n  - URL(s),\n  - UTC timestamp,\n  - observed error class (`dns`, `timeout`, `tls`, etc.),\n  - exact remaining method-surface gap.\n- Then pivot the same run to substantial offline work (not meta-only churn), such as:\n  - improving source-backed contracts from local snapshots under `docs/**/upstream/`,\n  - correcting invalid/broken links and provenance mismatches,\n  - tightening argument/type/constraint tables for already available packages,\n  - reconciling checklist/reference consistency using existing local evidence.\n\n## References\n\nCore repository references:\n\n- `README.md`\n- `AGENTS.md`\n- `TEST_QUALITY.md`\n- `docs/sage_methods_checklist.md`\n- `docs/julia_methods_checklist.md`\n- `docs/gap_methods_checklist.md`\n- `docs/forms_methods_checklist.md`\n- `docs/hypercells_methods_checklist.md`\n- `docs/flint_methods_checklist.md`\n- `docs/fpylll_methods_checklist.md`\n- `docs/ntl_methods_checklist.md`\n- `docs/pari_gp_methods_checklist.md`\n- `docs/latticegen_methods_checklist.md`\n- `docs/lattice_wrapper_capability_checklist.md`\n- `docs/method_ground_truth_tracker.csv`\n- local upstream snapshots under `docs/**/upstream/`\n\nUpstream living map:\n\n- SageMath:\n  - source: `https://github.com/sagemath/sage`\n  - docs: `https://doc.sagemath.org`\n- Oscar.jl:\n  - source: `https://github.com/oscar-system/Oscar.jl`\n  - docs: `https://docs.oscar-system.org`\n- Hecke.jl:\n  - source: `https://github.com/thofma/Hecke.jl`\n  - docs: `https://docs.hecke.thofma.com`\n- Nemo.jl (official):\n  - source: `https://github.com/Nemocas/Nemo.jl`\n  - docs: `https://nemocas.github.io/Nemo.jl/stable/`\n- AbstractAlgebra.jl:\n  - source: `https://github.com/Nemocas/AbstractAlgebra.jl`\n  - docs: `https://nemocas.github.io/AbstractAlgebra.jl/stable/`\n- GAP:\n  - source: `https://github.com/gap-system/gap`\n  - docs hub: `https://www.gap-system.org/doc/`\n  - package docs/index: `https://gap-packages.github.io`\n- HyperCells (GAP package):\n  - package page: `https://gap-packages.github.io/HyperCells/`\n  - manual: `https://www.hypercells.net/chap0_mj.html`\n- CddInterface (GAP package):\n  - package page: `https://homalg-project.github.io/CddInterface/`\n  - manual: `https://homalg-project.github.io/CddInterface/doc/chap0_mj.html`\n- NConvex (GAP package):\n  - package page: `https://homalg-project.github.io/NConvex/`\n  - source: `https://github.com/homalg-project/NConvex`\n- Forms (GAP package):\n  - package page: `https://gap-packages.github.io/forms/`\n  - manual: `https://gap-packages.github.io/forms/doc/chap0_mj.html`\n- fpylll (Python interface to fplll):\n  - `https://github.com/fplll/fpylll`\n- NTL:\n  - source/docs: `https://libntl.org`\n- FLINT:\n  - source: `https://github.com/flintlib/flint`\n  - docs: `https://flintlib.org/doc/`\n- PARI/GP:\n  - `https://pari.math.u-bordeaux.fr`"
  },
  "isError": false
}
tool serena.read_file({"relative_path":"docs/TODO.md"})
serena.read_file({"relative_path":"docs/TODO.md"}) success in 103ms:
{
  "content": [
    {
      "type": "text",
      "text": "# Documentation Gaps - Bilinear-Form Lattice Methods\n\nThis file tracks missing prerequisites for building the per-package method checklists correctly.\nThe checklists themselves track per-method completion; this file tracks what must exist *before* checklist entries can be filled out with source-backed accuracy (primarily: local copies of upstream docs).\n\nReal work needed.\n\n## Goal 1 maintenance checks (2026-02-18 pass)\n\n- [x] Cursory in-scope package-gap scan: no clear new bilinear-form lattice package surface requiring a new checklist was identified in this pass.\n\n## Goal 2 contract-fidelity items (2026-02-18 pass)\n\n- [x] Tighten `TorQuadModule.submodules` and `TorQuadModule.stable_submodules` signatures in Julia umbrella reference, Hecke mirror reference, and checklist — replaced `...` placeholders with source-backed typed signatures from upstream Hecke `TorQuadModule` discriminant-group docs.\n- [x] Reconcile `torsion_quadratic_module_with_isometry` constructor type union in Julia umbrella reference, Hecke mirror reference, and checklist — added `AutomorphismGroupElem{TorQuadModule}` to the documented type union `U` for the `f` parameter, per OSCAR stable upstream docs.\n- [x] Add optional-parameter fidelity (`[f]` notation) to both `torsion_quadratic_module_with_isometry` constructor rows across all three surfaces.\n- [x] Tighten `kernel_lattice(::ZZLatWithIsom, ...)` typed dispatch signatures (polynomial and integer overloads) and add primitivity caveats across checklist, Julia umbrella reference, and Hecke mirror reference — sourced from local snapshot `latwithisom.md`.\n- [x] Add missing even-lattice precondition to `image_centralizer_in_Oq` (hermitian Miranda-Morrison only available for even lattices) and differentiation caveat for `image_in_Oq` — sourced from local snapshot `latwithisom.md`.\n- [x] Add typed signatures and tuple return shapes for `TorQuadModuleWithIsom` submodule/aut-group methods (`sub`, `primary_part`, `orthogonal_submodule` return `(TorQuadModuleWithIsom, TorQuadModuleMap)`; `automorphism_group_with_inclusion` returns `(AutomorphismGroup{TorQuadModule}, GAPGroupHomomorphism)`) — sourced from OSCAR stable upstream `torquadmodwithisom` page (2026-02-18).\n- [x] Fix `discriminant_group(Lf)` return type to `(TorQuadModule, AutomorphismGroupElem)` and `::Type{TorQuadModuleWithIsom}` type-argument form; add `discriminant_representation` keyword args (`full`, `check`); add `invariant_coinvariant_pair(Lf)` tuple return `(ZZLatWithIsom, ZZLatWithIsom)`; add `signatures(Lf)` cyclotomic/irreducible constraint and `rational_spinor_norm` `b=-1` default; fix `close_vectors` `check` default to `false`; add `lll` `redo` and `ctx` kwargs; fix `rational_span(Lf)` return type to `QuadSpaceWithIsom` — all sourced from OSCAR stable upstream `latwithisom` and `integer_lattices` pages (2026-02-18).\n\n- [x] Fix `IntegralLattice.orthogonal_group` definiteness constraint: tag was `[PD]` (positive definite only) but upstream docs confirm negative definite lattices also work; only indefinite lattices raise `NotImplementedError` — corrected to `[DEFINITE]` across `sage_integral_lattice_reference.md` (method table + definiteness summary) and `sagemath_lattice_reference.md` (method table + two pitfalls entries). Sourced from local upstream snapshot `free_quadratic_module_integer_symmetric.html`.\n\n- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \"Given a definite lattice `L`\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.\n\n## Goal 2 contract-fidelity verification (2026-02-18 follow-up)\n\n- [x] Verified `torquadmodwithisom.md` local snapshot already has `submodules(::TorQuadModuleWithIsom; quotype::Vector{Int}=Int[])` keyword contract — Julia references and checklist are consistent with local snapshot.\n\n## Missing Local Doc Copies\n\nThese packages have partial or need complete local copies of upstream docs:\n\n- [ ] flint (has .rst files under upstream/, needs integration check)\n- [ ] gap (core GAP docs)\n- [x] Replace `NormalFormIntMat(...)` and `Decomposition(...)` placeholder signatures in GAP core reference and checklist with source-backed typed signatures — `NormalFormIntMat(mat, options)` with full bitmask contract and record-return shape; `Decomposition(A, B, depth)` with cyclotomic-matrix rank constraint and `\"nonnegative\"` depth variant — sourced from local upstream `docs/gap/upstream/matint.gd` §NormalFormIntMat and `docs/gap/upstream/chap25.html` §25.4-1.\n\n- [ ] ntl (has .txt/.cpp.html files under upstream/, needs integration check)\n- [ ] fpylll (partial docs)\n- [ ] forms (partial docs)\n- [ ] g6k (partial docs)\n- [ ] crystallographic_stack (partial docs)\n- [ ] pari_gp (partial docs)\n\nAlready addressed:\n- [x] hypercells (has full chapter snapshots under upstream/)\n- [x] flatter (has README and example profiles under upstream/)"
    }
  ],
  "structuredContent": {
    "result": "# Documentation Gaps - Bilinear-Form Lattice Methods\n\nThis file tracks missing prerequisites for building the per-package method checklists correctly.\nThe checklists themselves track per-method completion; this file tracks what must exist *before* checklist entries can be filled out with source-backed accuracy (primarily: local copies of upstream docs).\n\nReal work needed.\n\n## Goal 1 maintenance checks (2026-02-18 pass)\n\n- [x] Cursory in-scope package-gap scan: no clear new bilinear-form lattice package surface requiring a new checklist was identified in this pass.\n\n## Goal 2 contract-fidelity items (2026-02-18 pass)\n\n- [x] Tighten `TorQuadModule.submodules` and `TorQuadModule.stable_submodules` signatures in Julia umbrella reference, Hecke mirror reference, and checklist — replaced `...` placeholders with source-backed typed signatures from upstream Hecke `TorQuadModule` discriminant-group docs.\n- [x] Reconcile `torsion_quadratic_module_with_isometry` constructor type union in Julia umbrella reference, Hecke mirror reference, and checklist — added `AutomorphismGroupElem{TorQuadModule}` to the documented type union `U` for the `f` parameter, per OSCAR stable upstream docs.\n- [x] Add optional-parameter fidelity (`[f]` notation) to both `torsion_quadratic_module_with_isometry` constructor rows across all three surfaces.\n- [x] Tighten `kernel_lattice(::ZZLatWithIsom, ...)` typed dispatch signatures (polynomial and integer overloads) and add primitivity caveats across checklist, Julia umbrella reference, and Hecke mirror reference — sourced from local snapshot `latwithisom.md`.\n- [x] Add missing even-lattice precondition to `image_centralizer_in_Oq` (hermitian Miranda-Morrison only available for even lattices) and differentiation caveat for `image_in_Oq` — sourced from local snapshot `latwithisom.md`.\n- [x] Add typed signatures and tuple return shapes for `TorQuadModuleWithIsom` submodule/aut-group methods (`sub`, `primary_part`, `orthogonal_submodule` return `(TorQuadModuleWithIsom, TorQuadModuleMap)`; `automorphism_group_with_inclusion` returns `(AutomorphismGroup{TorQuadModule}, GAPGroupHomomorphism)`) — sourced from OSCAR stable upstream `torquadmodwithisom` page (2026-02-18).\n- [x] Fix `discriminant_group(Lf)` return type to `(TorQuadModule, AutomorphismGroupElem)` and `::Type{TorQuadModuleWithIsom}` type-argument form; add `discriminant_representation` keyword args (`full`, `check`); add `invariant_coinvariant_pair(Lf)` tuple return `(ZZLatWithIsom, ZZLatWithIsom)`; add `signatures(Lf)` cyclotomic/irreducible constraint and `rational_spinor_norm` `b=-1` default; fix `close_vectors` `check` default to `false`; add `lll` `redo` and `ctx` kwargs; fix `rational_span(Lf)` return type to `QuadSpaceWithIsom` — all sourced from OSCAR stable upstream `latwithisom` and `integer_lattices` pages (2026-02-18).\n\n- [x] Fix `IntegralLattice.orthogonal_group` definiteness constraint: tag was `[PD]` (positive definite only) but upstream docs confirm negative definite lattices also work; only indefinite lattices raise `NotImplementedError` — corrected to `[DEFINITE]` across `sage_integral_lattice_reference.md` (method table + definiteness summary) and `sagemath_lattice_reference.md` (method table + two pitfalls entries). Sourced from local upstream snapshot `free_quadratic_module_integer_symmetric.html`.\n\n- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \"Given a definite lattice `L`\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.\n\n## Goal 2 contract-fidelity verification (2026-02-18 follow-up)\n\n- [x] Verified `torquadmodwithisom.md` local snapshot already has `submodules(::TorQuadModuleWithIsom; quotype::Vector{Int}=Int[])` keyword contract — Julia references and checklist are consistent with local snapshot.\n\n## Missing Local Doc Copies\n\nThese packages have partial or need complete local copies of upstream docs:\n\n- [ ] flint (has .rst files under upstream/, needs integration check)\n- [ ] gap (core GAP docs)\n- [x] Replace `NormalFormIntMat(...)` and `Decomposition(...)` placeholder signatures in GAP core reference and checklist with source-backed typed signatures — `NormalFormIntMat(mat, options)` with full bitmask contract and record-return shape; `Decomposition(A, B, depth)` with cyclotomic-matrix rank constraint and `\"nonnegative\"` depth variant — sourced from local upstream `docs/gap/upstream/matint.gd` §NormalFormIntMat and `docs/gap/upstream/chap25.html` §25.4-1.\n\n- [ ] ntl (has .txt/.cpp.html files under upstream/, needs integration check)\n- [ ] fpylll (partial docs)\n- [ ] forms (partial docs)\n- [ ] g6k (partial docs)\n- [ ] crystallographic_stack (partial docs)\n- [ ] pari_gp (partial docs)\n\nAlready addressed:\n- [x] hypercells (has full chapter snapshots under upstream/)\n- [x] flatter (has README and example profiles under upstream/)"
  },
  "isError": false
}
thinking
Let me understand the current state:

1. The project is a documentation coverage audit for bilinear-form lattice methods
2. There are memories for various documentation tasks already completed
3. The TODO.md shows that Goal 1 (package surface maintenance) and Goal 2 (contract fidelity) have been largely completed

Looking at the prompt, I'm supposed to:
1. First Goal: Check for missing in-scope package surfaces (green-fielding largely complete)
2. Second Goal: Focus on completeness and provable correctness of documented methods - this is the active emphasis

Let me check what's still outstanding in the TODO and look at recent memories to understand what work remains.
tool serena.list_memories({})
serena.list_memories({}) success in 59ms:
{
  "content": [
    {
      "type": "text",
      "text": "[\"doc_coverage_audit_2026-02-18_gap_umbrella_polyhedral_archive\", \"doc_coverage_audit_2026-02-18_julia_isometry_map_return_contracts\", \"doc_coverage_audit_2026-02-17_crystallographic_toric_checklist_surfaces\", \"doc_coverage_audit_2026-02-18_torquadmodule_submodule_signatures_and_constructor_type_union\", \"doc_coverage_audit_2026-02-18_julia_genus_constructor_signature_fidelity\", \"doc_coverage_audit_2026-02-18_sage_is_genus_odd_contract_fidelity\", \"doc_coverage_audit_2026-02-18_fpylll_signature_fidelity_and_archive_scaffold\", \"doc_coverage_audit_2026-02-17_group_action_overloads_round3\", \"doc_coverage_audit_2026-02-17_palp_checklist_surface\", \"doc_coverage_audit_2026-02-18_crystallographic_signature_fidelity_round2\", \"doc_coverage_audit_2026-02-18_zzlatwithisom_order_contract_fidelity\", \"doc_coverage_audit_2026-02-17_minor_julia_package_signature_closure\", \"doc_coverage_audit_2026-02-18_fpylll_bkz_placeholder_signature_fidelity\", \"doc_coverage_audit_2026-02-18_torquadmodwithisom_submodules_signature_fidelity\", \"doc_coverage_audit_2026-02-18_gap_umbrella_crystallographic_signature_reconcile\", \"doc_coverage_audit_2026-02-18_polyhedral_scope_migration_completion\", \"project_overview\", \"doc_coverage_audit_2026-02-18_cddlib_cddinterface_archive_migration\", \"doc_coverage_audit_2026-02-17_topcom_checklist_surface\", \"doc_coverage_audit_2026-02-17_isom_signatures_round2\", \"doc_coverage_audit_2026-02-17_cddlib_pycddlib_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_hypercells_checklist_surface\", \"doc_coverage_audit_2026-02-17_lrslib_polymake_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_4ti2_normaliz_checklist_surfaces\", \"doc_coverage_audit_2026-02-18_sage_toric_archive_scope_cleanup\", \"doc_coverage_audit_2026-02-17_cdd_nconvex_checklist_surfaces\", \"style_and_conventions\", \"doc_coverage_audit_2026-02-17_isom_contracts\", \"doc_coverage_audit_2026-02-18_automorphism_group_definiteness_contract_fidelity\", \"doc_coverage_audit_2026-02-18_pycddlib_archive_and_sage_is_genus_contract\", \"doc_coverage_audit_2026-02-17_nconvex_method_inventory_closure\", \"doc_coverage_audit_2026-02-17_fingrpact_stabilizer_signature_fidelity\", \"doc_coverage_audit_2026-02-18_torquadmodwithisom_submodules_quotype_drift\", \"codex_serena_smoketest\", \"test_coverage_alignment_2026-02-18_checklist_tags_round1\", \"suggested_commands\", \"doc_coverage_audit_2026-02-17_ntl_flint_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_forms_checklist_surface\", \"doc_coverage_audit_2026-02-18_gap_normalformintmat_decomposition_signature_fidelity\", \"doc_coverage_audit_2026-02-18_sage_orthogonal_group_definiteness_contract_fidelity\", \"doc_coverage_audit_2026-02-18_kernel_lattice_signatures_and_image_centralizer_even_constraint\", \"doc_coverage_audit_2026-02-17_g6k_flatter_latte_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_pari_gp_signature_surface_closure\", \"doc_coverage_audit_2026-02-17_missing_package_checklist_surfaces\", \"task_completion\", \"doc_coverage_audit_2026-02-17_pycddlib_checklist_surface\", \"doc_coverage_audit_2026-02-17_package_surface_expansion_fplll_julia\", \"doc_coverage_audit_2026-02-18_crystallographic_selector_domain_closure\"]"
    }
  ],
  "structuredContent": {
    "result": "[\"doc_coverage_audit_2026-02-18_gap_umbrella_polyhedral_archive\", \"doc_coverage_audit_2026-02-18_julia_isometry_map_return_contracts\", \"doc_coverage_audit_2026-02-17_crystallographic_toric_checklist_surfaces\", \"doc_coverage_audit_2026-02-18_torquadmodule_submodule_signatures_and_constructor_type_union\", \"doc_coverage_audit_2026-02-18_julia_genus_constructor_signature_fidelity\", \"doc_coverage_audit_2026-02-18_sage_is_genus_odd_contract_fidelity\", \"doc_coverage_audit_2026-02-18_fpylll_signature_fidelity_and_archive_scaffold\", \"doc_coverage_audit_2026-02-17_group_action_overloads_round3\", \"doc_coverage_audit_2026-02-17_palp_checklist_surface\", \"doc_coverage_audit_2026-02-18_crystallographic_signature_fidelity_round2\", \"doc_coverage_audit_2026-02-18_zzlatwithisom_order_contract_fidelity\", \"doc_coverage_audit_2026-02-17_minor_julia_package_signature_closure\", \"doc_coverage_audit_2026-02-18_fpylll_bkz_placeholder_signature_fidelity\", \"doc_coverage_audit_2026-02-18_torquadmodwithisom_submodules_signature_fidelity\", \"doc_coverage_audit_2026-02-18_gap_umbrella_crystallographic_signature_reconcile\", \"doc_coverage_audit_2026-02-18_polyhedral_scope_migration_completion\", \"project_overview\", \"doc_coverage_audit_2026-02-18_cddlib_cddinterface_archive_migration\", \"doc_coverage_audit_2026-02-17_topcom_checklist_surface\", \"doc_coverage_audit_2026-02-17_isom_signatures_round2\", \"doc_coverage_audit_2026-02-17_cddlib_pycddlib_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_hypercells_checklist_surface\", \"doc_coverage_audit_2026-02-17_lrslib_polymake_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_4ti2_normaliz_checklist_surfaces\", \"doc_coverage_audit_2026-02-18_sage_toric_archive_scope_cleanup\", \"doc_coverage_audit_2026-02-17_cdd_nconvex_checklist_surfaces\", \"style_and_conventions\", \"doc_coverage_audit_2026-02-17_isom_contracts\", \"doc_coverage_audit_2026-02-18_automorphism_group_definiteness_contract_fidelity\", \"doc_coverage_audit_2026-02-18_pycddlib_archive_and_sage_is_genus_contract\", \"doc_coverage_audit_2026-02-17_nconvex_method_inventory_closure\", \"doc_coverage_audit_2026-02-17_fingrpact_stabilizer_signature_fidelity\", \"doc_coverage_audit_2026-02-18_torquadmodwithisom_submodules_quotype_drift\", \"codex_serena_smoketest\", \"test_coverage_alignment_2026-02-18_checklist_tags_round1\", \"suggested_commands\", \"doc_coverage_audit_2026-02-17_ntl_flint_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_forms_checklist_surface\", \"doc_coverage_audit_2026-02-18_gap_normalformintmat_decomposition_signature_fidelity\", \"doc_coverage_audit_2026-02-18_sage_orthogonal_group_definiteness_contract_fidelity\", \"doc_coverage_audit_2026-02-18_kernel_lattice_signatures_and_image_centralizer_even_constraint\", \"doc_coverage_audit_2026-02-17_g6k_flatter_latte_checklist_surfaces\", \"doc_coverage_audit_2026-02-17_pari_gp_signature_surface_closure\", \"doc_coverage_audit_2026-02-17_missing_package_checklist_surfaces\", \"task_completion\", \"doc_coverage_audit_2026-02-17_pycddlib_checklist_surface\", \"doc_coverage_audit_2026-02-17_package_surface_expansion_fplll_julia\", \"doc_coverage_audit_2026-02-18_crystallographic_selector_domain_closure\"]"
  },
  "isError": false
}
thinking
Let me review the most recent memory files to understand the current state of the documentation work. I'll also check the TODO list for any remaining open items that might need work.

Looking at the TODO, it seems quite complete - most Goal 1 and Goal 2 items are checked off. Let me check for any remaining open items and understand what's left to do. I should also look at a few recent memory files to see what was recently worked on.
tool serena.read_memory({"memory_file_name":"doc_coverage_audit_2026-02-18_sage_orthogonal_group_definiteness_contract_fidelity"})
serena.read_memory({"memory_file_name":"doc_coverage_audit_2026-02-18_sage_orthogonal_group_definiteness_contract_fidelity"}) success in 99ms:
{
  "content": [
    {
      "type": "text",
      "text": "# Doc Coverage Audit Handoff (2026-02-18): Sage `IntegralLattice.orthogonal_group` definiteness constraint\n\n## Objectives covered\n- FIRST GOAL (cursory package-surface maintenance): reviewed current checklist inventory and prior handoff memories; no clear new in-scope bilinear-form lattice package surface requiring a new checklist was identified in this pass.\n- SECOND GOAL (active phase focus): corrected a source-backed contract-fidelity error in the Sage `IntegralLattice.orthogonal_group` definiteness constraint.\n\n## The error\n- Previous documentation tagged `IntegralLattice.orthogonal_group(gens=None, is_finite=None)` as `[PD]` (positive definite only) in three separate locations.\n- Upstream local snapshot (`free_quadratic_module_integer_symmetric.html`) explicitly demonstrates that **negative definite** lattices (e.g. `IntegralLattice(-Matrix(ZZ, 2, [2,1,1,2]))`) work with `orthogonal_group()` and return a correct group.\n- Only **indefinite** lattices raise `NotImplementedError: currently, we can only compute generators for orthogonal groups over definite lattices.`\n- Therefore the correct constraint is `[DEFINITE]` (positive or negative definite), not `[PD]`.\n\n## Completed edits\n1. `docs/sage/integral_lattice/sage_integral_lattice_reference.md`\n   - Method table: `[PD]` → `[DEFINITE]` for both `orthogonal_group` and `automorphisms` alias.\n   - Caveat text: \"requires positive definite lattice\" → \"requires a **definite** lattice (positive definite or negative definite); indefinite forms raise `NotImplementedError`\".\n   - Definiteness summary table: ND row now lists `orthogonal_group (automatic)` as available; INDEF row updated to note the `NotImplementedError`.\n\n2. `docs/sage/lattice/sagemath_lattice_reference.md`\n   - Method table §3 Symmetry: `[PD only — indefinite not yet implemented]` → `[DEFINITE — indefinite raises NotImplementedError]`; alias row `[PD only]` → `[DEFINITE]`.\n   - Pitfalls §13: \"requires positive definite\" → \"requires a **definite** lattice (positive or negative definite)\" in two separate bullet points.\n\n3. `docs/TODO.md`\n   - Added and checked off Goal 2 contract-fidelity item for this pass.\n\n## Source evidence\n- Local upstream snapshot: `docs/sage/integral_lattice/upstream/free_quadratic_module_integer_symmetric.html`\n  - Section `orthogonal_group`: example with `A2m = IntegralLattice(-Matrix(ZZ, 2, [2,1,1,2]))` → `A2m.orthogonal_group()` returns group of order 12 (succeeds).\n  - Section `orthogonal_group`: example with `U = IntegralLattice(Matrix(ZZ, 2, [0,1,1,0]))` → `U.orthogonal_group()` raises `NotImplementedError: currently, we can only compute generators for orthogonal groups over definite lattices.`\n\n## Commit\n- `08c2e42` — docs: correct IntegralLattice.orthogonal_group definiteness constraint from [PD] to [DEFINITE]\n\n## Validation\n- Documentation-only pass; no runtime tests executed.\n\n## Intentional non-edits\n- Did not modify unrelated pre-existing dirty files:\n  - `README.md`, `docs/documentation_coverage_audit_playbook.md`, `prompt.md`, `scripts/doc_coverage_scheduler.py`\n  - untracked `.serena/`, `scripts/__pycache__/`\n\n## Remaining high-impact gaps\n1. Sage checklist has many unchecked `IntegralLattice` methods: `IntegralLattice(data, basis=None)`, `IntegralLatticeDirectSum`, `IntegralLatticeGluing`, `orthogonal_group`, `genus()`, `local_modification`, `twist`, `is_primitive`, `direct_sum`, `quadratic_form` — all undocumented with `method:` tagged tests.\n2. Julia §2.3 Construction, §2.4 Intrinsic data, §2.8 Automorphism/isometry, §2.9 Module operations, §2.14 most accessors/attributes/operations remain entirely unchecked.\n3. Missing local doc copies still open in TODO.md (flint, gap, ntl, fpylll, forms, g6k, crystallographic_stack, pari_gp).\n"
    }
  ],
  "structuredContent": {
    "result": "# Doc Coverage Audit Handoff (2026-02-18): Sage `IntegralLattice.orthogonal_group` definiteness constraint\n\n## Objectives covered\n- FIRST GOAL (cursory package-surface maintenance): reviewed current checklist inventory and prior handoff memories; no clear new in-scope bilinear-form lattice package surface requiring a new checklist was identified in this pass.\n- SECOND GOAL (active phase focus): corrected a source-backed contract-fidelity error in the Sage `IntegralLattice.orthogonal_group` definiteness constraint.\n\n## The error\n- Previous documentation tagged `IntegralLattice.orthogonal_group(gens=None, is_finite=None)` as `[PD]` (positive definite only) in three separate locations.\n- Upstream local snapshot (`free_quadratic_module_integer_symmetric.html`) explicitly demonstrates that **negative definite** lattices (e.g. `IntegralLattice(-Matrix(ZZ, 2, [2,1,1,2]))`) work with `orthogonal_group()` and return a correct group.\n- Only **indefinite** lattices raise `NotImplementedError: currently, we can only compute generators for orthogonal groups over definite lattices.`\n- Therefore the correct constraint is `[DEFINITE]` (positive or negative definite), not `[PD]`.\n\n## Completed edits\n1. `docs/sage/integral_lattice/sage_integral_lattice_reference.md`\n   - Method table: `[PD]` → `[DEFINITE]` for both `orthogonal_group` and `automorphisms` alias.\n   - Caveat text: \"requires positive definite lattice\" → \"requires a **definite** lattice (positive definite or negative definite); indefinite forms raise `NotImplementedError`\".\n   - Definiteness summary table: ND row now lists `orthogonal_group (automatic)` as available; INDEF row updated to note the `NotImplementedError`.\n\n2. `docs/sage/lattice/sagemath_lattice_reference.md`\n   - Method table §3 Symmetry: `[PD only — indefinite not yet implemented]` → `[DEFINITE — indefinite raises NotImplementedError]`; alias row `[PD only]` → `[DEFINITE]`.\n   - Pitfalls §13: \"requires positive definite\" → \"requires a **definite** lattice (positive or negative definite)\" in two separate bullet points.\n\n3. `docs/TODO.md`\n   - Added and checked off Goal 2 contract-fidelity item for this pass.\n\n## Source evidence\n- Local upstream snapshot: `docs/sage/integral_lattice/upstream/free_quadratic_module_integer_symmetric.html`\n  - Section `orthogonal_group`: example with `A2m = IntegralLattice(-Matrix(ZZ, 2, [2,1,1,2]))` → `A2m.orthogonal_group()` returns group of order 12 (succeeds).\n  - Section `orthogonal_group`: example with `U = IntegralLattice(Matrix(ZZ, 2, [0,1,1,0]))` → `U.orthogonal_group()` raises `NotImplementedError: currently, we can only compute generators for orthogonal groups over definite lattices.`\n\n## Commit\n- `08c2e42` — docs: correct IntegralLattice.orthogonal_group definiteness constraint from [PD] to [DEFINITE]\n\n## Validation\n- Documentation-only pass; no runtime tests executed.\n\n## Intentional non-edits\n- Did not modify unrelated pre-existing dirty files:\n  - `README.md`, `docs/documentation_coverage_audit_playbook.md`, `prompt.md`, `scripts/doc_coverage_scheduler.py`\n  - untracked `.serena/`, `scripts/__pycache__/`\n\n## Remaining high-impact gaps\n1. Sage checklist has many unchecked `IntegralLattice` methods: `IntegralLattice(data, basis=None)`, `IntegralLatticeDirectSum`, `IntegralLatticeGluing`, `orthogonal_group`, `genus()`, `local_modification`, `twist`, `is_primitive`, `direct_sum`, `quadratic_form` — all undocumented with `method:` tagged tests.\n2. Julia §2.3 Construction, §2.4 Intrinsic data, §2.8 Automorphism/isometry, §2.9 Module operations, §2.14 most accessors/attributes/operations remain entirely unchecked.\n3. Missing local doc copies still open in TODO.md (flint, gap, ntl, fpylll, forms, g6k, crystallographic_stack, pari_gp).\n"
  },
  "isError": false
}
tool serena.read_memory({"memory_file_name":"doc_coverage_audit_2026-02-18_automorphism_group_definiteness_contract_fidelity"})
serena.read_memory({"memory_file_name":"doc_coverage_audit_2026-02-18_automorphism_group_definiteness_contract_fidelity"}) success in 107ms:
{
  "content": [
    {
      "type": "text",
      "text": "# Doc Coverage Audit Handoff (2026-02-18): `automorphism_group_generators` / `automorphism_group_order` definiteness constraint\n\n## Objectives covered\n- FIRST GOAL (cursory package-surface maintenance): no new in-scope bilinear-form lattice package surface gap identified.\n- SECOND GOAL (active phase focus): corrected a source-backed contract-fidelity error in the OSCAR/Hecke `automorphism_group_generators` and `automorphism_group_order` definiteness constraints.\n\n## The error\n- Previous documentation tagged both `automorphism_group_generators(L)` and `automorphism_group_order(L)` as `[PD]` (positive definite only) in three separate locations.\n- Upstream OSCAR/Hecke stable docs (`https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`) explicitly state \"Given a **definite** lattice `L`\" for both functions.\n- \"Definite\" encompasses both positive definite AND negative definite lattices; only indefinite lattices are excluded.\n- Therefore the correct constraint is `[DEFINITE]` (positive or negative definite), not `[PD]`.\n\n## Additional improvement\n- Added the previously undocumented `ambient_representation::Bool=true` keyword argument to `automorphism_group_generators`, per the upstream typed signature: `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)`.\n- Also added typed signatures with `depth::Int=-1` and `bacher_depth::Int=0` kwargs to `automorphism_group_order`.\n\n## Completed edits\n1. `docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md` (§2.8)\n   - Method table: `[PD, GAP]` → `[DEFINITE, GAP]` for `automorphism_group_generators`; full typed signature added.\n   - Method table: `[PD]` → `[DEFINITE]` for `automorphism_group_order`; full typed signature added.\n   - Bullet note updated: \"PD: finite groups...\" → \"DEFINITE (PD or ND): both positive and negative definite lattices supported...\"\n\n2. `docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md` (§2.7)\n   - Method table: `[PD, GAP, NT]` → `[DEFINITE, GAP, NT]` for `automorphism_group_generators`; full typed signature added.\n   - Method table: `[PD, NT]` → `[DEFINITE, NT]` for `automorphism_group_order`; full typed signature added.\n   - Added \"Definite note\" paragraph clarifying the upstream `is_definite(L)` requirement vs `is_positive_definite(L)`.\n\n3. `docs/julia_methods_checklist.md` (§2.8)\n   - Both entries updated with typed signatures and explicit `[DEFINITE]` caveats.\n\n4. `docs/TODO.md`\n   - Added and checked off Goal 2 contract-fidelity item for this pass.\n\n## Source evidence\n- `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`\n  - `automorphism_group_generators`: \"Given a **definite** lattice `L`, return generators for the automorphism group of `L`.\"\n  - `automorphism_group_order`: \"Given a **definite** lattice `L`, return the order of the automorphism group of `L`.\"\n  - Full typed signature: `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)`\n\n## Commit\n- `b4936ad` — docs: correct automorphism_group_generators/order definiteness constraint from [PD] to [DEFINITE]\n\n## Validation\n- Documentation-only pass; no runtime tests executed.\n\n## Intentional non-edits\n- Did not modify unrelated pre-existing dirty files (agent_runner logs, etc.)\n\n## Pattern note\n- This is the **second** instance of the same `[PD]` vs `[DEFINITE]` error pattern in this project:\n  - Pass 1: Sage `IntegralLattice.orthogonal_group` — `[PD]` → `[DEFINITE]` (commit `08c2e42`)\n  - Pass 2: Julia/OSCAR `automorphism_group_generators` / `automorphism_group_order` — `[PD]` → `[DEFINITE]` (commit `b4936ad`)\n- Future workers should check other `[PD]`-tagged methods where the upstream may actually say \"definite\" (not \"positive definite\").\n\n## Remaining high-impact gaps\n1. §2.8 `is_isometric(L1, L2)` — tagged `[PD]` but no explicit definiteness restriction stated in upstream docstring; may warrant a review.\n2. §2.8 `is_isometric_with_isometry(L1, L2)` — not confirmed in current upstream docs but documented with a return contract; status should be reviewed.\n3. §2.3, §2.4, §2.9: most entries unchecked (no method-tagged tests).\n4. §2.14 Construction/accessor/attribute/operations blocks: almost entirely unchecked.\n5. Missing local doc copies for flint, gap, ntl, fpylll, forms, g6k, crystallographic_stack, pari_gp.\n"
    }
  ],
  "structuredContent": {
    "result": "# Doc Coverage Audit Handoff (2026-02-18): `automorphism_group_generators` / `automorphism_group_order` definiteness constraint\n\n## Objectives covered\n- FIRST GOAL (cursory package-surface maintenance): no new in-scope bilinear-form lattice package surface gap identified.\n- SECOND GOAL (active phase focus): corrected a source-backed contract-fidelity error in the OSCAR/Hecke `automorphism_group_generators` and `automorphism_group_order` definiteness constraints.\n\n## The error\n- Previous documentation tagged both `automorphism_group_generators(L)` and `automorphism_group_order(L)` as `[PD]` (positive definite only) in three separate locations.\n- Upstream OSCAR/Hecke stable docs (`https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`) explicitly state \"Given a **definite** lattice `L`\" for both functions.\n- \"Definite\" encompasses both positive definite AND negative definite lattices; only indefinite lattices are excluded.\n- Therefore the correct constraint is `[DEFINITE]` (positive or negative definite), not `[PD]`.\n\n## Additional improvement\n- Added the previously undocumented `ambient_representation::Bool=true` keyword argument to `automorphism_group_generators`, per the upstream typed signature: `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)`.\n- Also added typed signatures with `depth::Int=-1` and `bacher_depth::Int=0` kwargs to `automorphism_group_order`.\n\n## Completed edits\n1. `docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md` (§2.8)\n   - Method table: `[PD, GAP]` → `[DEFINITE, GAP]` for `automorphism_group_generators`; full typed signature added.\n   - Method table: `[PD]` → `[DEFINITE]` for `automorphism_group_order`; full typed signature added.\n   - Bullet note updated: \"PD: finite groups...\" → \"DEFINITE (PD or ND): both positive and negative definite lattices supported...\"\n\n2. `docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md` (§2.7)\n   - Method table: `[PD, GAP, NT]` → `[DEFINITE, GAP, NT]` for `automorphism_group_generators`; full typed signature added.\n   - Method table: `[PD, NT]` → `[DEFINITE, NT]` for `automorphism_group_order`; full typed signature added.\n   - Added \"Definite note\" paragraph clarifying the upstream `is_definite(L)` requirement vs `is_positive_definite(L)`.\n\n3. `docs/julia_methods_checklist.md` (§2.8)\n   - Both entries updated with typed signatures and explicit `[DEFINITE]` caveats.\n\n4. `docs/TODO.md`\n   - Added and checked off Goal 2 contract-fidelity item for this pass.\n\n## Source evidence\n- `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`\n  - `automorphism_group_generators`: \"Given a **definite** lattice `L`, return generators for the automorphism group of `L`.\"\n  - `automorphism_group_order`: \"Given a **definite** lattice `L`, return the order of the automorphism group of `L`.\"\n  - Full typed signature: `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)`\n\n## Commit\n- `b4936ad` — docs: correct automorphism_group_generators/order definiteness constraint from [PD] to [DEFINITE]\n\n## Validation\n- Documentation-only pass; no runtime tests executed.\n\n## Intentional non-edits\n- Did not modify unrelated pre-existing dirty files (agent_runner logs, etc.)\n\n## Pattern note\n- This is the **second** instance of the same `[PD]` vs `[DEFINITE]` error pattern in this project:\n  - Pass 1: Sage `IntegralLattice.orthogonal_group` — `[PD]` → `[DEFINITE]` (commit `08c2e42`)\n  - Pass 2: Julia/OSCAR `automorphism_group_generators` / `automorphism_group_order` — `[PD]` → `[DEFINITE]` (commit `b4936ad`)\n- Future workers should check other `[PD]`-tagged methods where the upstream may actually say \"definite\" (not \"positive definite\").\n\n## Remaining high-impact gaps\n1. §2.8 `is_isometric(L1, L2)` — tagged `[PD]` but no explicit definiteness restriction stated in upstream docstring; may warrant a review.\n2. §2.8 `is_isometric_with_isometry(L1, L2)` — not confirmed in current upstream docs but documented with a return contract; status should be reviewed.\n3. §2.3, §2.4, §2.9: most entries unchecked (no method-tagged tests).\n4. §2.14 Construction/accessor/attribute/operations blocks: almost entirely unchecked.\n5. Missing local doc copies for flint, gap, ntl, fpylll, forms, g6k, crystallographic_stack, pari_gp.\n"
  },
  "isError": false
}
thinking
The user wants me to continue the documentation coverage audit work. Based on the context:

1. This is the documentation coverage worker for the lattice_interface project
2. The project tracks bilinear-form lattice methods (free R-modules with symmetric nondegenerate bilinear forms)
3. FIRST GOAL is cursory package-surface maintenance (largely complete)
4. SECOND GOAL is the active focus - completeness and provable correctness of documented methods

From the memories and TODO, I can see recent work has been done on:
- Sage orthogonal_group definiteness (PD → DEFINITE)
- Julia automorphism_group_generators/order definiteness (PD → DEFINITE)
- Various other contract fidelity items

The TODO shows the current open items:
- Missing Local Doc Copies (flint, gap, ntl, fpylll, forms, g6k, crystallographic_stack, pari_gp)

Looking at the playbook, it says:
- FIRST GOAL is cursory maintenance check - largely complete per the checkmark in TODO
- SECOND GOAL is active emphasis - prioritize deepening correctness/completeness of existing in-scope surfaces

The remaining gaps in the handoff memories mention:
1. Many unchecked Sage IntegralLattice methods
2. Julia sections unchecked
3. Missing local doc copies

Let me also check the recent memory files to see what's been done recently and what needs to be done next. I should look at a recent memory to understand the current state and find an open contract fidelity item to work on.
tool serena.read_memory({"memory_file_name":"doc_coverage_audit_2026-02-18_zzlatwithisom_order_contract_fidelity"})
serena.read_memory({"memory_file_name":"doc_coverage_audit_2026-02-18_zzlatwithisom_order_contract_fidelity"}) success in 61ms:
{
  "content": [
    {
      "type": "text",
      "text": "# Doc Coverage Audit Handoff (2026-02-18): `ZZLatWithIsom.order_of_isometry` contract fidelity\n\n## FIRST GOAL (cursory package-surface maintenance)\n- Re-ran a brief in-scope package-surface maintenance check against the current checklist inventory and upstream living-map scope.\n- No clear new in-scope bilinear-form lattice package checklist gap was identified in this pass.\n\n## SECOND GOAL (active phase focus)\n- Tightened method-contract precision for `order_of_isometry(Lf)` on Julia/Oscar + Hecke mirror surfaces.\n- Removed vague wording and replaced with source-backed contract from local `latwithisom` snapshot:\n  - `ZZLatWithIsom` is modeled as `(Vf, L, f, n)` with `n` equal to the order of `f`,\n  - `n` is documented as a divisor of the ambient isometry order,\n  - finite- and infinite-order isometries are both supported.\n\n## Completed edits\n1. `docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md`\n- Updated `order_of_isometry(Lf)` description to explicit divisor/support contract.\n\n2. `docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md`\n- Updated `order_of_isometry(Lf)` description to explicit divisor/support contract.\n\n3. `docs/julia_methods_checklist.md`\n- Added caveat under `order_of_isometry(Lf)` documenting divisor relation and finite/infinite support.\n\n4. `docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md`\n- Added `Pass-21 addendum (2026-02-18)` capturing evidence and alignment actions.\n\n5. `docs/TODO.md`\n- Added and checked off:\n  - Goal 1 maintenance re-check note (no new in-scope package gap found),\n  - Goal 2 contract-fidelity item for `ZZLatWithIsom.order_of_isometry` wording.\n\n## Commit\n- `d2878ff` — docs: tighten ZZLatWithIsom order contract wording\n\n## Validation\n- Documentation-only pass; no runtime tests run.\n\n## Intentional non-edits\n- Left unrelated dirty files untouched (`README.md`, `docs/documentation_coverage_audit_playbook.md`, `prompt.md`, `scripts/doc_coverage_scheduler.py`, untracked `.serena/`, `scripts/__pycache__/`).\n\n## Remaining high-impact gaps\n1. Continue Goal 2 contract-fidelity tightening for Julia `fingrpact` stabilizer-family methods that still appear as runtime-name placeholders where typed dispatch is not surfaced.\n2. Proceed with queued out-of-scope archive migration items in `docs/TODO.md` once in-scope contract-fidelity priorities are considered sufficiently covered for the run."
    }
  ],
  "structuredContent": {
    "result": "# Doc Coverage Audit Handoff (2026-02-18): `ZZLatWithIsom.order_of_isometry` contract fidelity\n\n## FIRST GOAL (cursory package-surface maintenance)\n- Re-ran a brief in-scope package-surface maintenance check against the current checklist inventory and upstream living-map scope.\n- No clear new in-scope bilinear-form lattice package checklist gap was identified in this pass.\n\n## SECOND GOAL (active phase focus)\n- Tightened method-contract precision for `order_of_isometry(Lf)` on Julia/Oscar + Hecke mirror surfaces.\n- Removed vague wording and replaced with source-backed contract from local `latwithisom` snapshot:\n  - `ZZLatWithIsom` is modeled as `(Vf, L, f, n)` with `n` equal to the order of `f`,\n  - `n` is documented as a divisor of the ambient isometry order,\n  - finite- and infinite-order isometries are both supported.\n\n## Completed edits\n1. `docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md`\n- Updated `order_of_isometry(Lf)` description to explicit divisor/support contract.\n\n2. `docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md`\n- Updated `order_of_isometry(Lf)` description to explicit divisor/support contract.\n\n3. `docs/julia_methods_checklist.md`\n- Added caveat under `order_of_isometry(Lf)` documenting divisor relation and finite/infinite support.\n\n4. `docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md`\n- Added `Pass-21 addendum (2026-02-18)` capturing evidence and alignment actions.\n\n5. `docs/TODO.md`\n- Added and checked off:\n  - Goal 1 maintenance re-check note (no new in-scope package gap found),\n  - Goal 2 contract-fidelity item for `ZZLatWithIsom.order_of_isometry` wording.\n\n## Commit\n- `d2878ff` — docs: tighten ZZLatWithIsom order contract wording\n\n## Validation\n- Documentation-only pass; no runtime tests run.\n\n## Intentional non-edits\n- Left unrelated dirty files untouched (`README.md`, `docs/documentation_coverage_audit_playbook.md`, `prompt.md`, `scripts/doc_coverage_scheduler.py`, untracked `.serena/`, `scripts/__pycache__/`).\n\n## Remaining high-impact gaps\n1. Continue Goal 2 contract-fidelity tightening for Julia `fingrpact` stabilizer-family methods that still appear as runtime-name placeholders where typed dispatch is not surfaced.\n2. Proceed with queued out-of-scope archive migration items in `docs/TODO.md` once in-scope contract-fidelity priorities are considered sufficiently covered for the run."
  },
  "isError": false
}
thinking
The user is asking me to work on documentation coverage for the lattice_interface project. Based on the context, I'm a documentation worker bringing project documentation into alignment with what the project is supposed to be - covering bilinear-form lattice methods.

The instructions say:
1. FIRST GOAL: Cursory maintenance check for missing in-scope package surfaces
2. SECOND GOAL: Completeness and provable correctness of all documented methods
3. MINOR GOAL: Only after first two goals are satisfied - precision/clarity refinement

Looking at the TODO.md and memories, it seems most of the Goal 2 work has been completed. The memories show many "contract fidelity" items have been addressed - things like definiteness constraints, method signatures, etc.

Let me check what outstanding work remains. Looking at TODO.md:
- Goal 1 is marked complete (no new bilinear-form lattice packages)
- Goal 2 contract fidelity items are largely complete

The remaining gaps mentioned are:
1. Various unchecked methods in Sage checklist
2. Julia sections unchecked
3. Missing local doc copies for flint, gap, ntl, fpylll, forms, g6k, crystallographic_stack, pari_gp

Given the instruction says "Goal 2 and beyond are the active emphasis for this phase" and to "prioritize deepening correctness/completeness of existing in-scope surfaces over expanding package count", I should focus on checking for any remaining contract fidelity issues or missing method coverage.

Let me check the git status to see what dirty files exist and see if there are any obvious gaps to address.
tool serena.execute_shell_command({"command":"cd /home/dzack/lattice_interface && git status"})
serena.execute_shell_command({"command":"cd /home/dzack/lattice_interface && git status"}) success in 173ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"stdout\":\"On branch main\\nYour branch is ahead of 'origin/main' by 60 commits.\\n  (use \\\"git push\\\" to publish your local commits)\\n\\nChanges not staged for commit:\\n  (use \\\"git add <file>...\\\" to update what will be committed)\\n  (use \\\"git restore <file>...\\\" to discard changes in working directory)\\n\\tmodified:   agent_runner/README.md\\n\\tmodified:   agent_runner/logs/debug_hello_simple/codex/test/last_message.txt\\n\\tmodified:   agent_runner/logs/debug_hello_simple/ollama/agent.log\\n\\tmodified:   agent_runner/logs/debug_hello_simple/task.log\\n\\tmodified:   agent_runner/logs/document_coverage/task.log\\n\\tmodified:   agent_runner/logs/heartbeat/task.log\\n\\tmodified:   agent_runner/pyproject.toml\\n\\tmodified:   agent_runner/src/agent_runner/agents.py\\n\\tmodified:   agent_runner/src/agent_runner/config.py\\n\\tmodified:   agent_runner/src/agent_runner/errors.py\\n\\tmodified:   agent_runner/src/agent_runner/notifications_cli.py\\n\\tmodified:   agent_runner/src/agent_runner/orchestrator.py\\n\\tmodified:   agent_runner/src/agent_runner/transcript.py\\n\\tmodified:   agent_runner/tests/claude/test_direct.py\\n\\tmodified:   agent_runner/tests/codex/test_direct.py\\n\\tmodified:   agent_runner/tests/gemini/test_direct.py\\n\\tmodified:   agent_runner/tests/ollama/test_direct.py\\n\\tmodified:   agent_runner/tests/test_agents_direct.py\\n\\tmodified:   agent_runner/uv.lock\\n\\nUntracked files:\\n  (use \\\"git add <file>...\\\" to include in what will be committed)\\n\\t.serena/memories/doc_coverage_audit_2026-02-18_automorphism_group_definiteness_contract_fidelity.md\\n\\t.serena/memories/doc_coverage_audit_2026-02-18_gap_normalformintmat_decomposition_signature_fidelity.md\\n\\t.serena/memories/doc_coverage_audit_2026-02-18_sage_orthogonal_group_definiteness_contract_fidelity.md\\n\\tagent_runner/logs/debug_hello_simple/claude/20260218_202953/\\n\\tagent_runner/logs/debug_hello_simple/claude/20260218_203420/\\n\\tagent_runner/logs/debug_hello_simple/claude/test/\\n\\tagent_runner/logs/debug_hello_simple/codex/test/transcript.log\\n\\tagent_runner/logs/debug_hello_simple/gemini/20260218_203036/\\n\\tagent_runner/logs/debug_hello_simple/gemini/20260218_203459/\\n\\tagent_runner/logs/debug_hello_simple/gemini/test/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260218_203106/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260218_203529/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260218_232534/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260218_233527/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260219_001632/\\n\\tagent_runner/logs/debug_hello_simple/ollama/test/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_202909/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_202921/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_202956/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_203141/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_203423/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_203606/\\n\\tagent_runner/logs/document_coverage/claude/\\n\\tagent_runner/logs/document_coverage/codex/20260218_201503/\\n\\tagent_runner/logs/document_coverage/codex/20260218_211502/\\n\\tagent_runner/logs/document_coverage/codex/20260218_221502/\\n\\tagent_runner/logs/document_coverage/codex/20260218_231504/\\n\\tagent_runner/logs/document_coverage/ollama/\\n\\tagent_runner/stubs/\\n\\tagent_runner/telemetry-id\\n\\tagent_runner/tests/kilo/\\n\\tagent_runner/tests/opencode/\\n\\tagent_runner/tests/test_env_preflight.py\\n\\ttelemetry-id\\n\\tuv.lock\\n\\nno changes added to commit (use \\\"git add\\\" and/or \\\"git commit -a\\\")\\n\",\"return_code\":0,\"cwd\":\"/home/dzack/lattice_interface\",\"stderr\":\"\"}"
    }
  ],
  "structuredContent": {
    "result": "{\"stdout\":\"On branch main\\nYour branch is ahead of 'origin/main' by 60 commits.\\n  (use \\\"git push\\\" to publish your local commits)\\n\\nChanges not staged for commit:\\n  (use \\\"git add <file>...\\\" to update what will be committed)\\n  (use \\\"git restore <file>...\\\" to discard changes in working directory)\\n\\tmodified:   agent_runner/README.md\\n\\tmodified:   agent_runner/logs/debug_hello_simple/codex/test/last_message.txt\\n\\tmodified:   agent_runner/logs/debug_hello_simple/ollama/agent.log\\n\\tmodified:   agent_runner/logs/debug_hello_simple/task.log\\n\\tmodified:   agent_runner/logs/document_coverage/task.log\\n\\tmodified:   agent_runner/logs/heartbeat/task.log\\n\\tmodified:   agent_runner/pyproject.toml\\n\\tmodified:   agent_runner/src/agent_runner/agents.py\\n\\tmodified:   agent_runner/src/agent_runner/config.py\\n\\tmodified:   agent_runner/src/agent_runner/errors.py\\n\\tmodified:   agent_runner/src/agent_runner/notifications_cli.py\\n\\tmodified:   agent_runner/src/agent_runner/orchestrator.py\\n\\tmodified:   agent_runner/src/agent_runner/transcript.py\\n\\tmodified:   agent_runner/tests/claude/test_direct.py\\n\\tmodified:   agent_runner/tests/codex/test_direct.py\\n\\tmodified:   agent_runner/tests/gemini/test_direct.py\\n\\tmodified:   agent_runner/tests/ollama/test_direct.py\\n\\tmodified:   agent_runner/tests/test_agents_direct.py\\n\\tmodified:   agent_runner/uv.lock\\n\\nUntracked files:\\n  (use \\\"git add <file>...\\\" to include in what will be committed)\\n\\t.serena/memories/doc_coverage_audit_2026-02-18_automorphism_group_definiteness_contract_fidelity.md\\n\\t.serena/memories/doc_coverage_audit_2026-02-18_gap_normalformintmat_decomposition_signature_fidelity.md\\n\\t.serena/memories/doc_coverage_audit_2026-02-18_sage_orthogonal_group_definiteness_contract_fidelity.md\\n\\tagent_runner/logs/debug_hello_simple/claude/20260218_202953/\\n\\tagent_runner/logs/debug_hello_simple/claude/20260218_203420/\\n\\tagent_runner/logs/debug_hello_simple/claude/test/\\n\\tagent_runner/logs/debug_hello_simple/codex/test/transcript.log\\n\\tagent_runner/logs/debug_hello_simple/gemini/20260218_203036/\\n\\tagent_runner/logs/debug_hello_simple/gemini/20260218_203459/\\n\\tagent_runner/logs/debug_hello_simple/gemini/test/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260218_203106/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260218_203529/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260218_232534/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260218_233527/\\n\\tagent_runner/logs/debug_hello_simple/ollama/20260219_001632/\\n\\tagent_runner/logs/debug_hello_simple/ollama/test/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_202909/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_202921/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_202956/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_203141/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_203423/\\n\\tagent_runner/logs/debug_smoke_commit/codex/20260218_203606/\\n\\tagent_runner/logs/document_coverage/claude/\\n\\tagent_runner/logs/document_coverage/codex/20260218_201503/\\n\\tagent_runner/logs/document_coverage/codex/20260218_211502/\\n\\tagent_runner/logs/document_coverage/codex/20260218_221502/\\n\\tagent_runner/logs/document_coverage/codex/20260218_231504/\\n\\tagent_runner/logs/document_coverage/ollama/\\n\\tagent_runner/stubs/\\n\\tagent_runner/telemetry-id\\n\\tagent_runner/tests/kilo/\\n\\tagent_runner/tests/opencode/\\n\\tagent_runner/tests/test_env_preflight.py\\n\\ttelemetry-id\\n\\tuv.lock\\n\\nno changes added to commit (use \\\"git add\\\" and/or \\\"git commit -a\\\")\\n\",\"return_code\":0,\"cwd\":\"/home/dzack/lattice_interface\",\"stderr\":\"\"}"
  },
  "isError": false
}
thinking
I see there's been a lot of work already done based on the memories and TODO.md. Let me look at what contract fidelity items remain based on recent handoffs and identify a specific gap to address.

From the memories I've read:
1. `automorphism_group_generators` / `automorphism_group_order` definiteness constraint - DONE
2. `ZZLatWithIsom.order_of_isometry` contract - DONE
3. `IntegralLattice.orthogonal_group` definiteness constraint - DONE

The memories mention:
- "§2.8 `is_isometric(L1, L2)` — tagged `[PD]` but no explicit definiteness restriction stated in upstream docstring; may warrant a review."
- "§2.8 `is_isometric_with_isometry(L1, L2)` — not confirmed in current upstream docs but documented with a return contract; status should be reviewed."

Let me check these items in the Julia references and see if there's a contract fidelity issue to address. I should also check what's currently checked in the TODO for Goal 2.
tool serena.search_for_pattern({"context_lines_after":3,"context_lines_before":3,"paths_include_glob":"**/*.md","relative_path":"docs/julia","substring_pattern":"is_isometric"})
serena.search_for_pattern({"context_lines_after":3,"context_lines_before":3,"paths_include_glob":"**/*.md","relative_path":"docs/julia","substring_pattern":"is_isometric"}) success in 115ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md\": [\"  >  83:  - `is_isometric_with_isometry(L, M; depth=3, bacher_depth=5, ambient_representation=true)` has explicit tuple-return contract:\", \"  >  86:  - `is_isometric_with_isometry(T, U)` / `is_anti_isometric_with_anti_isometry(T, U)` on finite quadratic modules are documented with tuple-return shape and explicit preconditions:\"], \"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md\": [\"  >  86:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global / local isometry test | |\", \"  >  86:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global / local isometry test | |\", \"  > 233:| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\", \"  > 234:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |\", \"  > 330:| `is_isometric_with_isometry(T, U)` | Isometry test returning `(Bool, map)` (or `(false, 0)` if no isometry). Upstream states the contract assumes either equal quadratic-form moduli or prior rescaling to match, plus semiregular decomposition checks on `T ⊕ U` and `T ⊕ U^{-1}` | |\"], \"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md\": [\"  >  60:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global/local isometry tests | `[NT]` |\", \"  >  60:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global/local isometry tests | `[NT]` |\", \"  > 135:| `is_isometric(L1, L2)` | Isometry test | `[PD, NT]` |\", \"  > 136:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD, NT]` |\", \"  > 182:| `is_isometric_with_isometry(T, U)` | Isometry test returning `(Bool, map)` (or `(false, 0)` if no isometry). Upstream requires either equal quadratic-form moduli (or prior rescaling) and semiregular decomposition checks on `T ⊕ U` and `T ⊕ U^{-1}` | `[NT]` |\"]}"
    }
  ],
  "structuredContent": {
    "result": "{\"docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md\": [\"  >  83:  - `is_isometric_with_isometry(L, M; depth=3, bacher_depth=5, ambient_representation=true)` has explicit tuple-return contract:\", \"  >  86:  - `is_isometric_with_isometry(T, U)` / `is_anti_isometric_with_anti_isometry(T, U)` on finite quadratic modules are documented with tuple-return shape and explicit preconditions:\"], \"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md\": [\"  >  86:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global / local isometry test | |\", \"  >  86:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global / local isometry test | |\", \"  > 233:| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\", \"  > 234:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |\", \"  > 330:| `is_isometric_with_isometry(T, U)` | Isometry test returning `(Bool, map)` (or `(false, 0)` if no isometry). Upstream states the contract assumes either equal quadratic-form moduli or prior rescaling to match, plus semiregular decomposition checks on `T ⊕ U` and `T ⊕ U^{-1}` | |\"], \"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md\": [\"  >  60:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global/local isometry tests | `[NT]` |\", \"  >  60:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global/local isometry tests | `[NT]` |\", \"  > 135:| `is_isometric(L1, L2)` | Isometry test | `[PD, NT]` |\", \"  > 136:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD, NT]` |\", \"  > 182:| `is_isometric_with_isometry(T, U)` | Isometry test returning `(Bool, map)` (or `(false, 0)` if no isometry). Upstream requires either equal quadratic-form moduli (or prior rescaling) and semiregular decomposition checks on `T ⊕ U` and `T ⊕ U^{-1}` | `[NT]` |\"]}"
  },
  "isError": false
}
thinking
Now I should check the upstream contract for `is_isometric(L1, L2)` to see whether it truly requires `[PD]` (positive definite only) or if it might actually work for definite (both PD and ND) or even indefinite lattices. Let me check the local upstream docs.
tool serena.search_for_pattern({"context_lines_after":5,"context_lines_before":3,"paths_include_glob":"*.md","relative_path":"docs/julia/oscar_jl/lattice","substring_pattern":"is_isometric.*L1.*L2"})
serena.search_for_pattern({"context_lines_after":5,"context_lines_before":3,"paths_include_glob":"*.md","relative_path":"docs/julia/oscar_jl/lattice","substring_pattern":"is_isometric.*L1.*L2"}) success in 47ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md\": [\"  >  86:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global / local isometry test | |\\n  >  87:| `is_locally_represented_by(U, V, p)` | Whether $U$ is locally represented by $V$ | |\\n  >  88:| `is_represented_by(U, V)` | Whether $U$ is globally represented by $V$ | |\\n  >  89:| `inner_product(V, v, w)` | Evaluate bilinear form | |\\n  >  90:| `orthogonal_complement(V, M)` | Orthogonal complement of subspace $M$ | |\\n  >  91:| `orthogonal_projection(V, M)` | Projection onto subspace $M$ | |\\n  >  92:| `is_isotropic(V, p)` | Local isotropy test | |\\n  >  93:| `is_locally_hyperbolic(V, p)` | Whether $V_p$ is hyperbolic (hermitian spaces) | |\\n  >  94:| `restrict_scalars(V, K, α)` | Restriction of scalars | |\\n  >  95:| `direct_sum(V, W)` / `direct_product` / `biproduct` | Categorical constructions | |\\n  >  96:\\n  >  97:### 2.3 Construction\\n  >  98:\\n  >  99:| Function | Description | Tags |\\n  > 100:|----------|-------------|------|\\n  > 101:| `integer_lattice(; gram=G)` | Integer lattice from Gram matrix | |\\n  > 102:| `integer_lattice(B; gram=G)` | Integer lattice from basis matrix $B$ and optional Gram | |\\n  > 103:| `lattice(V, B)` | Lattice in quadratic space $V$ with basis matrix $B$ | |\\n  > 104:| `quadratic_lattice(K, gens; gram=M)` | Lattice from generators + Gram matrix; `K=QQ` → `ZZLat` | `[INDEF ok]` |\\n  > 105:| `hermitian_lattice(E, gens; gram=M)` | Hermitian lattice over quadratic extension E | |\\n  > 106:| `root_lattice(:A, n)` / `(:D, n)` / `(:E, n)` / `(:I, n)` | Named root lattice | `[PD]` |\\n  > 107:| `hyperbolic_plane_lattice(n)` | Hyperbolic plane $U$ scaled by $n$ | `[INDEF]` |\\n  > 108:| `leech_lattice()` | Rank-24 Leech lattice | `[PD]` |\\n  > 109:| `k3_lattice()` | K3 surface lattice $U^3 \\\\oplus E_8(-1)^2$ | `[INDEF]` |\\n  > 110:| `mukai_lattice()` | Rank-24 Mukai lattice (K3 theory); optional extended form | `[INDEF]` |\\n  > 111:| `hyperkaehler_lattice(:K3, n=3)` | Hyperkähler intersection form (sig $(3,19)$ or similar) | `[INDEF]` |\\n  > 112:| `rescale(L, r)` | New lattice with Gram $r \\\\cdot G$; use `rescale(L, -1)` to flip sign of ND lattice | |\\n  > 113:\\n  > 114:### 2.4 Intrinsic data\\n  > 115:\\n  > 116:| Method | Description | Tags |\\n  > 117:|--------|-------------|------|\\n  > 118:| `gram_matrix(L)` | Gram matrix | |\\n  > 119:| `basis_matrix(L)` | Basis matrix | |\\n  > 120:| `ambient_space(L)` | Ambient quadratic space | |\\n  > 121:| `rational_span(L)` | Rational span as quadratic space | |\\n  > 122:| `rank(L)` | Rank | |\\n  > 123:| `degree(L)` | Degree (ambient dimension) | |\\n  > 124:| `signature_tuple(L)` | $(n_{+}, n_{0}, n_{-})$ (positive, zero, negative counts) | `[INDEF ok]` |\\n  > 125:| `det(L)` | Determinant of Gram | |\\n  > 126:| `discriminant(L)` | Discriminant | |\\n  > 127:| `scale(L)` | Scale ideal (generated by $b(x,y)$ for all $x,y \\\\in L$) | |\\n  > 128:| `norm(L)` | Norm ideal (generated by $q(x)$ for all $x \\\\in L$) | |\\n  > 129:| `is_positive_definite(L)` | | `[PD]` |\\n  > 130:| `is_negative_definite(L)` | | |\\n  > 131:| `is_definite(L)` | PD or ND | |\\n  > 132:| `is_even(L)` | All $(x,x) \\\\in 2\\\\mathbb{Z}$ | |\\n  > 133:| `is_integral(L)` | All $b(x,y) \\\\in \\\\mathbb{Z}$ | |\\n  > 134:| `is_unimodular(L)` | $|\\\\det G| = 1$ | |\\n  > 135:| `is_primary(L, p)` | $L^\\\\vee/L$ is a $p$-group | |\\n  > 136:| `is_primary_with_prime(L)` | Returns `(true, p)` if primary | |\\n  > 137:| `is_elementary(L, p)` | $L^\\\\vee/L \\\\cong (\\\\mathbb{Z}/p)^k$ | |\\n  > 138:| `is_elementary_with_prime(L)` | Returns `(true, p)` if elementary | |\\n  > 139:\\n  > 140:### 2.5 Reduction\\n  > 141:\\n  > 142:| Method | Description | Tags |\\n  > 143:|--------|-------------|------|\\n  > 144:| `lll(L::ZZLat; same_ambient::Bool=true, redo::Bool=false, ctx::LLLContext=...)` | LLL-reduced basis; returns new lattice; `redo=true` forces recomputation even if cached; `ctx` specifies Lovász parameters | `[INDEF ok, FLINT]` |\\n  > 145:\\n  > 146:- PD: specify Lovász parameters via `LLLContext(δ, η)` passed as `ctx`\\n  > 147:- INDEF: runs but \\\"shorter\\\" is w.r.t. a majorant, not the indefinite form itself\\n  > 148:\\n  > 149:### 2.6 Vector enumeration\\n  > 150:\\n  > 151:| Method | Description | Tags |\\n  > 152:|--------|-------------|------|\\n  > 153:| `short_vectors(L, lb, ub)` | Nonzero vectors with $lb \\\\le \\\\|v\\\\|^2 \\\\le ub$ (up to sign) | `[PD]` |\\n  > 154:| `short_vectors_iterator(L, lb, ub)` | Lazy iterator version of `short_vectors` | `[PD]` |\\n  > 155:| `shortest_vectors(L)` | Shortest vectors and their squared norm | `[PD]` |\\n  > 156:| `close_vectors(L::ZZLat, v::Vector, [lb,] ub; check::Bool=false)` | Returns `Vector{Tuple{Vector{Int}, QQFieldElem}}` — lattice points $x$ with $b(v-x, v-x) \\\\le ub$; Fincke–Pohst enumeration; **`check` defaults to `false`** (not `true`) | `[PD]` |\\n  > 157:| `short_vectors_affine(S, v, α, d)` | Vectors $x \\\\in S$ with $x^2 = d$ and $x \\\\cdot v = \\\\alpha$ (Vinberg) | `[INDEF]` |\\n  > 158:| `vectors_of_square_and_divisibility(L, n, d)` | Vectors $v$ with $v^2 = n$ and divisibility $d$ in $L$ | `[PD]` |\\n  > 159:| `enumerate_quadratic_triples(L, ...)` | Enumerate quadratic solutions in lattice | `[PD]` |\\n  > 160:| `minimum(L)` | Squared length of shortest nonzero vector | `[PD]` |\\n  > 161:| `kissing_number(L)` | Number of shortest vectors | `[PD]` |\\n  > 162:\\n  > 163:- ND lattices: use `rescale(L, -1)` then enumerate (no scalar rescaling makes INDEF → PD)\\n  > 164:- INDEF: `short_vectors` / `shortest_vectors` refuse; use `short_vectors_affine` or genus methods\\n  > 165:- `close_vectors` with `check=false` runs on INDEF but result is ill-posed (distances can be negative/zero)\\n  > 166:\\n  > 167:### 2.7 Genus and classification\\n  > 168:\\n  > 169:#### ZZGenus methods\\n  > 170:\\n  > 171:| Method | Description | Tags |\\n  > 172:|--------|-------------|------|\\n  > 173:| `genus(L::ZZLat)` | `ZZGenus` — genus symbol (local invariants at all primes) | `[INDEF ok]` |\\n  > 174:| `genus(A::MatElem)` | Genus from Gram matrix | `[INDEF ok]` |\\n  > 175:| `genus(L, p)` | Local genus `ZZLocalGenus` at prime $p$ | |\\n  > 176:| `integer_genera(sig::Tuple{Int, Int}, det::RationalUnion; even::Bool=true, kwargs...)` / `integer_genera(sig::Tuple{Int, Int}, det::QQFieldElem; even::Bool=true, max_scale::Int=Int(det), rank::Int=sum(sig), kwargs...)` | Enumerate all genus symbols with signature `sig=(s_+, s_-)` and determinant `det`; upstream requires determinant sign compatibility (`det` has sign `(-1)^{s_-}`) and parity compatibility (`det ∈ 2ZZ` when `even=true`, `det ∈ ZZ` when `even=false`) | |\\n  > 177:| `direct_sum(G1::ZZGenus, G2::ZZGenus)` | Genus of the orthogonal direct sum | |\\n  > 178:| `representative(gen)` | Concrete lattice for a genus class | |\\n  > 179:| `representatives(gen)` | All classes in genus | |\\n  > 180:| `mass(gen)` | Mass of the genus | |\\n  > 181:| `dim(gen)` / `rank(gen)` | Dimension / rank of genus | |\\n  > 182:| `signature(gen)` | Signature pair | |\\n  > 183:| `det(gen)` | Determinant | |\\n  > 184:| `iseven(gen)` | Evenness | |\\n  > 185:| `is_definite(gen)` | Definiteness | |\\n  > 186:| `level(gen)` | Level | |\\n  > 187:| `scale(gen)` / `norm(gen)` | Scale / norm of genus | |\\n  > 188:| `primes(gen)` | List of primes appearing in local symbols | |\\n  > 189:| `is_integral(gen)` | Integrality | |\\n  > 190:| `local_symbol(gen, p)` | Retrieve `ZZLocalGenus` at prime $p$ | |\\n  > 191:| `quadratic_space(gen)` | Quadratic space representing the genus | |\\n  > 192:| `rational_representative(gen)` | Rational form | |\\n  > 193:| `rescale(gen, a)` | Rescaled genus | |\\n  > 194:| `represents(G1, G2)` | Whether genus $G_1$ represents $G_2$ | |\\n  > 195:\\n  > 196:#### ZZLocalGenus methods\\n  > 197:\\n  > 198:| Method | Description | Tags |\\n  > 199:|--------|-------------|------|\\n  > 200:| `prime(S)` | Underlying prime | |\\n  > 201:| `iseven(S)` | Evenness at $p$ | |\\n  > 202:| `symbol(S, scale)` | Jordan block invariants | |\\n  > 203:| `hasse_invariant(S)` | Hasse invariant | |\\n  > 204:| `det(S)` / `dim(S)` / `rank(S)` | Determinant / dimension / rank | |\\n  > 205:| `excess(S)` | $p$-excess | |\\n  > 206:| `signature(S)` | $p$-signature | |\\n  > 207:| `oddity(S)` | 2-adic oddity | |\\n  > 208:| `scale(S)` / `norm(S)` / `level(S)` | Scale / norm / level | |\\n  > 209:| `representative(S)` / `gram_matrix(S)` | Representative lattice / Gram | |\\n  > 210:| `rescale(S, a)` | Rescaled local genus | |\\n  > 211:| `direct_sum(S1, S2)` | Local genus direct sum | |\\n  > 212:| `represents(S1, S2)` | Local representation check | |\\n  > 213:\\n  > 214:#### Discriminant group and classification\\n  > 215:\\n  > 216:| Method | Description | Tags |\\n  > 217:|--------|-------------|------|\\n  > 218:| `discriminant_group(L)` | $L^\\\\vee / L$ as `TorQuadModule` | |\\n  > 219:| `genus_representatives(L)` | All isometry class representatives in the genus of $L$ | |\\n  > 220:| `Hecke.quadratic_lattice_database()` | DB of lattices rank ≥ 3 with class number 1 or 2 | `[PD]` |\\n  > 221:\\n  > 222:- Genus relies on local theory (Jordan decomposition, local densities) via MAGMA/GAP\\n  > 223:- INDEF genus: can compute discriminant forms and genera even for indefinite lattices\\n  > 224:- Handles even unimodular indefinite forms $II_{p,q}$\\n  > 225:- Two even INDEF lattices of the same genus are often isometric (Hasse–Minkowski); genus invariants may suffice for equivalence\\n  > 226:\\n  > 227:### 2.8 Automorphism and isometry\\n  > 228:\\n  > 229:| Method | Description | Tags |\\n  > 230:|--------|-------------|------|\\n  > 231:| `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)` | Generators of `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite); `ambient_representation=true` returns matrices in ambient-space coordinates | `[DEFINITE, GAP]` |\\n  > 232:| `automorphism_group_order(L::AbstractLat; depth::Int=-1, bacher_depth::Int=0)` | Order of `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite) | `[DEFINITE]` |\\n  > 233:| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\\n  > 234:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |\\n  > 235:| `is_locally_isometric(L1, L2, p)` | $p$-adic isometry test | |\\n  > 236:| `is_rationally_isometric(L1, L2)` | Rational (ℚ) isometry test | `[INDEF ok]` |\\n  > 237:| `hasse_invariant(L, p)` | Hasse invariant at prime $p$ | |\\n  > 238:| `witt_invariant(L, p)` | Witt invariant at prime $p$ | |\\n  > 239:\\n  > 240:- DEFINITE (PD or ND): `automorphism_group_generators` / `automorphism_group_order` support both positive and negative definite lattices; finite groups computed via shortest vectors + symmetries (e.g. $E_8$ Weyl group); negative definite lattices may be passed directly (no need to rescale by $-1$ first)\\n  > 241:- Oscar also exposes \\\"Lattices with isometry\\\" and \\\"Groups of automorphisms\\\" sections\\n  > 242:- INDEF: Aut(L) infinite; use Indefinite.jl or Vinberg's algorithm for reflection subgroups\\n  > 243:- Rational/local isometry tests work for all signatures and are key ingredients in genus theory\\n  > 244:\\n  > 245:### 2.9 Module operations and embeddings\\n  > 246:\\n  > 247:| Method | Description | Tags |\\n  > 248:|--------|-------------|------|\\n  > 249:| `direct_sum(L1, L2)` | Orthogonal direct sum; returns $(L, i_1, i_2)$ with injection maps | |\\n  > 250:| `direct_product(L1, L2)` | Direct product; returns $(L, p_1, p_2)$ with projection maps | |\\n  > 251:| `biproduct(L1, L2)` | Biproduct; returns $(L, i_1, i_2, p_1, p_2)$ | |\\n  > 252:| `intersect(L1, L2)` | Intersection in common ambient space | |\\n  > 253:| `+(L1, L2)` | Sum of lattices in common ambient | |\\n  > 254:| `*(n, L)` | Scalar multiple of lattice | |\\n  > 255:| `lattice_in_same_ambient_space(L, B)` | Sublattice with basis B in ambient of L | |\\n  > 256:| `orthogonal_submodule(L, S)` | Orthogonal complement of S in L | |\\n  > 257:| `dual(L)` | Dual lattice $L^\\\\vee$ | |\\n  > 258:| `is_sublattice(L, S)` | Whether $S \\\\subseteq L$ | |\\n  > 259:| `is_sublattice_with_relations(L, S)` | Sublattice test + inclusion relations | |\\n  > 260:| `is_primitive(L, S)` | Whether S is primitive in L ($L/S$ torsion-free) | |\\n  > 261:| `primitive_closure(L, S)` | Smallest primitive sublattice of $L$ containing $S$ | |\\n  > 262:| `divisibility(L, v)` | Divisibility of vector $v$ in $L$ | |\\n  > 263:| `in(v, L)` | Vector membership test | |\\n  > 264:| `irreducible_components(L)` | Decompose into orthogonally irreducible components | |\\n  > 265:\\n  > 266:#### Overlattices and embeddings\\n  > 267:\\n  > 268:| Method | Description | Tags |\\n  > 269:|--------|-------------|------|\\n  > 270:| `glue_map(L, S, gen_imgs)` | Construct glue map for primitive extension | |\\n  > 271:| `overlattice(glue_map)` | Build overlattice from a glue map | |\\n  > 272:| `primitive_extension(L1, L2, glue_map)` | Nikulin gluing: lattice from isometric discriminant subquotients | |\"]}"
    }
  ],
  "structuredContent": {
    "result": "{\"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md\": [\"  >  86:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global / local isometry test | |\\n  >  87:| `is_locally_represented_by(U, V, p)` | Whether $U$ is locally represented by $V$ | |\\n  >  88:| `is_represented_by(U, V)` | Whether $U$ is globally represented by $V$ | |\\n  >  89:| `inner_product(V, v, w)` | Evaluate bilinear form | |\\n  >  90:| `orthogonal_complement(V, M)` | Orthogonal complement of subspace $M$ | |\\n  >  91:| `orthogonal_projection(V, M)` | Projection onto subspace $M$ | |\\n  >  92:| `is_isotropic(V, p)` | Local isotropy test | |\\n  >  93:| `is_locally_hyperbolic(V, p)` | Whether $V_p$ is hyperbolic (hermitian spaces) | |\\n  >  94:| `restrict_scalars(V, K, α)` | Restriction of scalars | |\\n  >  95:| `direct_sum(V, W)` / `direct_product` / `biproduct` | Categorical constructions | |\\n  >  96:\\n  >  97:### 2.3 Construction\\n  >  98:\\n  >  99:| Function | Description | Tags |\\n  > 100:|----------|-------------|------|\\n  > 101:| `integer_lattice(; gram=G)` | Integer lattice from Gram matrix | |\\n  > 102:| `integer_lattice(B; gram=G)` | Integer lattice from basis matrix $B$ and optional Gram | |\\n  > 103:| `lattice(V, B)` | Lattice in quadratic space $V$ with basis matrix $B$ | |\\n  > 104:| `quadratic_lattice(K, gens; gram=M)` | Lattice from generators + Gram matrix; `K=QQ` → `ZZLat` | `[INDEF ok]` |\\n  > 105:| `hermitian_lattice(E, gens; gram=M)` | Hermitian lattice over quadratic extension E | |\\n  > 106:| `root_lattice(:A, n)` / `(:D, n)` / `(:E, n)` / `(:I, n)` | Named root lattice | `[PD]` |\\n  > 107:| `hyperbolic_plane_lattice(n)` | Hyperbolic plane $U$ scaled by $n$ | `[INDEF]` |\\n  > 108:| `leech_lattice()` | Rank-24 Leech lattice | `[PD]` |\\n  > 109:| `k3_lattice()` | K3 surface lattice $U^3 \\\\oplus E_8(-1)^2$ | `[INDEF]` |\\n  > 110:| `mukai_lattice()` | Rank-24 Mukai lattice (K3 theory); optional extended form | `[INDEF]` |\\n  > 111:| `hyperkaehler_lattice(:K3, n=3)` | Hyperkähler intersection form (sig $(3,19)$ or similar) | `[INDEF]` |\\n  > 112:| `rescale(L, r)` | New lattice with Gram $r \\\\cdot G$; use `rescale(L, -1)` to flip sign of ND lattice | |\\n  > 113:\\n  > 114:### 2.4 Intrinsic data\\n  > 115:\\n  > 116:| Method | Description | Tags |\\n  > 117:|--------|-------------|------|\\n  > 118:| `gram_matrix(L)` | Gram matrix | |\\n  > 119:| `basis_matrix(L)` | Basis matrix | |\\n  > 120:| `ambient_space(L)` | Ambient quadratic space | |\\n  > 121:| `rational_span(L)` | Rational span as quadratic space | |\\n  > 122:| `rank(L)` | Rank | |\\n  > 123:| `degree(L)` | Degree (ambient dimension) | |\\n  > 124:| `signature_tuple(L)` | $(n_{+}, n_{0}, n_{-})$ (positive, zero, negative counts) | `[INDEF ok]` |\\n  > 125:| `det(L)` | Determinant of Gram | |\\n  > 126:| `discriminant(L)` | Discriminant | |\\n  > 127:| `scale(L)` | Scale ideal (generated by $b(x,y)$ for all $x,y \\\\in L$) | |\\n  > 128:| `norm(L)` | Norm ideal (generated by $q(x)$ for all $x \\\\in L$) | |\\n  > 129:| `is_positive_definite(L)` | | `[PD]` |\\n  > 130:| `is_negative_definite(L)` | | |\\n  > 131:| `is_definite(L)` | PD or ND | |\\n  > 132:| `is_even(L)` | All $(x,x) \\\\in 2\\\\mathbb{Z}$ | |\\n  > 133:| `is_integral(L)` | All $b(x,y) \\\\in \\\\mathbb{Z}$ | |\\n  > 134:| `is_unimodular(L)` | $|\\\\det G| = 1$ | |\\n  > 135:| `is_primary(L, p)` | $L^\\\\vee/L$ is a $p$-group | |\\n  > 136:| `is_primary_with_prime(L)` | Returns `(true, p)` if primary | |\\n  > 137:| `is_elementary(L, p)` | $L^\\\\vee/L \\\\cong (\\\\mathbb{Z}/p)^k$ | |\\n  > 138:| `is_elementary_with_prime(L)` | Returns `(true, p)` if elementary | |\\n  > 139:\\n  > 140:### 2.5 Reduction\\n  > 141:\\n  > 142:| Method | Description | Tags |\\n  > 143:|--------|-------------|------|\\n  > 144:| `lll(L::ZZLat; same_ambient::Bool=true, redo::Bool=false, ctx::LLLContext=...)` | LLL-reduced basis; returns new lattice; `redo=true` forces recomputation even if cached; `ctx` specifies Lovász parameters | `[INDEF ok, FLINT]` |\\n  > 145:\\n  > 146:- PD: specify Lovász parameters via `LLLContext(δ, η)` passed as `ctx`\\n  > 147:- INDEF: runs but \\\"shorter\\\" is w.r.t. a majorant, not the indefinite form itself\\n  > 148:\\n  > 149:### 2.6 Vector enumeration\\n  > 150:\\n  > 151:| Method | Description | Tags |\\n  > 152:|--------|-------------|------|\\n  > 153:| `short_vectors(L, lb, ub)` | Nonzero vectors with $lb \\\\le \\\\|v\\\\|^2 \\\\le ub$ (up to sign) | `[PD]` |\\n  > 154:| `short_vectors_iterator(L, lb, ub)` | Lazy iterator version of `short_vectors` | `[PD]` |\\n  > 155:| `shortest_vectors(L)` | Shortest vectors and their squared norm | `[PD]` |\\n  > 156:| `close_vectors(L::ZZLat, v::Vector, [lb,] ub; check::Bool=false)` | Returns `Vector{Tuple{Vector{Int}, QQFieldElem}}` — lattice points $x$ with $b(v-x, v-x) \\\\le ub$; Fincke–Pohst enumeration; **`check` defaults to `false`** (not `true`) | `[PD]` |\\n  > 157:| `short_vectors_affine(S, v, α, d)` | Vectors $x \\\\in S$ with $x^2 = d$ and $x \\\\cdot v = \\\\alpha$ (Vinberg) | `[INDEF]` |\\n  > 158:| `vectors_of_square_and_divisibility(L, n, d)` | Vectors $v$ with $v^2 = n$ and divisibility $d$ in $L$ | `[PD]` |\\n  > 159:| `enumerate_quadratic_triples(L, ...)` | Enumerate quadratic solutions in lattice | `[PD]` |\\n  > 160:| `minimum(L)` | Squared length of shortest nonzero vector | `[PD]` |\\n  > 161:| `kissing_number(L)` | Number of shortest vectors | `[PD]` |\\n  > 162:\\n  > 163:- ND lattices: use `rescale(L, -1)` then enumerate (no scalar rescaling makes INDEF → PD)\\n  > 164:- INDEF: `short_vectors` / `shortest_vectors` refuse; use `short_vectors_affine` or genus methods\\n  > 165:- `close_vectors` with `check=false` runs on INDEF but result is ill-posed (distances can be negative/zero)\\n  > 166:\\n  > 167:### 2.7 Genus and classification\\n  > 168:\\n  > 169:#### ZZGenus methods\\n  > 170:\\n  > 171:| Method | Description | Tags |\\n  > 172:|--------|-------------|------|\\n  > 173:| `genus(L::ZZLat)` | `ZZGenus` — genus symbol (local invariants at all primes) | `[INDEF ok]` |\\n  > 174:| `genus(A::MatElem)` | Genus from Gram matrix | `[INDEF ok]` |\\n  > 175:| `genus(L, p)` | Local genus `ZZLocalGenus` at prime $p$ | |\\n  > 176:| `integer_genera(sig::Tuple{Int, Int}, det::RationalUnion; even::Bool=true, kwargs...)` / `integer_genera(sig::Tuple{Int, Int}, det::QQFieldElem; even::Bool=true, max_scale::Int=Int(det), rank::Int=sum(sig), kwargs...)` | Enumerate all genus symbols with signature `sig=(s_+, s_-)` and determinant `det`; upstream requires determinant sign compatibility (`det` has sign `(-1)^{s_-}`) and parity compatibility (`det ∈ 2ZZ` when `even=true`, `det ∈ ZZ` when `even=false`) | |\\n  > 177:| `direct_sum(G1::ZZGenus, G2::ZZGenus)` | Genus of the orthogonal direct sum | |\\n  > 178:| `representative(gen)` | Concrete lattice for a genus class | |\\n  > 179:| `representatives(gen)` | All classes in genus | |\\n  > 180:| `mass(gen)` | Mass of the genus | |\\n  > 181:| `dim(gen)` / `rank(gen)` | Dimension / rank of genus | |\\n  > 182:| `signature(gen)` | Signature pair | |\\n  > 183:| `det(gen)` | Determinant | |\\n  > 184:| `iseven(gen)` | Evenness | |\\n  > 185:| `is_definite(gen)` | Definiteness | |\\n  > 186:| `level(gen)` | Level | |\\n  > 187:| `scale(gen)` / `norm(gen)` | Scale / norm of genus | |\\n  > 188:| `primes(gen)` | List of primes appearing in local symbols | |\\n  > 189:| `is_integral(gen)` | Integrality | |\\n  > 190:| `local_symbol(gen, p)` | Retrieve `ZZLocalGenus` at prime $p$ | |\\n  > 191:| `quadratic_space(gen)` | Quadratic space representing the genus | |\\n  > 192:| `rational_representative(gen)` | Rational form | |\\n  > 193:| `rescale(gen, a)` | Rescaled genus | |\\n  > 194:| `represents(G1, G2)` | Whether genus $G_1$ represents $G_2$ | |\\n  > 195:\\n  > 196:#### ZZLocalGenus methods\\n  > 197:\\n  > 198:| Method | Description | Tags |\\n  > 199:|--------|-------------|------|\\n  > 200:| `prime(S)` | Underlying prime | |\\n  > 201:| `iseven(S)` | Evenness at $p$ | |\\n  > 202:| `symbol(S, scale)` | Jordan block invariants | |\\n  > 203:| `hasse_invariant(S)` | Hasse invariant | |\\n  > 204:| `det(S)` / `dim(S)` / `rank(S)` | Determinant / dimension / rank | |\\n  > 205:| `excess(S)` | $p$-excess | |\\n  > 206:| `signature(S)` | $p$-signature | |\\n  > 207:| `oddity(S)` | 2-adic oddity | |\\n  > 208:| `scale(S)` / `norm(S)` / `level(S)` | Scale / norm / level | |\\n  > 209:| `representative(S)` / `gram_matrix(S)` | Representative lattice / Gram | |\\n  > 210:| `rescale(S, a)` | Rescaled local genus | |\\n  > 211:| `direct_sum(S1, S2)` | Local genus direct sum | |\\n  > 212:| `represents(S1, S2)` | Local representation check | |\\n  > 213:\\n  > 214:#### Discriminant group and classification\\n  > 215:\\n  > 216:| Method | Description | Tags |\\n  > 217:|--------|-------------|------|\\n  > 218:| `discriminant_group(L)` | $L^\\\\vee / L$ as `TorQuadModule` | |\\n  > 219:| `genus_representatives(L)` | All isometry class representatives in the genus of $L$ | |\\n  > 220:| `Hecke.quadratic_lattice_database()` | DB of lattices rank ≥ 3 with class number 1 or 2 | `[PD]` |\\n  > 221:\\n  > 222:- Genus relies on local theory (Jordan decomposition, local densities) via MAGMA/GAP\\n  > 223:- INDEF genus: can compute discriminant forms and genera even for indefinite lattices\\n  > 224:- Handles even unimodular indefinite forms $II_{p,q}$\\n  > 225:- Two even INDEF lattices of the same genus are often isometric (Hasse–Minkowski); genus invariants may suffice for equivalence\\n  > 226:\\n  > 227:### 2.8 Automorphism and isometry\\n  > 228:\\n  > 229:| Method | Description | Tags |\\n  > 230:|--------|-------------|------|\\n  > 231:| `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)` | Generators of `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite); `ambient_representation=true` returns matrices in ambient-space coordinates | `[DEFINITE, GAP]` |\\n  > 232:| `automorphism_group_order(L::AbstractLat; depth::Int=-1, bacher_depth::Int=0)` | Order of `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite) | `[DEFINITE]` |\\n  > 233:| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\\n  > 234:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |\\n  > 235:| `is_locally_isometric(L1, L2, p)` | $p$-adic isometry test | |\\n  > 236:| `is_rationally_isometric(L1, L2)` | Rational (ℚ) isometry test | `[INDEF ok]` |\\n  > 237:| `hasse_invariant(L, p)` | Hasse invariant at prime $p$ | |\\n  > 238:| `witt_invariant(L, p)` | Witt invariant at prime $p$ | |\\n  > 239:\\n  > 240:- DEFINITE (PD or ND): `automorphism_group_generators` / `automorphism_group_order` support both positive and negative definite lattices; finite groups computed via shortest vectors + symmetries (e.g. $E_8$ Weyl group); negative definite lattices may be passed directly (no need to rescale by $-1$ first)\\n  > 241:- Oscar also exposes \\\"Lattices with isometry\\\" and \\\"Groups of automorphisms\\\" sections\\n  > 242:- INDEF: Aut(L) infinite; use Indefinite.jl or Vinberg's algorithm for reflection subgroups\\n  > 243:- Rational/local isometry tests work for all signatures and are key ingredients in genus theory\\n  > 244:\\n  > 245:### 2.9 Module operations and embeddings\\n  > 246:\\n  > 247:| Method | Description | Tags |\\n  > 248:|--------|-------------|------|\\n  > 249:| `direct_sum(L1, L2)` | Orthogonal direct sum; returns $(L, i_1, i_2)$ with injection maps | |\\n  > 250:| `direct_product(L1, L2)` | Direct product; returns $(L, p_1, p_2)$ with projection maps | |\\n  > 251:| `biproduct(L1, L2)` | Biproduct; returns $(L, i_1, i_2, p_1, p_2)$ | |\\n  > 252:| `intersect(L1, L2)` | Intersection in common ambient space | |\\n  > 253:| `+(L1, L2)` | Sum of lattices in common ambient | |\\n  > 254:| `*(n, L)` | Scalar multiple of lattice | |\\n  > 255:| `lattice_in_same_ambient_space(L, B)` | Sublattice with basis B in ambient of L | |\\n  > 256:| `orthogonal_submodule(L, S)` | Orthogonal complement of S in L | |\\n  > 257:| `dual(L)` | Dual lattice $L^\\\\vee$ | |\\n  > 258:| `is_sublattice(L, S)` | Whether $S \\\\subseteq L$ | |\\n  > 259:| `is_sublattice_with_relations(L, S)` | Sublattice test + inclusion relations | |\\n  > 260:| `is_primitive(L, S)` | Whether S is primitive in L ($L/S$ torsion-free) | |\\n  > 261:| `primitive_closure(L, S)` | Smallest primitive sublattice of $L$ containing $S$ | |\\n  > 262:| `divisibility(L, v)` | Divisibility of vector $v$ in $L$ | |\\n  > 263:| `in(v, L)` | Vector membership test | |\\n  > 264:| `irreducible_components(L)` | Decompose into orthogonally irreducible components | |\\n  > 265:\\n  > 266:#### Overlattices and embeddings\\n  > 267:\\n  > 268:| Method | Description | Tags |\\n  > 269:|--------|-------------|------|\\n  > 270:| `glue_map(L, S, gen_imgs)` | Construct glue map for primitive extension | |\\n  > 271:| `overlattice(glue_map)` | Build overlattice from a glue map | |\\n  > 272:| `primitive_extension(L1, L2, glue_map)` | Nikulin gluing: lattice from isometric discriminant subquotients | |\"]}"
  },
  "isError": false
}
thinking
I can see that `is_isometric(L1, L2)` is currently tagged with `[PD]` in both Julia reference files. Let me check the upstream docs to see if this is accurate or if it should be `[DEFINITE]` like the automorphism_group methods.
tool serena.execute_shell_command({"command":"curl -s \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | head -100","cwd":"/home/dzack/lattice_interface","max_answer_chars":5000})
serena.execute_shell_command({"command":"curl -s \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | head -100","cwd":"/home/dzack/lattice_interface","max_answer_chars":5000}) success in 552ms:
{
  "content": [
    {
      "type": "text",
      "text": "The answer is too long (69652 characters). Please try a more specific tool query or raise the max_answer_chars parameter."
    }
  ],
  "structuredContent": {
    "result": "The answer is too long (69652 characters). Please try a more specific tool query or raise the max_answer_chars parameter."
  },
  "isError": false
}
thinking
The URL is accessible and returns a large document. Let me try a more targeted search for `is_isometric` in the upstream docs.
tool serena.execute_shell_command({"command":"curl -s \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -i \"is_isometric\" | head -20","cwd":"/home/dzack/lattice_interface","max_answer_chars":3000})
serena.execute_shell_command({"command":"curl -s \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -i \"is_isometric\" | head -20","cwd":"/home/dzack/lattice_interface","max_answer_chars":3000}) success in 433ms:
{
  "content": [
    {
      "type": "text",
      "text": "The answer is too long (5326 characters). Please try a more specific tool query or raise the max_answer_chars parameter."
    }
  ],
  "structuredContent": {
    "result": "The answer is too long (5326 characters). Please try a more specific tool query or raise the max_answer_chars parameter."
  },
  "isError": false
}
thinking
The output is long but contains the grep results. Let me try with more context.
tool serena.execute_shell_command({"command":"curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -A2 -B2 \"is_isometric\"","cwd":"/home/dzack/lattice_interface","max_answer_chars":8000})
serena.execute_shell_command({"command":"curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -A2 -B2 \"is_isometric\"","cwd":"/home/dzack/lattice_interface","max_answer_chars":8000}) success in 211ms:
{
  "content": [
    {
      "type": "text",
      "text": "The answer is too long (19564 characters). Please try a more specific tool query or raise the max_answer_chars parameter."
    }
  ],
  "structuredContent": {
    "result": "The answer is too long (19564 characters). Please try a more specific tool query or raise the max_answer_chars parameter."
  },
  "isError": false
}
thinking
The curl output is huge. Let me try a different approach - use grep with a max output.
exec
/bin/bash -lc 'curl -sL "https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/" 2>&1 | grep -i "is_isometric" | head -5' in /home/dzack/lattice_interface succeeded in 50ms:
Total output lines: 1

                                                      -&gt; Vector{MatElem}</code></pre><p>Given a definite lattice <code>L</code>, return generators for the automorphism group of <code>L</code>. If <code>ambient_representation == true</code> (the default), the transformations are represented with respect to the ambient space of <code>L</code>. Otherwise, the transformations are represented with respect to the (pseudo-)basis of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1526-L1539">source</a></section></details></article><article><details class="docstring"><summ…790 tokens truncated…root_lattice_recognition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">root_lattice_recognition(L::ZZLat)</code></pre><p>Return the ADE type of the root sublattice of <code>L</code>.</p><p>The root sublattice is the lattice spanned by the vectors of squared length <span>$1$</span> and <span>$2$</span>.  The odd lattice of rank 1 and determinant <span>$1$</span> is denoted by <code>(:I, 1)</code>.</p><p>Input:</p><p><code>L</code> – a definite and integral <span>$\mathbb{Z}$</span>-lattice.</p><p>Output:</p><p>Two lists, the first one containing the ADE types and the second one the irreducible root sublattices.</p><p>For more recognizable gram matrices use <a href="#root_lattice_recognition_fundamental-Tuple{ZZLat}"><code>root_lattice_recognition_fundamental</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = integer_lattice(; gram=ZZ[4  0 0  0 3  0 3  0;
thinking
The curl output is getting truncated. Let me try a more targeted approach - searching for is_isometric in a different way, or looking at the local upstream snapshots that are mentioned in the TODO.

Let me search the local docs for is_isometric documentation.
tool serena.find_file({"file_mask":"*.md","relative_path":"docs"})
serena.find_file({"file_mask":"*.md","relative_path":"docs"}) success in 148ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"files\": [\"docs/forms_methods_checklist.md\", \"docs/ntl_methods_checklist.md\", \"docs/sage_methods_checklist.md\", \"docs/hypercells/lattice/hypercells_lattice_reference.md\", \"docs/hypercells/upstream/chap0_overview.md\", \"docs/hypercells/upstream/chap3_cells.md\", \"docs/hypercells/upstream/chap2_triangle_groups.md\", \"docs/hypercells/upstream/chap4_model_graphs.md\", \"docs/hypercells/upstream/hypercells_online_provenance_2026-02-17.md\", \"docs/hypercells/upstream/chap5_supercells.md\", \"docs/hypercells/upstream/chap1_introduction.md\", \"docs/latticegen/reference/latticegen_lattice_reference.md\", \"docs/crystallographic_stack_methods_checklist.md\", \"docs/TODO.md\", \"docs/archive/README.md\", \"docs/archive/fplll/lattice/fplll_lattice_reference.md\", \"docs/archive/scope_violations/topcom/lattice/topcom_lattice_reference.md\", \"docs/archive/scope_violations/topcom/upstream/topcom_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/normaliz/lattice/normaliz_lattice_reference.md\", \"docs/archive/scope_violations/nconvex_methods_checklist.md\", \"docs/archive/scope_violations/topcom_methods_checklist.md\", \"docs/archive/scope_violations/toric_methods_checklist.md\", \"docs/archive/scope_violations/palp/lattice/palp_lattice_reference.md\", \"docs/archive/scope_violations/palp/upstream/palp_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/sage_methods_checklist_toric_sections_2026-02-18.md\", \"docs/archive/scope_violations/gap/lattice/gap_lattice_methods_reference_polyhedral_sections_2026-02-18.md\", \"docs/archive/scope_violations/lrslib_methods_checklist.md\", \"docs/archive/scope_violations/lrslib/lattice/lrslib_lattice_reference.md\", \"docs/archive/scope_violations/lrslib/upstream/lrslib_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/latte_integrale/lattice/latte_integrale_lattice_reference.md\", \"docs/archive/scope_violations/latte_integrale/upstream/latte_integrale_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/cddinterface/lattice/cddinterface_lattice_reference.md\", \"docs/archive/scope_violations/cddinterface/upstream/cddinterface_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/cddlib_methods_checklist.md\", \"docs/archive/scope_violations/cddlib/lattice/cddlib_lattice_reference.md\", \"docs/archive/scope_violations/cddlib/upstream/cddlib_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/gap_methods_checklist_polyhedral_sections_2026-02-18.md\", \"docs/archive/scope_violations/sage/lattice/sagemath_lattice_reference_toric_sections_2026-02-18.md\", \"docs/archive/scope_violations/4ti2/lattice/4ti2_lattice_reference.md\", \"docs/archive/scope_violations/cddinterface_methods_checklist.md\", \"docs/archive/scope_violations/polymake_methods_checklist.md\", \"docs/archive/scope_violations/latte_integrale_methods_checklist.md\", \"docs/archive/scope_violations/toric/lattice/gap_toric_lattice_reference.md\", \"docs/archive/scope_violations/toric/upstream/toric_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/normaliz_methods_checklist.md\", \"docs/archive/scope_violations/palp_methods_checklist.md\", \"docs/archive/scope_violations/4ti2_methods_checklist.md\", \"docs/archive/scope_violations/pycddlib/lattice/pycddlib_lattice_reference.md\", \"docs/archive/scope_violations/pycddlib/upstream/pycddlib_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/polymake/lattice/polymake_lattice_reference.md\", \"docs/archive/scope_violations/polymake/upstream/polymake_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/nconvex/lattice/nconvex_lattice_reference.md\", \"docs/archive/scope_violations/nconvex/upstream/nconvex_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/pycddlib_methods_checklist.md\", \"docs/archive/fplll_methods_checklist.md\", \"docs/lattice_wrapper_capability_checklist.md\", \"docs/flatter_methods_checklist.md\", \"docs/documentation_coverage_audit_playbook.md\", \"docs/project/plans/2026-02-15-lattice-wrapper-tdd-implementation.md\", \"docs/project/doc_coverage_audit_changelog.md\", \"docs/julia_methods_checklist.md\", \"docs/flint_methods_checklist.md\", \"docs/gap_methods_checklist.md\", \"docs/g6k/lattice/g6k_lattice_reference.md\", \"docs/g6k/upstream/g6k_online_provenance_2026-02-17.md\", \"docs/ntl/lattice/ntl_lattice_reference.md\", \"docs/gap/lattice/gap_lattice_methods_reference.md\", \"docs/gap/upstream/README.md\", \"docs/crystallographic_stack/lattice/crystallographic_stack_lattice_reference.md\", \"docs/crystallographic_stack/upstream/crystallographic_stack_online_provenance_2026-02-17.md\", \"docs/interface_design_playbook.md\", \"docs/g6k_methods_checklist.md\", \"docs/pari_gp_methods_checklist.md\", \"docs/latticegen_methods_checklist.md\", \"docs/sage/SOURCES.md\", \"docs/sage/torsion_quadratic_module/sage_torsion_quadratic_module_reference.md\", \"docs/sage/special_forms/README.md\", \"docs/sage/README.md\", \"docs/sage/quadratic_form/sage_quadratic_form_reference.md\", \"docs/sage/lattice/sagemath_lattice_reference.md\", \"docs/sage/integral_lattice/sage_integral_lattice_reference.md\", \"docs/sage/genus/sage_genus_reference.md\", \"docs/test_coverage_playbook.md\", \"docs/fpylll/lattice/fpylll_lattice_reference.md\", \"docs/fpylll/upstream/fpylll_online_provenance_2026-02-18.md\", \"docs/flatter/lattice/flatter_lattice_reference.md\", \"docs/flatter/upstream/README.md\", \"docs/flatter/upstream/flatter_online_provenance_2026-02-17.md\", \"docs/flatter/upstream/example_profiles.md\", \"docs/hypercells_methods_checklist.md\", \"docs/fpylll_methods_checklist.md\", \"docs/julia/indefinite_jl/inventory/indefinite_julia_gap_method_inventory.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/spacewithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/fingrpact.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/primembed.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/introduction.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/torquadmodwithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/enumeration.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom_online_provenance_2026-02-17.md\", \"docs/julia/oscar_jl/lie_theory/root_systems.md\", \"docs/julia/oscar_jl/lie_theory/cartan_matrix.md\", \"docs/julia/oscar_jl/lie_theory/intro.md\", \"docs/julia/oscar_jl/lie_theory/weyl_groups.md\", \"docs/julia/oscar_jl/lie_theory/weight_lattices.md\", \"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md\", \"docs/julia/oscar_jl/algebraic_geometry/surfaces/K3Surfaces.md\", \"docs/julia/oscar_jl/algebraic_geometry/surfaces/EnriquesSurfaces.md\", \"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md\", \"docs/pari_gp/lattice/pari_gp_lattice_reference.md\", \"docs/pari_gp/upstream/pari_gp_online_provenance_2026-02-17.md\", \"docs/flint/lattice/flint_lattice_reference.md\", \"docs/forms/lattice/forms_lattice_reference.md\", \"docs/forms/upstream/forms_online_provenance_2026-02-17.md\"]}"
    }
  ],
  "structuredContent": {
    "result": "{\"files\": [\"docs/forms_methods_checklist.md\", \"docs/ntl_methods_checklist.md\", \"docs/sage_methods_checklist.md\", \"docs/hypercells/lattice/hypercells_lattice_reference.md\", \"docs/hypercells/upstream/chap0_overview.md\", \"docs/hypercells/upstream/chap3_cells.md\", \"docs/hypercells/upstream/chap2_triangle_groups.md\", \"docs/hypercells/upstream/chap4_model_graphs.md\", \"docs/hypercells/upstream/hypercells_online_provenance_2026-02-17.md\", \"docs/hypercells/upstream/chap5_supercells.md\", \"docs/hypercells/upstream/chap1_introduction.md\", \"docs/latticegen/reference/latticegen_lattice_reference.md\", \"docs/crystallographic_stack_methods_checklist.md\", \"docs/TODO.md\", \"docs/archive/README.md\", \"docs/archive/fplll/lattice/fplll_lattice_reference.md\", \"docs/archive/scope_violations/topcom/lattice/topcom_lattice_reference.md\", \"docs/archive/scope_violations/topcom/upstream/topcom_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/normaliz/lattice/normaliz_lattice_reference.md\", \"docs/archive/scope_violations/nconvex_methods_checklist.md\", \"docs/archive/scope_violations/topcom_methods_checklist.md\", \"docs/archive/scope_violations/toric_methods_checklist.md\", \"docs/archive/scope_violations/palp/lattice/palp_lattice_reference.md\", \"docs/archive/scope_violations/palp/upstream/palp_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/sage_methods_checklist_toric_sections_2026-02-18.md\", \"docs/archive/scope_violations/gap/lattice/gap_lattice_methods_reference_polyhedral_sections_2026-02-18.md\", \"docs/archive/scope_violations/lrslib_methods_checklist.md\", \"docs/archive/scope_violations/lrslib/lattice/lrslib_lattice_reference.md\", \"docs/archive/scope_violations/lrslib/upstream/lrslib_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/latte_integrale/lattice/latte_integrale_lattice_reference.md\", \"docs/archive/scope_violations/latte_integrale/upstream/latte_integrale_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/cddinterface/lattice/cddinterface_lattice_reference.md\", \"docs/archive/scope_violations/cddinterface/upstream/cddinterface_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/cddlib_methods_checklist.md\", \"docs/archive/scope_violations/cddlib/lattice/cddlib_lattice_reference.md\", \"docs/archive/scope_violations/cddlib/upstream/cddlib_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/gap_methods_checklist_polyhedral_sections_2026-02-18.md\", \"docs/archive/scope_violations/sage/lattice/sagemath_lattice_reference_toric_sections_2026-02-18.md\", \"docs/archive/scope_violations/4ti2/lattice/4ti2_lattice_reference.md\", \"docs/archive/scope_violations/cddinterface_methods_checklist.md\", \"docs/archive/scope_violations/polymake_methods_checklist.md\", \"docs/archive/scope_violations/latte_integrale_methods_checklist.md\", \"docs/archive/scope_violations/toric/lattice/gap_toric_lattice_reference.md\", \"docs/archive/scope_violations/toric/upstream/toric_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/normaliz_methods_checklist.md\", \"docs/archive/scope_violations/palp_methods_checklist.md\", \"docs/archive/scope_violations/4ti2_methods_checklist.md\", \"docs/archive/scope_violations/pycddlib/lattice/pycddlib_lattice_reference.md\", \"docs/archive/scope_violations/pycddlib/upstream/pycddlib_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/polymake/lattice/polymake_lattice_reference.md\", \"docs/archive/scope_violations/polymake/upstream/polymake_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/nconvex/lattice/nconvex_lattice_reference.md\", \"docs/archive/scope_violations/nconvex/upstream/nconvex_online_provenance_2026-02-17.md\", \"docs/archive/scope_violations/pycddlib_methods_checklist.md\", \"docs/archive/fplll_methods_checklist.md\", \"docs/lattice_wrapper_capability_checklist.md\", \"docs/flatter_methods_checklist.md\", \"docs/documentation_coverage_audit_playbook.md\", \"docs/project/plans/2026-02-15-lattice-wrapper-tdd-implementation.md\", \"docs/project/doc_coverage_audit_changelog.md\", \"docs/julia_methods_checklist.md\", \"docs/flint_methods_checklist.md\", \"docs/gap_methods_checklist.md\", \"docs/g6k/lattice/g6k_lattice_reference.md\", \"docs/g6k/upstream/g6k_online_provenance_2026-02-17.md\", \"docs/ntl/lattice/ntl_lattice_reference.md\", \"docs/gap/lattice/gap_lattice_methods_reference.md\", \"docs/gap/upstream/README.md\", \"docs/crystallographic_stack/lattice/crystallographic_stack_lattice_reference.md\", \"docs/crystallographic_stack/upstream/crystallographic_stack_online_provenance_2026-02-17.md\", \"docs/interface_design_playbook.md\", \"docs/g6k_methods_checklist.md\", \"docs/pari_gp_methods_checklist.md\", \"docs/latticegen_methods_checklist.md\", \"docs/sage/SOURCES.md\", \"docs/sage/torsion_quadratic_module/sage_torsion_quadratic_module_reference.md\", \"docs/sage/special_forms/README.md\", \"docs/sage/README.md\", \"docs/sage/quadratic_form/sage_quadratic_form_reference.md\", \"docs/sage/lattice/sagemath_lattice_reference.md\", \"docs/sage/integral_lattice/sage_integral_lattice_reference.md\", \"docs/sage/genus/sage_genus_reference.md\", \"docs/test_coverage_playbook.md\", \"docs/fpylll/lattice/fpylll_lattice_reference.md\", \"docs/fpylll/upstream/fpylll_online_provenance_2026-02-18.md\", \"docs/flatter/lattice/flatter_lattice_reference.md\", \"docs/flatter/upstream/README.md\", \"docs/flatter/upstream/flatter_online_provenance_2026-02-17.md\", \"docs/flatter/upstream/example_profiles.md\", \"docs/hypercells_methods_checklist.md\", \"docs/fpylll_methods_checklist.md\", \"docs/julia/indefinite_jl/inventory/indefinite_julia_gap_method_inventory.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/spacewithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/fingrpact.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/primembed.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/introduction.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/torquadmodwithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/enumeration.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom_online_provenance_2026-02-17.md\", \"docs/julia/oscar_jl/lie_theory/root_systems.md\", \"docs/julia/oscar_jl/lie_theory/cartan_matrix.md\", \"docs/julia/oscar_jl/lie_theory/intro.md\", \"docs/julia/oscar_jl/lie_theory/weyl_groups.md\", \"docs/julia/oscar_jl/lie_theory/weight_lattices.md\", \"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md\", \"docs/julia/oscar_jl/algebraic_geometry/surfaces/K3Surfaces.md\", \"docs/julia/oscar_jl/algebraic_geometry/surfaces/EnriquesSurfaces.md\", \"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md\", \"docs/pari_gp/lattice/pari_gp_lattice_reference.md\", \"docs/pari_gp/upstream/pari_gp_online_provenance_2026-02-17.md\", \"docs/flint/lattice/flint_lattice_reference.md\", \"docs/forms/lattice/forms_lattice_reference.md\", \"docs/forms/upstream/forms_online_provenance_2026-02-17.md\"]}"
  },
  "isError": false
}
thinking
Let me look at more recent memory to see what specific contract fidelity work was done. Let me check if there are specific `[PD]` tags that need to be changed to `[DEFINITE]` beyond what's already been done.
tool serena.read_memory({"memory_file_name":"doc_coverage_audit_2026-02-18_fpylll_signature_fidelity_and_archive_scaffold"})
serena.read_memory({"memory_file_name":"doc_coverage_audit_2026-02-18_fpylll_signature_fidelity_and_archive_scaffold"}) success in 79ms:
{
  "content": [
    {
      "type": "text",
      "text": "# Doc Coverage Audit Handoff (2026-02-18): fpylll signature fidelity + archive scaffold\n\n## Objectives covered\n- FIRST GOAL (cursory maintenance check): brief survey for missing in-scope package surfaces; no clear new bilinear-form lattice package surface requiring checklist creation was identified in this pass.\n- SECOND GOAL (active phase focus): tighten method contract correctness/completeness on existing in-scope `fpylll` surface (signatures, defaults, constraints, caveats, source grounding).\n- TODO queue execution: completed first two scope-cleanup scaffold items by creating archive structure + archive README and checking them off in `docs/TODO.md`.\n\n## Completed edits\n1. `docs/fpylll_methods_checklist.md`\n- Replaced placeholder/incorrect signatures with source-anchored signatures.\n- Corrected `GSO.Mat` / `MatGSO` constructor surface to include `flags=GSO_DEFAULT` and removed incorrect `precision` parameter.\n- Corrected `Enumeration(...)` constructor surface (removed unsupported `threads` parameter).\n- Expanded BKZ parameter surface with explicit argument contract and source-anchor caveat.\n- Added explicit `Pruning.run(...)`, `adjust_radius_to_gh_bound(...)`, and `gaussian_heuristic(...)` signatures.\n- Added provenance-file reference.\n\n2. `docs/fpylll/lattice/fpylll_lattice_reference.md`\n- Rewrote to canonical/source-backed contract style.\n- Added explicit method signatures, default values, and parameter constraints for core `LLL`, `BKZ`, `Enumeration`, `SVP/CVP`, `Pruning`, and utility APIs.\n- Added explicit BKZ doc-gap note: modules page does not fully render BKZ member signatures; signatures are source-anchored.\n- Removed non-canonical DeepWiki/Context7 source references and replaced with canonical upstream docs + source files.\n\n3. `docs/fpylll/upstream/fpylll_online_provenance_2026-02-18.md` (new)\n- Added dated provenance capture with canonical URLs and signature-fidelity notes used for this pass.\n\n4. `docs/archive/README.md` (new) + archive structure scaffolding\n- Added archive scope-policy README.\n- Added tracked placeholders:\n  - `docs/archive/scope_violations/.gitkeep`\n  - `docs/archive/scope_violations/upstream/.gitkeep`\n\n5. `docs/TODO.md`\n- Marked complete:\n  - create archive folder structure,\n  - add archive README.\n\n## Commit\n- `eb5d41b` — docs: tighten fpylll method contracts and add scope archive scaffold\n\n## Notes on repository state handling\n- Preserved unrelated pre-existing dirty files and did not revert/reset them:\n  - `README.md`\n  - `docs/documentation_coverage_audit_playbook.md`\n  - `prompt.md`\n  - `scripts/doc_coverage_scheduler.py`\n  - untracked `.serena/`, `scripts/__pycache__/`\n\n## Remaining high-impact gaps\n1. Continue TODO scope migration: move known out-of-scope package docs into `docs/archive/scope_violations/` and repair cross-links.\n2. Continue Goal 2 across other in-scope package surfaces (e.g., similar signature-fidelity passes where placeholders remain).\n3. Add method-tagged tests for the corrected `fpylll` signatures/contracts so checklist boxes can be evidence-closed.\n\n## Validation\n- Documentation-only pass; no runtime test suite executed in this environment."
    }
  ],
  "structuredContent": {
    "result": "# Doc Coverage Audit Handoff (2026-02-18): fpylll signature fidelity + archive scaffold\n\n## Objectives covered\n- FIRST GOAL (cursory maintenance check): brief survey for missing in-scope package surfaces; no clear new bilinear-form lattice package surface requiring checklist creation was identified in this pass.\n- SECOND GOAL (active phase focus): tighten method contract correctness/completeness on existing in-scope `fpylll` surface (signatures, defaults, constraints, caveats, source grounding).\n- TODO queue execution: completed first two scope-cleanup scaffold items by creating archive structure + archive README and checking them off in `docs/TODO.md`.\n\n## Completed edits\n1. `docs/fpylll_methods_checklist.md`\n- Replaced placeholder/incorrect signatures with source-anchored signatures.\n- Corrected `GSO.Mat` / `MatGSO` constructor surface to include `flags=GSO_DEFAULT` and removed incorrect `precision` parameter.\n- Corrected `Enumeration(...)` constructor surface (removed unsupported `threads` parameter).\n- Expanded BKZ parameter surface with explicit argument contract and source-anchor caveat.\n- Added explicit `Pruning.run(...)`, `adjust_radius_to_gh_bound(...)`, and `gaussian_heuristic(...)` signatures.\n- Added provenance-file reference.\n\n2. `docs/fpylll/lattice/fpylll_lattice_reference.md`\n- Rewrote to canonical/source-backed contract style.\n- Added explicit method signatures, default values, and parameter constraints for core `LLL`, `BKZ`, `Enumeration`, `SVP/CVP`, `Pruning`, and utility APIs.\n- Added explicit BKZ doc-gap note: modules page does not fully render BKZ member signatures; signatures are source-anchored.\n- Removed non-canonical DeepWiki/Context7 source references and replaced with canonical upstream docs + source files.\n\n3. `docs/fpylll/upstream/fpylll_online_provenance_2026-02-18.md` (new)\n- Added dated provenance capture with canonical URLs and signature-fidelity notes used for this pass.\n\n4. `docs/archive/README.md` (new) + archive structure scaffolding\n- Added archive scope-policy README.\n- Added tracked placeholders:\n  - `docs/archive/scope_violations/.gitkeep`\n  - `docs/archive/scope_violations/upstream/.gitkeep`\n\n5. `docs/TODO.md`\n- Marked complete:\n  - create archive folder structure,\n  - add archive README.\n\n## Commit\n- `eb5d41b` — docs: tighten fpylll method contracts and add scope archive scaffold\n\n## Notes on repository state handling\n- Preserved unrelated pre-existing dirty files and did not revert/reset them:\n  - `README.md`\n  - `docs/documentation_coverage_audit_playbook.md`\n  - `prompt.md`\n  - `scripts/doc_coverage_scheduler.py`\n  - untracked `.serena/`, `scripts/__pycache__/`\n\n## Remaining high-impact gaps\n1. Continue TODO scope migration: move known out-of-scope package docs into `docs/archive/scope_violations/` and repair cross-links.\n2. Continue Goal 2 across other in-scope package surfaces (e.g., similar signature-fidelity passes where placeholders remain).\n3. Add method-tagged tests for the corrected `fpylll` signatures/contracts so checklist boxes can be evidence-closed.\n\n## Validation\n- Documentation-only pass; no runtime test suite executed in this environment."
  },
  "isError": false
}
thinking
Based on my review of the memories and TODO, the main work has been:

1. **Goal 1**: Package surface maintenance - cursory checks complete, no new bilinear-form lattice package surfaces needed.

2. **Goal 2**: Contract fidelity - various improvements have been made:
   - `automorphism_group_generators` / `automorphism_group_order` - `[PD]` → `[DEFINITE]`
   - `IntegralLattice.orthogonal_group` - `[PD]` → `[DEFINITE]`
   - Various Julia signature improvements

Now, I need to check what's currently incomplete and identify any remaining work that falls within scope. The memories and TODO indicate:

1. The "Missing Local Doc Copies" section in TODO still has several items:
   - flint (needs integration check)
   - gap (core GAP docs)
   - ntl (needs integration check)
   - fpylll (partial docs)
   - forms (partial docs)
   - g6k (partial docs)
   - crystallographic_stack (partial docs)
   - pari_gp (partial docs)

2. The remaining high-impact gaps from memories include:
   - Continue Goal 2 contract-fidelity tightening for Julia `fingrpact` stabilizer-family methods
   - Various unchecked methods in checklists

Given that I'm asked to do active work on the SECOND GOAL (contract fidelity), let me look for any remaining `[PD]` tags that might need fixing to `[DEFINITE]`, or other contract issues I can address.

Let me search for remaining `[PD]` tags that could have the same issue - methods that might say "definite" in upstream docs but are tagged as `[PD]`:
tool serena.search_for_pattern({"context_lines_after":2,"context_lines_before":2,"paths_include_glob":"docs/**/*.md","relative_path":"docs","substring_pattern":"\\[PD\\]"})
serena.search_for_pattern({"context_lines_after":2,"context_lines_before":2,"paths_include_glob":"docs/**/*.md","relative_path":"docs","substring_pattern":"\\[PD\\]"}) success in 217ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"docs/TODO.md\": [\"  >  22:- [x] Fix `IntegralLattice.orthogonal_group` definiteness constraint: tag was `[PD]` (positive definite only) but upstream docs confirm negative definite lattices also work; only indefinite lattices raise `NotImplementedError` — corrected to `[DEFINITE]` across `sage_integral_lattice_reference.md` (method table + definiteness summary) and `sagemath_lattice_reference.md` (method table + two pitfalls entries). Sourced from local upstream snapshot `free_quadratic_module_integer_symmetric.html`.\", \"  >  24:- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \\\"Given a definite lattice `L`\\\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.\"], \"docs/archive/fplll/lattice/fplll_lattice_reference.md\": [\"  >  10:| `[PD]` | Positive-definite Euclidean lattice setting |\"], \"docs/gap/lattice/gap_lattice_methods_reference.md\": [\"  >  14:| `[PD]` | Effectively positive-definite assumptions/setting |\"], \"docs/crystallographic_stack/lattice/crystallographic_stack_lattice_reference.md\": [\"  >  12:| `[PD]` | Positive-definite crystallographic regime |\"], \"docs/sage/lattice/sagemath_lattice_reference.md\": [\"  >  10:| `[PD]` | Requires or only meaningful for **positive definite** forms |\", \"  >  98:IntegralLattice(3)                                  # I_3  [PD]\", \"  >  99:IntegralLattice(\\\"E8\\\")                               # E8 root lattice  [PD]\", \"  > 199:| `IntegralLattice(n)` | Rank-n Euclidean I_n | (n,0) `[PD]` |\", \"  > 200:| `IntegralLattice(matrix.diagonal([1]*8))` | I_8 (odd unimodular) | (8,0) `[PD]` |\", \"  > 220:| `is_positive_definite()` | Positive definite test | `[PD]` |\", \"  > 282:| `voronoi_cell()` | Voronoi cell as a polytope | `[PD]` |\", \"  > 283:| `voronoi_relevant_vectors()` | Vectors defining Voronoi cell facets | `[PD]` |\", \"  > 316:| `is_positive_definite()` | All eigenvalues > 0 | `[PD]` |\", \"  > 441:| `is_positive_definite()` / `is_posdef()` | D < 0, a > 0 | `[PD]` |\", \"  > 459:| `small_prime_value()` | A small prime represented by Q | `[PD]` |\", \"  > 499:| `is_positive_definite()` | All eigenvalues > 0 | `[PD]` |\", \"  > 531:| `theta_series(prec)` | Formal theta series Σ r(n) q^n | `[PD]` |\", \"  > 614:| `representatives(backend, algorithm)` | All distinct lattices in genus (finite list); backend options include `'sage'`, `'magma'` | `[PD]` |\", \"  > 615:| `mass(backend='sage')` | Mass = Σ 1/\\\\|Aut(L)\\\\| over genus; default backend is pure Sage (no PARI/Magma required) | `[PD]` |\", \"  > 697:- **`enumerate_short_vectors()` vs `short_vectors()`**: `enumerate_short_vectors()` (new in ≥10.x, Lorenz Panny 2024) is a lazy iterator using the lattice's inner product; **it does not yield vectors in non-decreasing norm order** — vectors with larger norm may appear before vectors with smaller norm. `short_vectors(n)` (older, PARI) returns a complete list of all vectors x with (x,x) ≤ n, unordered, and is `[PD]` only. Do not use `enumerate_short_vectors()` when you need the shortest vector; use `minimum()` or `IntegerLattice.shortest_vector()` for that.\", \"  > 704:- **`theta_series`** is only mathematically convergent for `[PD]` forms; both `IntegralLattice.theta_series` and `QuadraticForm.theta_series` assume positive definiteness.\"], \"docs/sage/integral_lattice/sage_integral_lattice_reference.md\": [\"  >  10:| `[PD]` | Requires or only meaningful for **positive definite** forms |\", \"  >  42:IntegralLattice(3)                                   # I_3  [PD]\", \"  >  43:IntegralLattice(\\\"E8\\\")                                # E8 root lattice  [PD]\"], \"docs/fpylll/lattice/fpylll_lattice_reference.md\": [\"  >  10:| `[PD]` | Positive-definite Euclidean lattice regime |\"], \"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md\": [\"  >  10:| `[PD]` | Requires or only meaningful for **positive definite** forms |\", \"  > 106:| `root_lattice(:A, n)` / `(:D, n)` / `(:E, n)` / `(:I, n)` | Named root lattice | `[PD]` |\", \"  > 108:| `leech_lattice()` | Rank-24 Leech lattice | `[PD]` |\", \"  > 129:| `is_positive_definite(L)` | | `[PD]` |\", \"  > 153:| `short_vectors(L, lb, ub)` | Nonzero vectors with $lb \\\\le \\\\|v\\\\|^2 \\\\le ub$ (up to sign) | `[PD]` |\", \"  > 154:| `short_vectors_iterator(L, lb, ub)` | Lazy iterator version of `short_vectors` | `[PD]` |\", \"  > 155:| `shortest_vectors(L)` | Shortest vectors and their squared norm | `[PD]` |\", \"  > 156:| `close_vectors(L::ZZLat, v::Vector, [lb,] ub; check::Bool=false)` | Returns `Vector{Tuple{Vector{Int}, QQFieldElem}}` — lattice points $x$ with $b(v-x, v-x) \\\\le ub$; Fincke–Pohst enumeration; **`check` defaults to `false`** (not `true`) | `[PD]` |\", \"  > 158:| `vectors_of_square_and_divisibility(L, n, d)` | Vectors $v$ with $v^2 = n$ and divisibility $d$ in $L$ | `[PD]` |\", \"  > 159:| `enumerate_quadratic_triples(L, ...)` | Enumerate quadratic solutions in lattice | `[PD]` |\", \"  > 160:| `minimum(L)` | Squared length of shortest nonzero vector | `[PD]` |\", \"  > 161:| `kissing_number(L)` | Number of shortest vectors | `[PD]` |\", \"  > 220:| `Hecke.quadratic_lattice_database()` | DB of lattices rank ≥ 3 with class number 1 or 2 | `[PD]` |\", \"  > 233:| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\", \"  > 234:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |\", \"  > 293:| `root_lattice_recognition(L)` | Identify ADE type of root sublattice | `[PD]` |\", \"  > 294:| `root_lattice_recognition_fundamental(L)` | Find fundamental root system | `[PD]` |\", \"  > 295:| `ADE_type(L)` | Determine root lattice type | `[PD]` |\", \"  > 296:| `coxeter_number(L)` | Coxeter number | `[PD]` |\", \"  > 297:| `highest_root(L)` | Highest root coordinates | `[PD]` |\", \"  > 421:| `minimum(Lf)` | Minimum of the underlying lattice; same positive-definite precondition as `minimum(L)` | `[PD]` |\", \"  > 793:No Julia package automates theta series computation. Use `short_vectors(L, 0, N)` in Hecke to count vectors by norm and assemble $\\\\Theta_L(q) = \\\\sum_{v \\\\in L} q^{|v|^2}$ manually. No `theta_series(L, precision)` function yet. No package for Eisenstein series or Siegel theta constants; use PARI/GP via Nemo for deeper analysis. `[PD]`\"], \"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md\": [\"  >  10:| `[PD]` | Positive-definite setting |\"], \"docs/pari_gp/lattice/pari_gp_lattice_reference.md\": [\"  >  10:| `[PD]` | Positive-definite assumptions |\"]}"
    }
  ],
  "structuredContent": {
    "result": "{\"docs/TODO.md\": [\"  >  22:- [x] Fix `IntegralLattice.orthogonal_group` definiteness constraint: tag was `[PD]` (positive definite only) but upstream docs confirm negative definite lattices also work; only indefinite lattices raise `NotImplementedError` — corrected to `[DEFINITE]` across `sage_integral_lattice_reference.md` (method table + definiteness summary) and `sagemath_lattice_reference.md` (method table + two pitfalls entries). Sourced from local upstream snapshot `free_quadratic_module_integer_symmetric.html`.\", \"  >  24:- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \\\"Given a definite lattice `L`\\\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.\"], \"docs/archive/fplll/lattice/fplll_lattice_reference.md\": [\"  >  10:| `[PD]` | Positive-definite Euclidean lattice setting |\"], \"docs/gap/lattice/gap_lattice_methods_reference.md\": [\"  >  14:| `[PD]` | Effectively positive-definite assumptions/setting |\"], \"docs/crystallographic_stack/lattice/crystallographic_stack_lattice_reference.md\": [\"  >  12:| `[PD]` | Positive-definite crystallographic regime |\"], \"docs/sage/lattice/sagemath_lattice_reference.md\": [\"  >  10:| `[PD]` | Requires or only meaningful for **positive definite** forms |\", \"  >  98:IntegralLattice(3)                                  # I_3  [PD]\", \"  >  99:IntegralLattice(\\\"E8\\\")                               # E8 root lattice  [PD]\", \"  > 199:| `IntegralLattice(n)` | Rank-n Euclidean I_n | (n,0) `[PD]` |\", \"  > 200:| `IntegralLattice(matrix.diagonal([1]*8))` | I_8 (odd unimodular) | (8,0) `[PD]` |\", \"  > 220:| `is_positive_definite()` | Positive definite test | `[PD]` |\", \"  > 282:| `voronoi_cell()` | Voronoi cell as a polytope | `[PD]` |\", \"  > 283:| `voronoi_relevant_vectors()` | Vectors defining Voronoi cell facets | `[PD]` |\", \"  > 316:| `is_positive_definite()` | All eigenvalues > 0 | `[PD]` |\", \"  > 441:| `is_positive_definite()` / `is_posdef()` | D < 0, a > 0 | `[PD]` |\", \"  > 459:| `small_prime_value()` | A small prime represented by Q | `[PD]` |\", \"  > 499:| `is_positive_definite()` | All eigenvalues > 0 | `[PD]` |\", \"  > 531:| `theta_series(prec)` | Formal theta series Σ r(n) q^n | `[PD]` |\", \"  > 614:| `representatives(backend, algorithm)` | All distinct lattices in genus (finite list); backend options include `'sage'`, `'magma'` | `[PD]` |\", \"  > 615:| `mass(backend='sage')` | Mass = Σ 1/\\\\|Aut(L)\\\\| over genus; default backend is pure Sage (no PARI/Magma required) | `[PD]` |\", \"  > 697:- **`enumerate_short_vectors()` vs `short_vectors()`**: `enumerate_short_vectors()` (new in ≥10.x, Lorenz Panny 2024) is a lazy iterator using the lattice's inner product; **it does not yield vectors in non-decreasing norm order** — vectors with larger norm may appear before vectors with smaller norm. `short_vectors(n)` (older, PARI) returns a complete list of all vectors x with (x,x) ≤ n, unordered, and is `[PD]` only. Do not use `enumerate_short_vectors()` when you need the shortest vector; use `minimum()` or `IntegerLattice.shortest_vector()` for that.\", \"  > 704:- **`theta_series`** is only mathematically convergent for `[PD]` forms; both `IntegralLattice.theta_series` and `QuadraticForm.theta_series` assume positive definiteness.\"], \"docs/sage/integral_lattice/sage_integral_lattice_reference.md\": [\"  >  10:| `[PD]` | Requires or only meaningful for **positive definite** forms |\", \"  >  42:IntegralLattice(3)                                   # I_3  [PD]\", \"  >  43:IntegralLattice(\\\"E8\\\")                                # E8 root lattice  [PD]\"], \"docs/fpylll/lattice/fpylll_lattice_reference.md\": [\"  >  10:| `[PD]` | Positive-definite Euclidean lattice regime |\"], \"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md\": [\"  >  10:| `[PD]` | Requires or only meaningful for **positive definite** forms |\", \"  > 106:| `root_lattice(:A, n)` / `(:D, n)` / `(:E, n)` / `(:I, n)` | Named root lattice | `[PD]` |\", \"  > 108:| `leech_lattice()` | Rank-24 Leech lattice | `[PD]` |\", \"  > 129:| `is_positive_definite(L)` | | `[PD]` |\", \"  > 153:| `short_vectors(L, lb, ub)` | Nonzero vectors with $lb \\\\le \\\\|v\\\\|^2 \\\\le ub$ (up to sign) | `[PD]` |\", \"  > 154:| `short_vectors_iterator(L, lb, ub)` | Lazy iterator version of `short_vectors` | `[PD]` |\", \"  > 155:| `shortest_vectors(L)` | Shortest vectors and their squared norm | `[PD]` |\", \"  > 156:| `close_vectors(L::ZZLat, v::Vector, [lb,] ub; check::Bool=false)` | Returns `Vector{Tuple{Vector{Int}, QQFieldElem}}` — lattice points $x$ with $b(v-x, v-x) \\\\le ub$; Fincke–Pohst enumeration; **`check` defaults to `false`** (not `true`) | `[PD]` |\", \"  > 158:| `vectors_of_square_and_divisibility(L, n, d)` | Vectors $v$ with $v^2 = n$ and divisibility $d$ in $L$ | `[PD]` |\", \"  > 159:| `enumerate_quadratic_triples(L, ...)` | Enumerate quadratic solutions in lattice | `[PD]` |\", \"  > 160:| `minimum(L)` | Squared length of shortest nonzero vector | `[PD]` |\", \"  > 161:| `kissing_number(L)` | Number of shortest vectors | `[PD]` |\", \"  > 220:| `Hecke.quadratic_lattice_database()` | DB of lattices rank ≥ 3 with class number 1 or 2 | `[PD]` |\", \"  > 233:| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\", \"  > 234:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |\", \"  > 293:| `root_lattice_recognition(L)` | Identify ADE type of root sublattice | `[PD]` |\", \"  > 294:| `root_lattice_recognition_fundamental(L)` | Find fundamental root system | `[PD]` |\", \"  > 295:| `ADE_type(L)` | Determine root lattice type | `[PD]` |\", \"  > 296:| `coxeter_number(L)` | Coxeter number | `[PD]` |\", \"  > 297:| `highest_root(L)` | Highest root coordinates | `[PD]` |\", \"  > 421:| `minimum(Lf)` | Minimum of the underlying lattice; same positive-definite precondition as `minimum(L)` | `[PD]` |\", \"  > 793:No Julia package automates theta series computation. Use `short_vectors(L, 0, N)` in Hecke to count vectors by norm and assemble $\\\\Theta_L(q) = \\\\sum_{v \\\\in L} q^{|v|^2}$ manually. No `theta_series(L, precision)` function yet. No package for Eisenstein series or Siegel theta constants; use PARI/GP via Nemo for deeper analysis. `[PD]`\"], \"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md\": [\"  >  10:| `[PD]` | Positive-definite setting |\"], \"docs/pari_gp/lattice/pari_gp_lattice_reference.md\": [\"  >  10:| `[PD]` | Positive-definite assumptions |\"]}"
  },
  "isError": false
}
thinking
Now I have a clear picture. The remaining `[PD]` tags in the Julia lattice references are:
1. `is_isometric(L1, L2)` - tagged `[PD]`
2. `is_isometric_with_isometry(L1, L2)` - tagged `[PD]`

The previous memory noted this as something that "may warrant a review." Let me verify against upstream if these methods actually support indefinite or definite (PD or ND) lattices.

Let me search the upstream docs more directly.
exec
/bin/bash -lc 'curl -sL "https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/" 2>&1 | grep -i "isometric" | head -10' in /home/dzack/lattice_interface succeeded in 51ms:
Total output lines: 3

                                                      -&gt; Vector{MatElem}</code></pre><p>Given a definite lattice <code>L</code>, return generators for the automorphism group of <code>L</code>. If <code>ambient_representation == true</code> (the default), the transformations are represented with respect to the ambient space of <code>L</code>. Otherwise, the transformations are represented with respect to the (pseudo-)basis of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1526-L1539">source</a></section></details></article><article><details class="docstring"><summary id="automorphism_group_order-Tuple{ZZLat}"><a class="docstring-binding" href="#automorphism_group_order-Tuple{ZZLat}"><code>automorphism_group_order</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">automorphism_group_order(L::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -&gt; Int</code></pre><p>Given a definite lattice <code>L</code>, return the order of the automorphism group of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve perf…1199 tokens truncated…sometric to the lattice <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1650-L1666">source</a></section></details></article><article><details class="docstring"><summary id="maximal_integral_lattice-Tuple{ZZLat}"><a class="docstring-binding" href="#maximal_integral_lattice-Tuple{ZZLat}"><code>maximal_integral_lattice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">maximal_integral_lattice(L::AbstractLat) -&gt; AbstractLat</code></pre><p>Given a lattice <code>L</code> with integral norm, return a maximal integral overlattice <code>M</code> of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L2022-L2027">source</a></section></details></article><h3 id="Sublattices-defined-by-endomorphisms"><a class="docs-heading-anchor" href="#Sublattices-defined-by-endomorphisms">Sublattices defined by endomorphisms</a><a id="Sublattices-defined-by-endomorphisms-1"></a><a class="docs-heading-anchor-permalink" href="#Sublattices-defined-by-endomorphisms" title="Permalink"></a></h3><article><details class="docstring"><summary id="kernel_lattice-Tuple{ZZLat, MatElem}"><a class="docstring-binding" href="#kernel_lattice-Tuple{ZZLat, MatElem}"><code>kernel_lattice</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kernel_lattice(L::ZZLat, f::MatElem;
thinking
The grep results are truncated, but I can see at least one key finding: `automorphism_group_order(L::AbstractLat)` says "Given a definite lattice L". And I saw earlier in the truncated output there was something about `is_isometric` with "isometric to the lattice L". Let me refine the query to get more context on is_isometric specifically.
exec
/bin/bash -lc "curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -A10 \"is_isometric.*definite\\|definite.*is_isometric\"" in /home/dzack/lattice_interface succeeded in 51ms:
Total output lines: 11

                                                      -&gt; Vector{MatElem}</code></pre><p>Given a definite lattice <code>L</code>, return generators for the automorphism group of <code>L</code>. If <code>ambient_representation == true</code> (the default), the transformations are represented with respect to the ambient space of <code>L</code>. Otherwise, the transformations are represented with respect to the (pseudo-)basis of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1526-L1539">source</a></section></details></article><article><details class="docstring"><summary id="automorphism_group_order-Tuple{ZZLat}"><a class="docstring-binding" href="#automorphism_group_order-Tuple{ZZLat}"><code>automorphism_group_order</code></a> — <span class="docstring-category"…815 tokens truncated…ce spanned by the vectors of squared length <span>$1$</span> and <span>$2$</span>.  The odd lattice of rank 1 and determinant <span>$1$</span> is denoted by <code>(:I, 1)</code>.</p><p>Input:</p><p><code>L</code> – a definite and integral <span>$\mathbb{Z}$</span>-lattice.</p><p>Output:</p><p>Two lists, the first one containing the ADE types and the second one the irreducible root sublattices.</p><p>For more recognizable gram matrices use <a href="#root_lattice_recognition_fundamental-Tuple{ZZLat}"><code>root_lattice_recognition_fundamental</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = integer_lattice(; gram=ZZ[4  0 0  0 3  0 3  0;
                                     0 16 8 12 2 12 6 10;
                                     0  8 8  6 2  8 4  5;
                                     0 12 6 10 2  9 5  8;
                                     3  2 2  2 4  2 4  2;
                                     0 12 8  9 2 12 6  9;
                                     3  6 4  5 4  6 6  5;
                                     0 10 5  8 2  9 5  8])
Integer lattice of rank 8 and degree 8
with gram matrix
[4    0   0    0   3    0   3    0]
thinking
The grep didn't show me the is_isometric contract directly, but I saw "isometric to the lattice L" in the output. Let me try another approach - search for the specific method signature with curl and extract just the description.
exec
/bin/bash -lc "curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -oP 'is_isometric.*?(?=<|</summary)' | head -5" in /home/dzack/lattice_interface succeeded in 63ms:
is_isometric-Tuple{ZZLat, ZZLat}">
is_isometric-Tuple{ZZLat, ZZLat}">
is_isometric
is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -&gt; Bool
thinking
Good, I found the signature: `is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -> Bool`. Let me get more context about the precondition.
exec
/bin/bash -lc "curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -A15 'is_isometric.*AbstractLat.*AbstractLat' | head -20" in /home/dzack/lattice_interface succeeded in 50ms:
Total output lines: 16

                                                      -&gt; Vector{MatElem}</code></pre><p>Given a definite lattice <code>L</code>, return generators for the automorphism group of <code>L</code>. If <code>ambient_representation == true</code> (the default), the transformations are represented with respect to the ambient space of <code>L</code>. Otherwise, the transformations are represented with respect to the (pseudo-)basis of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1526-L1539">source</a></section></details></article><article><details class="docstring"><summary id="automorphism_group_order-Tuple{ZZLat}"><a class="docstring-binding" href="#automorphism_group_order-Tuple{ZZLat}"><code>automorphism_group_order</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">automorphism_group_order(L::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -&gt; Int</code></pre><p>Given a definite lattice <code>L</code>, return the order of the automorphism group of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve perf…660 tokens truncated…</span></summary><section><div><pre><code class="language-julia hljs">root_lattice_recognition(L::ZZLat)</code></pre><p>Return the ADE type of the root sublattice of <code>L</code>.</p><p>The root sublattice is the lattice spanned by the vectors of squared length <span>$1$</span> and <span>$2$</span>.  The odd lattice of rank 1 and determinant <span>$1$</span> is denoted by <code>(:I, 1)</code>.</p><p>Input:</p><p><code>L</code> – a definite and integral <span>$\mathbb{Z}$</span>-lattice.</p><p>Output:</p><p>Two lists, the first one containing the ADE types and the second one the irreducible root sublattices.</p><p>For more recognizable gram matrices use <a href="#root_lattice_recognition_fundamental-Tuple{ZZLat}"><code>root_lattice_recognition_fundamental</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = integer_lattice(; gram=ZZ[4  0 0  0 3  0 3  0;
                                     0 16 8 12 2 12 6 10;
                                     0  8 8  6 2  8 4  5;
                                     0 12 6 10 2  9 5  8;
                                     3  2 2  2 4  2 4  2;
                                     0 12 8  9 2 12 6  9;
                                     3  6 4  5 4  6 6  5;
                                     0 10 5  8 2  9 5  8])
Integer lattice of rank 8 and degree 8
with gram matrix
[4    0   0    0   3    0   3    0]
[0   16   8   12   2   12   6   10]
[0    8   8    6   2    8   4    5]
[0   12   6   10   2    9   5    8]
[3    2   2    2   4    2   4    2]
[0   12   8    9   2   12   6    9]
thinking
Let me try a more targeted search for the is_isometric docstring:
exec
/bin/bash -lc "curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | sed -n '/is_isometric/,/<\\/article>/p' | head -25" in /home/dzack/lattice_interface succeeded in 51ms:
Total output lines: 25

                                                      -&gt; Vector{MatElem}</code></pre><p>Given a definite lattice <code>L</code>, return generators for the automorphism group of <code>L</code>. If <code>ambient_representation == true</code> (the default), the transformations are represented with respect to the ambient space of <code>L</code>. Otherwise, the transformations are represented with respect to the (pseudo-)basis of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1526-L1539">source</a></section></details></article><article><details class="docstring"><summary id="automorphism_group_order-Tuple{ZZLat}"><a class="docstring-binding" href="#automorphism_group_order-Tuple{ZZLat}"><code>automorphism_group_order</code></a> — <span class="docstring-category"…954 tokens truncated…></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = integer_lattice(; gram=ZZ[4  0 0  0 3  0 3  0;
                                     0 16 8 12 2 12 6 10;
                                     0  8 8  6 2  8 4  5;
                                     0 12 6 10 2  9 5  8;
                                     3  2 2  2 4  2 4  2;
                                     0 12 8  9 2 12 6  9;
                                     3  6 4  5 4  6 6  5;
                                     0 10 5  8 2  9 5  8])
Integer lattice of rank 8 and degree 8
with gram matrix
[4    0   0    0   3    0   3    0]
[0   16   8   12   2   12   6   10]
[0    8   8    6   2    8   4    5]
[0   12   6   10   2    9   5    8]
[3    2   2    2   4    2   4    2]
[0   12   8    9   2   12   6    9]
[3    6   4    5   4    6   6    5]
[0   10   5    8   2    9   5    8]
thinking
The search is capturing too much. Let me try to target only the is_isometric method section more directly. The output shows it has `is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -> Bool` but I need to see the full description to determine if there's a definiteness constraint.
exec
/bin/bash -lc "curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -A25 'id=\"is_isometric-Tuple{ZZLat' | head -30" in /home/dzack/lattice_interface succeeded in 62ms:
                                                      -&gt; Vector{MatElem}</code></pre><p>Given a definite lattice <code>L</code>, return generators for the automorphism group of <code>L</code>. If <code>ambient_representation == true</code> (the default), the transformations are represented with respect to the ambient space of <code>L</code>. Otherwise, the transformations are represented with respect to the (pseudo-)basis of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1526-L1539">source</a></section></details></article><article><details class="docstring"><summary id="automorphism_group_order-Tuple{ZZLat}"><a class="docstring-binding" href="#automorphism_group_order-Tuple{ZZLat}"><code>automorphism_group_order</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">automorphism_group_order(L::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -&gt; Int</code></pre><p>Given a definite lattice <code>L</code>, return the order of the automorphism group of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1583-L1591">source</a></section></details></article><article><details class="docstring"><summary id="is_isometric-Tuple{ZZLat, ZZLat}"><a class="docstring-binding" href="#is_isometric-Tuple{ZZLat, ZZLat}"><code>is_isometric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -&gt; Bool</code></pre><p>Return whether the lattices <code>L</code> and <code>M</code> are isometric.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1610-L1618">source</a></section></details></article><article><details class="docstring"><summary id="is_locally_isometric-Tuple{ZZLat, ZZLat, Int64}"><a class="docstring-binding" href="#is_locally_isometric-Tuple{ZZLat, ZZLat, Int64}"><code>is_locally_isometric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_locally_isometric(L::ZZLat, M::ZZLat, p::Int) -&gt; Bool</code></pre><p>Return whether <code>L</code> and <code>M</code> are isometric over the <code>p</code>-adic integers.</p><p>i.e. whether <span>$L \otimes \mathbb{Z}_p \cong M\otimes \mathbb{Z}_p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1213-L1219">source</a></section></details></article><h1 id="Root-lattices"><a class="docs-heading-anchor" href="#Root-lattices">Root lattices</a><a id="Root-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Root-lattices" title="Permalink"></a></h1><article><details class="docstring"><summary id="root_lattice_recognition-Tuple{ZZLat}"><a class="docstring-binding" href="#root_lattice_recognition-Tuple{ZZLat}"><code>root_lattice_recognition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">root_lattice_recognition(L::ZZLat)</code></pre><p>Return the ADE type of the root sublattice of <code>L</code>.</p><p>The root sublattice is the lattice spanned by the vectors of squared length <span>$1$</span> and <span>$2$</span>.  The odd lattice of rank 1 and determinant <span>$1$</span> is denoted by <code>(:I, 1)</code>.</p><p>Input:</p><p><code>L</code> – a definite and integral <span>$\mathbb{Z}$</span>-lattice.</p><p>Output:</p><p>Two lists, the first one containing the ADE types and the second one the irreducible root sublattices.</p><p>For more recognizable gram matrices use <a href="#root_lattice_recognition_fundamental-Tuple{ZZLat}"><code>root_lattice_recognition_fundamental</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = integer_lattice(; gram=ZZ[4  0 0  0 3  0 3  0;
                                     0 16 8 12 2 12 6 10;
                                     0  8 8  6 2  8 4  5;
                                     0 12 6 10 2  9 5  8;
                                     3  2 2  2 4  2 4  2;
                                     0 12 8  9 2 12 6  9;
                                     3  6 4  5 4  6 6  5;
                                     0 10 5  8 2  9 5  8])
Integer lattice of rank 8 and degree 8
with gram matrix
[4    0   0    0   3    0   3    0]
[0   16   8   12   2   12   6   10]
[0    8   8    6   2    8   4    5]
[0   12   6   10   2    9   5    8]
[3    2   2    2   4    2   4    2]
[0   12   8    9   2   12   6    9]
[3    6   4    5   4    6   6    5]
[0   10   5    8   2    9   5    8]

julia&gt; R = root_lattice_recognition(L)
thinking
Let me check the local snapshots instead for `is_isometric` contract.
tool serena.find_file({"file_mask":"*isom*.md","relative_path":"docs/julia/oscar_jl/number_theory"})
serena.find_file({"file_mask":"*isom*.md","relative_path":"docs/julia/oscar_jl/number_theory"}) success in 640ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"files\": [\"docs/julia/oscar_jl/number_theory/quad_form_and_isom/spacewithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/torquadmodwithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom_online_provenance_2026-02-17.md\"]}"
    }
  ],
  "structuredContent": {
    "result": "{\"files\": [\"docs/julia/oscar_jl/number_theory/quad_form_and_isom/spacewithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/torquadmodwithisom.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md\", \"docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom_online_provenance_2026-02-17.md\"]}"
  },
  "isError": false
}
thinking
Let me check what content is in one of these local provenance files - they might have captured the `is_isometric` constraints.
tool serena.search_for_pattern({"context_lines_after":5,"context_lines_before":3,"paths_include_glob":"*.md","relative_path":"docs/julia/oscar_jl/number_theory","substring_pattern":"is_isometric"})
serena.search_for_pattern({"context_lines_after":5,"context_lines_before":3,"paths_include_glob":"*.md","relative_path":"docs/julia/oscar_jl/number_theory","substring_pattern":"is_isometric"}) success in 77ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md\": [\"  >  83:  - `is_isometric_with_isometry(L, M; depth=3, bacher_depth=5, ambient_representation=true)` has explicit tuple-return contract:\", \"  >  86:  - `is_isometric_with_isometry(T, U)` / `is_anti_isometric_with_anti_isometry(T, U)` on finite quadratic modules are documented with tuple-return shape and explicit preconditions:\"]}"
    }
  ],
  "structuredContent": {
    "result": "{\"docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md\": [\"  >  83:  - `is_isometric_with_isometry(L, M; depth=3, bacher_depth=5, ambient_representation=true)` has explicit tuple-return contract:\", \"  >  86:  - `is_isometric_with_isometry(T, U)` / `is_anti_isometric_with_anti_isometry(T, U)` on finite quadratic modules are documented with tuple-return shape and explicit preconditions:\"]}"
  },
  "isError": false
}
thinking
I should use the local snapshot to find the exact is_isometric documentation. Let me look at the local snapshot:
tool serena.execute_shell_command({"command":"find /home/dzack/lattice_interface/docs -name \"*.html\" -path \"*/upstream/*\" | xargs grep -l \"is_isometric\" 2>/dev/null | head -5","cwd":"/home/dzack/lattice_interface","max_answer_chars":2000})
serena.execute_shell_command({"command":"find /home/dzack/lattice_interface/docs -name \"*.html\" -path \"*/upstream/*\" | xargs grep -l \"is_isometric\" 2>/dev/null | head -5","cwd":"/home/dzack/lattice_interface","max_answer_chars":2000}) success in 182ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"stdout\":\"\",\"return_code\":0,\"cwd\":\"/home/dzack/lattice_interface\",\"stderr\":\"\"}"
    }
  ],
  "structuredContent": {
    "result": "{\"stdout\":\"\",\"return_code\":0,\"cwd\":\"/home/dzack/lattice_interface\",\"stderr\":\"\"}"
  },
  "isError": false
}
thinking
Let me check whether there's a source anchor for `is_isometric` in Julia - the hint from the grep earlier shows it has typed signature with depth/bacher_depth kwargs:
exec
/bin/bash -lc "curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -oP 'is_isometric\\(["'^)]+'"\\).*?->.*?(?=<)' | head -3" in /home/dzack/lattice_interface succeeded in 144ms:

thinking
Let me try a different approach - maybe search for the specific method in the Hecke source code.
exec
/bin/bash -lc 'curl -sL "https://raw.githubusercontent.com/thofma/Hecke.jl/v0.39.12/src/QuadForm/Quad/ZLattices.jl" 2>&1 | grep -A20 "''^function is_isometric" | head -30' in /home/dzack/lattice_interface succeeded in 342ms:

thinking
Let me check the actual Hecke source code by downloading a specific version tag:
exec
/bin/bash -lc 'curl -sL "https://raw.githubusercontent.com/thofma/Hecke.jl/v0.39.12/src/QuadForm/Lattices.jl" 2>&1 | grep -A25 "''^    function is_isometric" | head -35' in /home/dzack/lattice_interface succeeded in 314ms:

thinking
The curl commands are not returning content - let me try without the specific version:
exec
/bin/bash -lc 'curl -sL "https://raw.githubusercontent.com/thofma/Hecke.jl/master/src/QuadForm/Lattices.jl" 2>&1 | grep -A20 "''^    function is_isometric" | head -30' in /home/dzack/lattice_interface succeeded in 295ms:

thinking
Let me try a simpler approach - search GitHub API differently:
exec
/bin/bash -lc 'curl -sL "https://api.github.com/repos/thofma/Hecke.jl/contents/src/QuadForm/Lattices.jl" 2>&1 | head -20' in /home/dzack/lattice_interface succeeded in 748ms:
{
  "name": "Lattices.jl",
  "path": "src/QuadForm/Lattices.jl",
  "sha": "2e0dca50541f710c88043fff2c95580fd3049d61",
  "size": 69680,
  "url": "https://api.github.com/repos/thofma/Hecke.jl/contents/src/QuadForm/Lattices.jl?ref=master",
  "html_url": "https://github.com/thofma/Hecke.jl/blob/master/src/QuadForm/Lattices.jl",
  "git_url": "https://api.github.com/repos/thofma/Hecke.jl/git/blobs/2e0dca50541f710c88043fff2c95580fd3049d61",
  "download_url": "https://raw.githubusercontent.com/thofma/Hecke.jl/master/src/QuadForm/Lattices.jl",
  "type": "file",
  "content": "IyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIwojICBBbWJp\nZW50IHNwYWNlCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMKCkBkb2MgcmF3IiIiCiAgICBoYXNfYW1iaWVudF9zcGFjZShMOjpBYnN0\ncmFjdExhdCkgLT4gQm9vbAoKUmV0dXJuIHdoZXRoZXIgdGhlIGFtYmllbnQg\nc3BhY2Ugb2YgdGhlIGxhdHRpY2UgYExgIGlzIHNldC4KIiIiCmZ1bmN0aW9u\nIGhhc19hbWJpZW50X3NwYWNlKEw6OkFic3RyYWN0TGF0KQogIHJldHVybiBp\nc2RlZmluZWQoTCwgOnNwYWNlKQplbmQKCkBkb2MgcmF3IiIiCiAgICBhbWJp\nZW50X3NwYWNlKEw6OkFic3RyYWN0TGF0KSAtPiBBYnN0cmFjdFNwYWNlCgpS\nZXR1cm4gdGhlIGFtYmllbnQgc3BhY2Ugb2YgdGhlIGxhdHRpY2UgYExgLiBJ\nZiB0aGUgYW1iaWVudCBzcGFjZSBpcyBub3Qga25vd24sIGFuCmVycm9yIGlz\nIHJhaXNlZC4KIiIiCmZ1bmN0aW9uIGFtYmllbnRfc3BhY2UoTDo6QWJzdHJh\nY3RMYXQpCiAgaWYgIWhhc19hbWJpZW50X3NwYWNlKEwpCiAgICBCID0gbWF0\ncml4KHBzZXVkb19tYXRyaXgoTCkpCiAgICBAYXNzZXJ0IGlzb25lKEIpCiAg\nICBMLnNwYWNlID0gcmF0aW9uYWxfc3BhbihMKQogIGVuZAogIHJldHVybiBM\nLnNwYWNlCmVuZAoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMKIwojICBSYXRpb25hbCBzcGFuCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMKCkBkb2MgcmF3IiIiCiAgICByYXRpb25hbF9zcGFu\nKEw6OkFic3RyYWN0TGF0KSAtPiBBYnN0cmFjdFNwYWNlCgpSZXR1cm4gdGhl\nIHJhdGlvbmFsIHNwYW4gb2YgdGhlIGxhdHRpY2UgYExgLgoiIiIKcmF0aW9u\nYWxfc3Bhbig6OkFic3RyYWN0TGF0KQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMKIwojICBEaWFnb25hbAojCiMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpAZG9jIHJhdyIiIgogICAgZGlhZ29u\nYWxfb2ZfcmF0aW9uYWxfc3BhbihMOjpBYnN0cmFjdExhdCkgLT4gVmVjdG9y\nCgpSZXR1cm4gdGhlIGRpYWdvbmFsIG9mIHRoZSByYXRpb25hbCBzcGFuIG9m\nIHRoZSBsYXR0aWNlIGBMYC4KIiIiCmZ1bmN0aW9uIGRpYWdvbmFsX29mX3Jh\ndGlvbmFsX3NwYW4oTDo6QWJzdHJhY3RMYXQpCiAgRCwgXyA9IF9ncmFtX3Nj\naG1pZHQoZ3JhbV9tYXRyaXhfb2ZfcmF0aW9uYWxfc3BhbihMKSwgaW52b2x1\ndGlvbihMKSkKICByZXR1cm4gZGlhZ29uYWwoRCkKZW5kCgojIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMgIE1vZHVsZSBwcm9wZXJ0\naWVzCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCkBk\nb2MgcmF3IiIiCiAgICBwc2V1ZG9fbWF0cml4KEw6OkFic3RyYWN0TGF0KSAt\nPiBQTWF0CgpSZXR1cm4gYSBiYXNpcyBwc2V1ZG8tbWF0cml4IG9mIHRoZSBs\nYXR0aWNlIGBMYC4KIiIiCnBzZXVkb19tYXRyaXgoTDo6QWJzdHJhY3RMYXQp\nID0gTC5wbWF0CgpAZG9jIHJhdyIiIgogICAgcHNldWRvX2Jhc2lzKEw6OkFi\nc3RyYWN0TGF0KSAtPiBWZWN0b3J7VHVwbGV7VmVjdG9yLCBJZGVhbH19CgpS\nZXR1cm4gYSBwc2V1ZG8tYmFzaXMgb2YgdGhlIGxhdHRpY2UgYExgLgoiIiIK\nZnVuY3Rpb24gcHNldWRvX2Jhc2lzKEw6OkFic3RyYWN0TGF0KQogIE0gPSBt\nYXRyaXgocHNldWRvX21hdHJpeChMKSkKICBMcE0gPSBwc2V1ZG9fbWF0cml4\nKEwpCiAgTyA9IGJhc2VfcmluZyhMcE0pCiAgeiA9IFZlY3RvcntUdXBsZXtW\nZWN0b3J7ZWxlbV90eXBlKG5mKE8pKX0sIGZyYWN0aW9uYWxfaWRlYWxfdHlw\nZShPKX19KHVuZGVmLCBucm93cyhNKSkKICBmb3IgaSBpbiAxOm5yb3dzKE0p\nCiAgICB6W2ldID0gKGVsZW1fdHlwZShiYXNlX3JpbmcoTSkpWyBNW2ksIGpd\nIGZvciBqIGluIDE6bmNvbHMoTSkgXSwKICAgICAgICAgICAgY29lZmZpY2ll\nbnRfaWRlYWxzKExwTSlbaV0pCiAgZW5kCiAgcmV0dXJuIHoKZW5kCgpAZG9j\nIHJhdyIiIgogICAgY29lZmZpY2llbnRfaWRlYWxzKEw6OkFic3RyYWN0TGF0\nKSAtPiBWZWN0b3J7QWJzTnVtRmllbGRPcmRlcklkZWFse0Fic1NpbXBsZU51\nbUZpZWxkLCBBYnNTaW1wbGVOdW1GaWVsZEVsZW19fQoKUmV0dXJuIHRoZSBj\nb2VmZmljaWVudCBpZGVhbHMgb2YgYSBwc2V1ZG8tYmFzaXMgb2YgdGhlIGxh\ndHRpY2UgYExgLgoiIiIKY29lZmZpY2llbnRfaWRlYWxzKEw6OkFic3RyYWN0\nTGF0KSA9IGNvZWZmaWNpZW50X2lkZWFscyhwc2V1ZG9fbWF0cml4KEwpKQoK\nQGRvYyByYXciIiIKICAgIGJhc2lzX21hdHJpeF9vZl9yYXRpb25hbF9zcGFu\nKEw6OkFic3RyYWN0TGF0KSAtPiBNYXRFbGVtCgpSZXR1cm4gYSBiYXNpcyBt\nYXRyaXggb2YgdGhlIHJhdGlvbmFsIHNwYW4gb2YgdGhlIGxhdHRpY2UgYExg\nLgoiIiIKYmFzaXNfbWF0cml4X29mX3JhdGlvbmFsX3NwYW4oTDo6QWJzdHJh\nY3RMYXQpID0gbWF0cml4KHBzZXVkb19tYXRyaXgoTCkpCgpAZG9jIHJhdyIi\nIgogICAgYmFzZV9maWVsZChMOjpBYnN0cmFjdExhdCkgLT4gRmllbGQKClJl\ndHVybiB0aGUgYWxnZWJyYSBvdmVyIHdoaWNoIHRoZSByYXRpb25hbCBzcGFu\nIG9mIHRoZSBsYXR0aWNlIGBMYCBpcyBkZWZpbmVkLgoiIiIKYmFzZV9maWVs\nZChMOjpBYnN0cmFjdExhdCkgPSBMLmJhc2VfYWxnZWJyYQoKQGRvYyByYXci\nIiIKICAgIGJhc2VfcmluZyhMOjpBYnN0cmFjdExhdCkgLT4gUmluZwoKUmV0\ndXJuIHRoZSBvcmRlciBvdmVyIHdoaWNoIHRoZSBsYXR0aWNlIGBMYCBpcyBk\nZWZpbmVkLgoiIiIKYmFzZV9yaW5nKEw6OkFic3RyYWN0TGF0KSA9IGJhc2Vf\ncmluZyhMLnBtYXQpCgpAZG9jIHJhdyIiIgogICAgZml4ZWRfZmllbGQoTDo6\nQWJzdHJhY3RMYXQpIC0+IEZpZWxkCgpSZXR1cm5zIHRoZSBmaXhlZCBmaWVs\nZCBvZiB0aGUgaW52b2x1dGlvbiBvZiB0aGUgbGF0dGljZSBgTGAuCiIiIgpm\naXhlZF9maWVsZChMOjpBYnN0cmFjdExhdCkgPSBmaXhlZF9maWVsZChyYXRp\nb25hbF9zcGFuKEwpKQoKQGRvYyByYXciIiIKICAgIGZpeGVkX3JpbmcoTDo6\nQWJzdHJhY3RMYXQpIC0+IFJpbmcKClJldHVybiB0aGUgbWF4aW1hbCBvcmRl\nciBpbiB0aGUgZml4ZWQgZmllbGQgb2YgdGhlIGxhdHRpY2UgYExgLgoiIiIK\nZml4ZWRfcmluZyhMOjpBYnN0cmFjdExhdCkgPSBtYXhpbWFsX29yZGVyKGZp\neGVkX2ZpZWxkKEwpKQoKQGRvYyByYXciIiIKICAgIGludm9sdXRpb24oTDo6\nQWJzdHJhY3RMYXQpIC0+IE1hcAoKUmV0dXJuIHRoZSBpbnZvbHV0aW9uIG9m\nIHRoZSByYXRpb25hbCBzcGFuIG9mIHRoZSBsYXR0aWNlIGBMYC4KIiIiCmlu\ndm9sdXRpb24oOjpBYnN0cmFjdExhdCkKCkBkb2MgcmF3IiIiCiAgICByYW5r\nKEw6OkFic3RyYWN0TGF0KSAtPiBJbnQKClJldHVybiB0aGUgcmFuayBvZiB0\naGUgdW5kZXJseWluZyBtb2R1bGUgb2YgdGhlIGxhdHRpY2UgYExgLgoiIiIK\ncmFuayhMOjpBYnN0cmFjdExhdCkgPSBkaW0ocmF0aW9uYWxfc3BhbihMKSkK\nCkBkb2MgcmF3IiIiCiAgICBkZWdyZWUoTDo6QWJzdHJhY3RMYXQpIC0+IElu\ndAoKUmV0dXJuIHRoZSBkaW1lbnNpb24gb2YgdGhlIGFtYmllbnQgc3BhY2Ug\nb2YgdGhlIGxhdHRpY2UgYExgLgoiIiIKZnVuY3Rpb24gZGVncmVlKEw6OkFi\nc3RyYWN0TGF0KQogIGlmIGlzZGVmaW5lZChMLCA6c3BhY2UpCiAgICByZXR1\ncm4gZGltKEwuc3BhY2UpCiAgZWxzZQogICAgcmV0dXJuIG5jb2xzKEwucG1h\ndC5tYXRyaXgpCiAgZW5kCmVuZAoKQGRvYyByYXciIiIKICAgIGlzX3N1Ymxh\ndHRpY2UoTDo6QWJzdHJhY3RMYXQsIE06OkFic3RyYWN0TGF0KSAtPiBCb29s\nCgpSZXR1cm4gd2hldGhlciBgTWAgaXMgYSBzdWJsYXR0aWNlIG9mIHRoZSBs\nYXR0aWNlIGBMYC4KIiIiCmZ1bmN0aW9uIGlzX3N1YmxhdHRpY2UoTDo6QWJz\ndHJhY3RMYXQsIE06OkFic3RyYWN0TGF0KQogIGlmIEwgPT09IE0KICAgIHJl\ndHVybiB0cnVlCiAgZW5kCgogIGlmIGFtYmllbnRfc3BhY2UoTCkgIT0gYW1i\naWVudF9zcGFjZShNKQogICAgcmV0dXJuIGZhbHNlCiAgZW5kCgogIHJldHVy\nbiBfc3BhbnNfc3Vic2V0X29mX3BzZXVkb2huZihwc2V1ZG9fbWF0cml4KE0p\nLCBfcHNldWRvX2huZihMKTsgc2hhcGUgPSA6bG93ZXJsZWZ0KQplbmQKCkBk\nb2MgcmF3IiIiCiAgICBpc3N1YnNldChNOjpBYnN0cmFjdExhdCwgTDo6QWJz\ndHJhY3RMYXQpIC0+IEJvb2wKClJldHVybiB3aGV0aGVyIGBNYCBpcyBhIHN1\nYnNldCBvZiB0aGUgbGF0dGljZSBgTGAuCiIiIgpCYXNlLmlzc3Vic2V0KE06\nOkFic3RyYWN0TGF0LCBMOjpBYnN0cmFjdExhdCkgPSBpc19zdWJsYXR0aWNl\nKEwsIE0pCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoj\nCiMgIFBzZXVkby1ITkYKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIwoKIyBSZXR1cm4gYSBsb3dlcmxlZnQgcHNldWRvIGhuZgpmdW5j\ndGlvbiBfcHNldWRvX2huZihMOjpBYnN0cmFjdExhdCkKICBnZXRfYXR0cmli\ndXRlIShMLCA6cHNldWRvX2huZikgZG8KICAgIHBzZXVkb19obmYocHNldWRv\nX21hdHJpeChMKSwgOmxvd2VybGVmdCkKICBlbmQ6OnR5cGVvZihMLnBtYXQp\nCmVuZAoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIwoj\nICBFcXVhbGl0eSBhbmQgaGFzaAojCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjCgpmdW5jdGlvbiBCYXNlLjooPT0pKEw6OkFic3RyYWN0\nTGF0LCBNOjpBYnN0cmFjdExhdCkKICBpZiBMID09PSBNCiAgICByZXR1cm4g\ndHJ1ZQogIGVuZAogIGlmIGFtYmllbnRfc3BhY2UoTCkgIT0gYW1iaWVudF9z\ncGFjZShNKQogICAgcmV0dXJuIGZhbHNlCiAgZW5kCiAgcmV0dXJuIHBzZXVk\nb19obmYocHNldWRvX21hdHJpeChMKSwgOmxvd2VybGVmdCkgPT0gcHNldWRv\nX2huZihwc2V1ZG9fbWF0cml4KE0pLCA6bG93ZXJsZWZ0KQplbmQKCmZ1bmN0\naW9uIEJhc2UuaGFzaChMOjpBYnN0cmFjdExhdCwgdTo6VUludCkKICBWID0g\nYW1iaWVudF9zcGFjZShMKQogIEIgPSBfcHNldWRvX2huZihMKQogICMgUHNl\ndWRvLWhuZiBhcmUgdW5pcXVlIGZvciBsYXR0aWNlcyBpbiBhIGdpdmVuIHNw\nYWNlLiBTaW5jZSB3ZSByZXF1aXJlIHRoYXQKICAjIGVxdWFsIGxhdHRpY2Vz\nIGxpZSBpbiB0aGUgc2FtZSBzcGFjZSwgd2UganVzdCBoYXZlIHRvIGhhc2gg\nYW5kIGNvbXBhcmUgdGhlCiAgIyBzcGFjZSBhbmQgdGhlIHBzZXVkbyBsYXR0\naWNlLiBIZXJlIGVxdWFsaXR5IGZvciBzcGFjZXMgaXMgc3Ryb25nIChgPT09\nYCkuCiAgaCA9IHhvcihoYXNoKFYpLCBoYXNoKEIpKQogIHJldHVybiB4b3Io\naCwgdSkKZW5kCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIwojCiMgIEdyYW0gbWF0cml4CiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMKCkBkb2MgcmF3IiIiCiAgICBncmFtX21hdHJpeF9vZl9y\nYXRpb25hbF9zcGFuKEw6OkFic3RyYWN0TGF0KSAtPiBNYXRFbGVtCgpSZXR1\ncm4gdGhlIEdyYW0gbWF0cml4IG9mIHRoZSByYXRpb25hbCBzcGFuIG9mIHRo\nZSBsYXR0aWNlIGBMYC4KIiIiCmZ1bmN0aW9uIGdyYW1fbWF0cml4X29mX3Jh\ndGlvbmFsX3NwYW4oTDo6QWJzdHJhY3RMYXQpCiAgaWYgaXNkZWZpbmVkKEws\nIDpncmFtKQogICAgcmV0dXJuIEwuZ3JhbQogIGVsc2UKICAgIHJldHVybiBn\ncmFtX21hdHJpeChhbWJpZW50X3NwYWNlKEwpLCBMLnBtYXQubWF0cml4KQog\nIGVuZAplbmQKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nCiMKIyAgR2VuZXJhdG9ycwojCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjCgojIENoZWNrIGlmIG9uZSByZWFsbHkgbmVlZHMgbWluaW1h\nbAojIFN0ZWluaXR6IGZvcm0gaXMgbm90IHByZXR0eQoKQGRvYyByYXciIiIK\nICAgIGdlbmVyYXRvcnMoTDo6QWJzdHJhY3RMYXQ7IG1pbmltYWwgPSBmYWxz\nZSkgLT4gVmVjdG9ye1ZlY3Rvcn0KClJldHVybiBhIHNldCBvZiBnZW5lcmF0\nb3JzIG9mIHRoZSBsYXR0aWNlIGBMYCBvdmVyIHRoZSBiYXNlIHJpbmcgb2Yg\nYExgLgoKSWYgYG1pbmltYWwgPT0gdHJ1ZWAsIHRoZSBudW1iZXIgb2YgZ2Vu\nZXJhdG9ycyBpcyBtaW5pbWFsLiBOb3RlIHRoYXQgY29tcHV0aW5nCm1pbmlt\nYWwgZ2VuZXJhdG9ycyBpcyBleHBlbnNpdmUuCiIiIgpmdW5jdGlvbiBnZW5l\ncmF0b3JzKEw6OkFic3RyYWN0TGF0OyBtaW5pbWFsOjpCb29sID0gZmFsc2Up\nCiAgSyA9IG5mKGJhc2VfcmluZyhMKSkKICBUID0gZWxlbV90eXBlKEspCiAg\naWYgIW1pbmltYWwKICAgIGlmIGlzZGVmaW5lZChMLCA6Z2VuZXJhdG9ycykK\nICAgICAgcmV0dXJuIEwuZ2VuZXJhdG9yczo6VmVjdG9ye1ZlY3RvcntUfX0K\nICAgIGVuZAogICAgdiA9IFZlY3RvcntUfVtdCiAgICBTdCA9IHBzZXVkb19t\nYXRyaXgoTCkKICAgIGQgPSBuY29scyhTdCkKICAgIGZvciBpIGluIDE6bnJv\nd3MoU3QpCiAgICAgIGlmIGJhc2VfcmluZyhMKSBpc2EgQWJzU2ltcGxlTnVt\nRmllbGRPcmRlcgogICAgICAgIEkgPSBudW1lcmF0b3IoY29lZmZpY2llbnRf\naWRlYWxzKFN0KVtpXSkKICAgICAgICBkZW4gPSBkZW5vbWluYXRvcihjb2Vm\nZmljaWVudF9pZGVhbHMoU3QpW2ldKQogICAgICAgIF9hc3N1cmVfd2Vha2x5\nX25vcm1hbF9wcmVzZW50YXRpb24oSSkKICAgICAgICBwdXNoISh2LCBUW0so\nSS5nZW5fb25lKS8vZGVuICogbWF0cml4KFN0KVtpLCBqXSBmb3IgaiBpbiAx\nOmRdKQogICAgICAgIHB1c2ghKHYsIFRbSyhJLmdlbl90d28pLy9kZW4gKiBt\nYXRyaXgoU3QpW2ksIGpdIGZvciBqIGluIDE6ZF0pCiAgICAgIGVsc2UKICAg\nICAgICBJID0gbnVtZXJhdG9yKGNvZWZmaWNpZW50X2lkZWFscyhTdClbaV0p\nCiAgICAgICAgZGVuID0gZGVub21pbmF0b3IoY29lZmZpY2llbnRfaWRlYWxz\nKFN0KVtpXSkKICAgICAgICBmb3IgZyBpbiBhYnNvbHV0ZV9iYXNpcyhJKQog\nICAgICAgICAgcHVzaCEodiwgVFtLKGcpLy9kZW4gKiBtYXRyaXgoU3QpW2ks\nIGpdIGZvciBqIGluIDE6ZF0pCiAgICAgICAgZW5kCiAgICAgIGVuZAogICAg\nZW5kCiAgICBMLmdlbmVyYXRvcnMgPSB2CiAgICByZXR1cm4gdgogIGVsc2Ug\nIyBtaW5pbWFsCiAgICBpZiBpc2RlZmluZWQoTCwgOm1pbmltYWxfZ2VuZXJh\ndG9ycykKICAgICAgcmV0dXJuIEwubWluaW1hbF9nZW5lcmF0b3JzOjpWZWN0\nb3J7VmVjdG9ye1R9fQogICAgZW5kCiAgICBTdCA9IHN0ZWluaXR6X2Zvcm0o\ncHNldWRvX21hdHJpeChMKSkKICAgIGQgPSBucm93cyhTdCkKICAgIG4gPSBk\nZWdyZWUoTCkKICAgIHYgPSBWZWN0b3J7VH1bXQogICAgZm9yIGkgaW4gMToo\nZCAtIDEpCiAgICAgICNAYXNzZXJ0IGlzX3ByaW5jaXBhbChjb2VmZmljaWVu\ndF9pZGVhbHMoU3QpW2ldKVsxXQogICAgICBwdXNoISh2LCBUW21hdHJpeChT\ndClbaSwgal0gZm9yIGogaW4gMTpkXSkKICAgIGVuZAoKICAgIEkgPSBudW1l\ncmF0b3IoY29lZmZpY2llbnRfaWRlYWxzKFN0KVtkXSkKICAgIGRlbiA9IGRl\nbm9taW5hdG9yKGNvZWZmaWNpZW50X2lkZWFscyhTdClbZF0pCiAgICBpZiBt\naW5pbWFsICYmIGJhc2VfcmluZyhMKSBpc2EgQWJzU2ltcGxlTnVtRmllbGRP\ncmRlcgogICAgICBiLCBhID0gaXNfcHJpbmNpcGFsX3dpdGhfZGF0YShJKQog\nICAgICBpZiBiCiAgICAgICAgcHVzaCEodiwgVFtLKGEpLy9kZW4gKiBtYXRy\naXgoU3QpW24sIGpdIGZvciBqIGluIDE6ZF0pCiAgICAgIGVuZAogICAgICBy\nZXR1cm4gdgogICAgZW5kCgogICAgaWYgYmFzZV9yaW5nKEwpIGlzYSBBYnNT\naW1wbGVOdW1GaWVsZE9yZGVyCiAgICAgIF9hc3N1cmVfd2Vha2x5X25vcm1h\nbF9wcmVzZW50YXRpb24oSSkKICAgICAgcHVzaCEodiwgVFtLKEkuZ2VuX29u\nZSkvL2RlbiAqIG1hdHJpeChTdClbbiwgal0gZm9yIGogaW4gMTpkXSkKICAg\nICAgcHVzaCEodiwgVFtLKEkuZ2VuX3R3bykvL2RlbiAqIG1hdHJpeChTdClb\nbiwgal0gZm9yIGogaW4gMTpkXSkKICAgIGVsc2UKICAgICAgZm9yIGcgaW4g\nYWJzb2x1dGVfYmFzaXMoSSkKICAgICAgICBwdXNoISh2LCBUW0soZykvL2Rl\nbiAqIG1hdHJpeChTdClbbiwgal0gZm9yIGogaW4gMTpkXSkKICAgICAgZW5k\nCiAgICBlbmQKICBlbmQKCiAgTC5taW5pbWFsX2dlbmVyYXRvcnMgPSB2Cgog\nIHJldHVybiB2CmVuZAoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIwojCiMgQ29uc3RydWN0b3JzCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIwoKQGRvYyByYXciIiIKICAgIGxhdHRpY2UoVjo6QWJz\ndHJhY3RTcGFjZSwgQjo6UE1hdCA7IGNoZWNrOjpCb29sID0gdHJ1ZSkgLT4g\nQWJzdHJhY3RMYXQKCkdpdmVuIGFuIGFtYmllbnQgc3BhY2UgYFZgIGFuZCBh\nIHBzZXVkby1tYXRyaXggYEJgLCByZXR1cm4gdGhlIGxhdHRpY2Ugc3Bhbm5l\nZApieSB0aGUgcHNldWRvLW1hdHJpeCBgQmAgaW5zaWRlIGBWYC4gSWYgYFZg\nIGlzIGhlcm1pdGlhbiAocmVzcC4gcXVhZHJhdGljKSB0aGVuCnRoZSBvdXRw\ndXQgaXMgYSBoZXJtaXRpYW4gKHJlc3AuIHF1YWRyYXRpYykgbGF0dGljZS4K\nCkJ5IGRlZmF1bHQsIGBCYCBpcyBjaGVja2VkIHRvIGJlIG9mIGZ1bGwgcmFu\nay4gVGhpcyB0ZXN0IGNhbiBiZSBkaXNhYmxlZCBieSBzZXR0aW5nCmBjaGVj\na2AgdG8gZmFsc2UuCiIiIgpsYXR0aWNlKFY6OkFic3RyYWN0U3BhY2UsIEI6\nOlBNYXQgOyBjaGVjazo6Qm9vbCA9IHRydWUpCgpAZG9jIHJhdyIiIgogICAg\nbGF0dGljZShWOjpBYnN0cmFjdFNwYWNlLCBiYXNpczo6TWF0RWxlbSA7IGNo\nZWNrOjpCb29sID0gdHJ1ZSkgLT4gQWJzdHJhY3RMYXQKCkdpdmVuIGFuIGFt\nYmllbnQgc3BhY2UgYFZgIGFuZCBhIG1hdHJpeCBgYmFzaXNgLCByZXR1cm4g\ndGhlIGxhdHRpY2Ugc3Bhbm5lZApieSB0aGUgcm93cyBvZiBgYmFzaXNgIGlu\nc2lkZSBgVmAuIElmIGBWYCBpcyBoZXJtaXRpYW4gKHJlc3AuIHF1YWRyYXRp\nYykgdGhlbgp0aGUgb3V0cHV0IGlzIGEgaGVybWl0aWFuIChyZXNwLiBxdWFk\ncmF0aWMpIGxhdHRpY2UuCgpCeSBkZWZhdWx0LCBgYmFzaXNgIGlzIGNoZWNr\nZWQgdG8gYmUgb2YgZnVsbCByYW5rLiBUaGlzIHRlc3QgY2FuIGJlIGRpc2Fi\nbGVkIGJ5IHNldHRpbmcKYGNoZWNrYCB0byBmYWxzZS4KIiIiCmxhdHRpY2Uo\nVjo6QWJzdHJhY3RTcGFjZSwgYmFzaXM6Ok1hdEVsZW0gOyBjaGVjazo6Qm9v\nbCA9IHRydWUpID0gbGF0dGljZShWLCBwc2V1ZG9fbWF0cml4KGJhc2lzKTsg\nY2hlY2spCgpAZG9jIHJhdyIiIgogICAgbGF0dGljZShWOjpBYnN0cmFjdFNw\nYWNlLCBnZW5zOjpWZWN0b3IpIC0+IEFic3RyYWN0TGF0CgpHaXZlbiBhbiBh\nbWJpZW50IHNwYWNlIGBWYCBhbmQgYSBsaXN0IG9mIGdlbmVyYXRvcnMgYGdl\nbnNgLCByZXR1cm4gdGhlIGxhdHRpY2UKc3Bhbm5lZCBieSBgZ2Vuc2AgaW4g\nYFZgLiBJZiBgVmAgaXMgaGVybWl0aWFuIChyZXNwLiBxdWFkcmF0aWMpIHRo\nZW4gdGhlIG91dHB1dAppcyBhIGhlcm1pdGlhbiAocmVzcC4gcXVhZHJhdGlj\nKSBsYXR0aWNlLgoKSWYgYGdlbnNgIGlzIGVtcHR5LCB0aGUgZnVuY3Rpb24g\ncmV0dXJucyB0aGUgemVybyBsYXR0aWNlIGluIGBWYC4KIiIiCmZ1bmN0aW9u\nIGxhdHRpY2UoVjo6SGVja2UuQWJzdHJhY3RTcGFjZSwgX2dlbnM6OlZlY3Rv\ncikKICBpZiBsZW5ndGgoX2dlbnMpID09IDAKICAgIHBtID0gcHNldWRvX21h\ndHJpeChtYXRyaXgoYmFzZV9yaW5nKFYpLCAwLCBkaW0oViksIFtdKSkKICAg\nIHJldHVybiBsYXR0aWNlKFYsIHBtOyBjaGVjayA9IGZhbHNlKQogIGVuZAog\nIEBhc3NlcnQgbGVuZ3RoKF9nZW5zWzFdKSA+IDAKICBAcmVxIGFsbCh2IC0+\nIGxlbmd0aCh2KSA9PSBsZW5ndGgoX2dlbnNbMV0pLCBfZ2VucykgIkFsbCB2\nZWN0b3JzIGluIGdlbnMgbXVzdCBiZSBvZiB0aGUgc2FtZSBsZW5ndGgiCiAg\nQHJlcSBsZW5ndGgoX2dlbnNbMV0pID09IGRpbShWKSAiSW5jb21wYXRpYmxl\nIGFyZ3VtZW50czogdGhlIGxlbmd0aCBvZiB0aGUgZWxlbWVudHMgb2YgZ2Vu\ncyBtdXN0IGNvcnJlc3BvbmQgdG8gdGhlIGRpbWVuc2lvbiBvZiBWIgogIEYg\nPSBiYXNlX3JpbmcoVikKICBnZW5zID0gW21hcChGLCB2KSBmb3IgdiBpbiBf\nZ2Vuc10KICBNID0gemVyb19tYXRyaXgoRiwgbGVuZ3RoKGdlbnMpLCBsZW5n\ndGgoZ2Vuc1sxXSkpCiAgZm9yIGk9MTpucm93cyhNKQogICAgZm9yIGo9MTpu\nY29scyhNKQogICAgICBNW2ksal0gPSBnZW5zW2ldW2pdCiAgICBlbmQKICBl\nbmQKICBwbSA9IHBzZXVkb19obmYocHNldWRvX21hdHJpeChNKSwgOmxvd2Vy\nbGVmdCkKICBpID0gMQogIHdoaWxlIGlzX3plcm9fcm93KHBtLm1hdHJpeCwg\naSkKICAgIGkgKz0gMQogIGVuZAogIHBtID0gc3ViKHBtLCBpOm5yb3dzKHBt\nKSwgMTpuY29scyhwbSkpCiAgTCA9IGxhdHRpY2UoViwgcG07IGNoZWNrID0g\nZmFsc2UpCiAgTC5nZW5lcmF0b3JzID0gZ2VucwogIHJldHVybiBMCmVuZAoK\nQGRvYyByYXciIiIKICAgIGxhdHRpY2UoVjo6QWJzdHJhY3RTcGFjZSkgLT4g\nQWJzdHJhY3RMYXQKCkdpdmVuIGFuIGFtYmllbnQgc3BhY2UgYFZgLCByZXR1\ncm4gdGhlIGxhdHRpY2Ugd2l0aCB0aGUgc3RhbmRhcmQgYmFzaXMKbWF0cml4\nLiBJZiBgVmAgaXMgaGVybWl0aWFuIChyZXNwLiBxdWFkcmF0aWMpIHRoZW4g\ndGhlIG91dHB1dCBpcyBhIGhlcm1pdGlhbgoocmVzcC4gcXVhZHJhdGljKSBs\nYXR0aWNlLgoiIiIKbGF0dGljZShWOjpBYnN0cmFjdFNwYWNlKSA9IGxhdHRp\nY2UoViwgaWRlbnRpdHlfbWF0cml4KGJhc2VfcmluZyhWKSwgcmFuayhWKSk7\nIGNoZWNrID0gZmFsc2UpCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIwojCiMgIEdyYW0gbWF0cml4IG9mIGdlbmVyYXRvcnMKIwojIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKQGRvYyByYXciIiIK\nICAgIGdyYW1fbWF0cml4X29mX2dlbmVyYXRvcnMoTDo6QWJzdHJhY3RMYXQ7\nIG1pbmltYWw6OkJvb2wgPSBmYWxzZSkgLT4gTWF0RWxlbQoKUmV0dXJuIHRo\nZSBHcmFtIG1hdHJpeCBvZiBhIGdlbmVyYXRpbmcgc2V0IG9mIHRoZSBsYXR0\naWNlIGBMYC4KCklmIGBtaW5pbWFsID09IHRydWVgLCB0aGVuIGEgbWluaW1h\nbCBnZW5lcmF0aW5nIHNldCBpcyB1c2VkLiBOb3RlIHRoYXQgY29tcHV0aW5n\nCm1pbmltYWwgZ2VuZXJhdG9ycyBpcyBleHBlbnNpdmUuCiIiIgpmdW5jdGlv\nbiBncmFtX21hdHJpeF9vZl9nZW5lcmF0b3JzKEw6OkFic3RyYWN0TGF0OyBt\naW5pbWFsOjpCb29sID0gZmFsc2UpCiAgbSA9IGdlbmVyYXRvcnMoTDsgbWlu\naW1hbCkKICBNID0gbWF0cml4KG5mKGJhc2VfcmluZyhMKSksIG0pCiAgcmV0\ndXJuIGdyYW1fbWF0cml4KGFtYmllbnRfc3BhY2UoTCksIE0pCmVuZAoKIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIwojICBEaXNjcmlt\naW5hbnQKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoK\nQGRvYyByYXciIiIKICAgIGRpc2NyaW1pbmFudChMOjpBYnN0cmFjdExhdCkg\nLT4gQWJzU2ltcGxlTnVtRmllbGRPcmRlckZyYWN0aW9uYWxJZGVhbAoKUmV0\ndXJuIHRoZSBkaXNjcmltaW5hbnQgb2YgdGhlIGxhdHRpY2UgYExgLCB0aGF0\nIGlzLCB0aGUgZ2VuZXJhbGl6ZWQgaW5kZXggaWRlYWwKJFtMXlwjIDogTF0k\nLgoiIiIKZnVuY3Rpb24gZGlzY3JpbWluYW50KEw6OkFic3RyYWN0TGF0KQog\nIGQgPSBkZXQoZ3JhbV9tYXRyaXhfb2ZfcmF0aW9uYWxfc3BhbihMKSkKICB2\nID0gaW52b2x1dGlvbihMKQogIEMgPSBjb2VmZmljaWVudF9pZGVhbHMoTCkK\nICBJID0gcHJvZChDOyBpbml0ID0gb25lKGJhc2VfZmllbGQoTCkpKmJhc2Vf\ncmluZyhMKSkKICByZXR1cm4gZCAqIEkgKiB2KEkpCmVuZAoKIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIwojICBSYXRpb25hbCAobG9j\nYWwpIGlzb21ldHJ5CiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMKCkBkb2MgcmF3IiIiCiAgICBoYXNzZV9pbnZhcmlhbnQoTDo6QWJz\ndHJhY3RMYXQsIHA6OlVuaW9ue0luZlBsYywgQWJzTnVtRmllbGRPcmRlcklk\nZWFse0Fic1NpbXBsZU51bUZpZWxkLCBBYnNTaW1wbGVOdW1GaWVsZEVsZW19\nfSkgLT4gSW50CgpSZXR1cm4gdGhlIEhhc3NlIGludmFyaWFudCBvZiB0aGUg\ncmF0aW9uYWwgc3BhbiBvZiB0aGUgbGF0dGljZSBgTGAgYXQgdGhlIHBsYWNl\nIGBwYC4KVGhlIGxhdHRpY2UgbXVzdCBiZSBxdWFkcmF0aWMuCiIiIgpoYXNz\nZV9pbnZhcmlhbnQoTDo6QWJzdHJhY3RMYXQsIHApCgpAZG9jIHJhdyIiIgog\nICAgd2l0dF9pbnZhcmlhbnQoTDo6QWJzdHJhY3RMYXQsIHA6OlVuaW9ue0lu\nZlBsYywgQWJzTnVtRmllbGRPcmRlcklkZWFse0Fic1NpbXBsZU51bUZpZWxk\nLCBBYnNTaW1wbGVOdW1GaWVsZEVsZW19fSkgLT4gSW50CgpSZXR1cm4gdGhl\nIFdpdHQgaW52YXJpYW50IG9mIHRoZSByYXRpb25hbCBzcGFuIG9mIHRoZSBs\nYXR0aWNlIGBMYCBhdCB0aGUgcGxhY2UgYHBgLgpUaGUgbGF0dGljZSBtdXN0\nIGJlIHF1YWRyYXRpYy4KIiIiCndpdHRfaW52YXJpYW50KEw6OkFic3RyYWN0\nTGF0LCBwKQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMK\nIwojICBSYXRpb25hbCBpc29tZXRyeQojCiMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjCgpAZG9jIHJhdyIiIgogICAgaXNfcmF0aW9uYWxs\neV9pc29tZXRyaWMoTDo6QWJzdHJhY3RMYXQsIE06OkFic3RyYWN0TGF0LCBw\nOjpVbmlvbntJbmZQbGMsIEFic051bUZpZWxkT3JkZXJJZGVhbH0pCiAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAtPiBCb29sCgpSZXR1cm4gd2hldGhl\nciB0aGUgcmF0aW9uYWwgc3BhbnMgb2YgdGhlIGxhdHRpY2VzIGBMYCBhbmQg\nYE1gIGFyZSBpc29tZXRyaWMgb3Zlcgp0aGUgY29tcGxldGlvbiBhdCB0aGUg\ncGxhY2UgYHBgLgoiIiIKaXNfcmF0aW9uYWxseV9pc29tZXRyaWMoOjpBYnN0\ncmFjdExhdCwgOjpBYnN0cmFjdExhdCwgOjpBYnNOdW1GaWVsZE9yZGVySWRl\nYWwpCgpmdW5jdGlvbiBpc19yYXRpb25hbGx5X2lzb21ldHJpYyhMOjpBYnN0\ncmFjdExhdCwgTTo6QWJzdHJhY3RMYXQsIHA6OkFic051bUZpZWxkT3JkZXJJ\nZGVhbCkKICByZXR1cm4gaXNfaXNvbWV0cmljKHJhdGlvbmFsX3NwYW4oTCks\nIHJhdGlvbmFsX3NwYW4oTSksIHApCmVuZAoKZnVuY3Rpb24gaXNfcmF0aW9u\nYWxseV9pc29tZXRyaWMoTDo6QWJzdHJhY3RMYXQsIE06OkFic3RyYWN0TGF0\nLCBwOjpJbmZQbGMpCiAgcmV0dXJuIGlzX2lzb21ldHJpYyhyYXRpb25hbF9z\ncGFuKEwpLCByYXRpb25hbF9zcGFuKE0pLCBwKQplbmQKCkBkb2MgcmF3IiIi\nCiAgICBpc19yYXRpb25hbGx5X2lzb21ldHJpYyhMOjpBYnN0cmFjdExhdCwg\nTTo6QWJzdHJhY3RMYXQpIC0+IEJvb2wKClJldHVybiB3aGV0aGVyIHRoZSBy\nYXRpb25hbCBzcGFucyBvZiB0aGUgbGF0dGljZXMgYExgIGFuZCBgTWAgYXJl\nIGlzb21ldHJpYy4KIiIiCmZ1bmN0aW9uIGlzX3JhdGlvbmFsbHlfaXNvbWV0\ncmljKEw6OkFic3RyYWN0TGF0LCBNOjpBYnN0cmFjdExhdCkKICByZXR1cm4g\naXNfaXNvbWV0cmljKHJhdGlvbmFsX3NwYW4oTCksIHJhdGlvbmFsX3NwYW4o\nTSkpCmVuZAoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMK\nIwojICBEZWZpbml0ZW5lc3MKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIwoKQGRvYyByYXciIiIKICAgIGlzX3Bvc2l0aXZlX2RlZmlu\naXRlKEw6OkFic3RyYWN0TGF0KSAtPiBCb29sCgpSZXR1cm4gd2hldGhlciB0\naGUgcmF0aW9uYWwgc3BhbiBvZiB0aGUgbGF0dGljZSBgTGAgaXMgcG9zaXRp\ndmUgZGVmaW5pdGUuCiIiIgppc19wb3NpdGl2ZV9kZWZpbml0ZShMOjpBYnN0\ncmFjdExhdCkgPSBpc19wb3NpdGl2ZV9kZWZpbml0ZShyYXRpb25hbF9zcGFu\nKEwpKQoKQGRvYyByYXciIiIKICAgIGlzX25lZ2F0aXZlX2RlZmluaXRlKEw6\nOkFic3RyYWN0TGF0KSAtPiBCb29sCgpSZXR1cm4gd2hldGhlciB0aGUgcmF0\naW9uYWwgc3BhbiBvZiB0aGUgbGF0dGljZSBgTGAgaXMgbmVnYXRpdmUgZGVm\naW5pdGUuCiIiIgppc19uZWdhdGl2ZV9kZWZpbml0ZShMOjpBYnN0cmFjdExh\ndCkgPSBpc19uZWdhdGl2ZV9kZWZpbml0ZShyYXRpb25hbF9zcGFuKEwpKQoK\nQGRvYyByYXciIiIKICAgIGlzX2RlZmluaXRlKEw6OkFic3RyYWN0TGF0KSAt\nPiBCb29sCgpSZXR1cm4gd2hldGhlciB0aGUgcmF0aW9uYWwgc3BhbiBvZiB0\naGUgbGF0dGljZSBgTGAgaXMgZGVmaW5pdGUuCiIiIgpAYXR0ciBCb29sIGlz\nX2RlZmluaXRlKEw6OkFic3RyYWN0TGF0KSA9IGlzX2RlZmluaXRlKHJhdGlv\nbmFsX3NwYW4oTCkpCgpAZG9jIHJhdyIiIgogICAgY2FuX3NjYWxlX3RvdGFs\nbHlfcG9zaXRpdmUoTDo6QWJzdHJhY3RMYXQpIC0+IEJvb2wsIE51bUZpZWxk\nRWxlbQoKUmV0dXJuIHdoZXRoZXIgdGhlcmUgaXMgYSB0b3RhbGx5IHBvc2l0\naXZlIHJlc2NhbGVkIGxhdHRpY2Ugb2YgdGhlIGxhdHRpY2UgYExgLgpJZiBz\nbywgdGhlIHNlY29uZCByZXR1cm5lZCB2YWx1ZSBpcyBhbiBlbGVtZW50ICRh\nJCBzdWNoIHRoYXQgJExeYSQgaXMgdG90YWxseSBwb3NpdGl2ZS4KIiIiCmZ1\nbmN0aW9uIGNhbl9zY2FsZV90b3RhbGx5X3Bvc2l0aXZlKEw6OkFic3RyYWN0\nTGF0KQogIGEgPSBfaXNkZWZpbml0ZShyYXRpb25hbF9zcGFuKEwpKQogIGlm\nIGlzemVybyhhKQogICAgcmV0dXJuIGZhbHNlLCBhCiAgZWxzZQogICAgcmV0\ndXJuIHRydWUsIGEKICBlbmQKZW5kCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIwojCiMgIEFkZGl0aW9uCiMKIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMKCiMgU29tZSBvZiB0aGVzZSBhc3NlcnRp\nb25zIGNhbiBiZSByZWxheGVkLCBpbiBwYXJ0aWN1bGFyIGluIHRoZSBzY2Fs\naW5nCgpAZG9jIHJhdyIiIgogICAgKyhMOjpBYnN0cmFjdExhdCwgTTo6QWJz\ndHJhY3RMYXQpIC0+IEFic3RyYWN0TGF0CgpSZXR1cm4gdGhlIHN1bSBvZiB0\naGUgbGF0dGljZXMgYExgIGFuZCBgTWAuCgpUaGUgbGF0dGljZXMgYExgIGFu\nZCBgTWAgbXVzdCBoYXZlIHRoZSBzYW1lIGFtYmllbnQgc3BhY2UuCiIiIgpC\nYXNlLjooKykoOjpBYnN0cmFjdExhdCwgOjpBYnN0cmFjdExhdCkKCmZ1bmN0\naW9uIEJhc2UuOigrKShMOjpULCBNOjpUKSB3aGVyZSB7VCA8OiBBYnN0cmFj\ndExhdH0KICBAYXNzZXJ0IGhhc19hbWJpZW50X3NwYWNlKEwpICYmIGhhc19h\nbWJpZW50X3NwYWNlKE0pCiAgQGFzc2VydCBhbWJpZW50X3NwYWNlKEwpID09\nPSBhbWJpZW50X3NwYWNlKE0pCiAgViA9IGFtYmllbnRfc3BhY2UoTCkKICBm\nciA9IG5yb3dzKHBzZXVkb19tYXRyaXgoTCkpID09IGRpbShWKSB8fCBucm93\ncyhwc2V1ZG9fbWF0cml4KE0pKSA9PSBkaW0oVikKICBtID0gX3N1bV9tb2R1\nbGVzKEwsIHBzZXVkb19tYXRyaXgoTCksIHBzZXVkb19tYXRyaXgoTSksIGZy\nKQogIHJldHVybiBsYXR0aWNlX2luX3NhbWVfYW1iaWVudF9zcGFjZShMLCBt\nKQplbmQKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMK\nIyAgSW50ZXJzZWN0aW9uCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMKCkBkb2MgcmF3IiIiCiAgICBpbnRlcnNlY3QoTDo6QWJzdHJh\nY3RMYXQsIE06OkFic3RyYWN0TGF0KSAtPiBBYnN0cmFjdExhdAoKUmV0dXJu\nIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIGxhdHRpY2VzIGBMYCBhbmQgYE1g\nLgoKVGhlIGxhdHRpY2VzIGBMYCBhbmQgYE1gIG11c3QgaGF2ZSB0aGUgc2Ft\nZSBhbWJpZW50IHNwYWNlLgoiIiIKaW50ZXJzZWN0KDo6QWJzdHJhY3RMYXQs\nIDo6QWJzdHJhY3RMYXQpCgpmdW5jdGlvbiBpbnRlcnNlY3QoTDo6VCwgTTo6\nVCkgd2hlcmUgVCA8OiBBYnN0cmFjdExhdAogIEBhc3NlcnQgaGFzX2FtYmll\nbnRfc3BhY2UoTCkgJiYgaGFzX2FtYmllbnRfc3BhY2UoTSkKICBAcmVxIGFt\nYmllbnRfc3BhY2UoTCkgPT09IGFtYmllbnRfc3BhY2UoTSkgIkxhdHRpY2Vz\nIG11c3QgYmUgaW4gdGhlIHNhbWUgYW1iaWVudCBzcGFjZSIKICBWID0gYW1i\naWVudF9zcGFjZShMKQogIGZyID0gbnJvd3MocHNldWRvX21hdHJpeChMKSkg\nPT0gZGltKFYpICYmIG5yb3dzKHBzZXVkb19tYXRyaXgoTSkpID09IGRpbShW\nKQogIGlmICFmcgogICAgcmV0dXJuIF9pbnRlcnNlY3RfdmlhX3Jlc3RyaWN0\naW9uX29mX3NjYWxhcnMoTCwgTSkKICBlbmQKICBtID0gX2ludGVyc2VjdF9t\nb2R1bGVzKEwsIHBzZXVkb19tYXRyaXgoTCksIHBzZXVkb19tYXRyaXgoTSks\nIGZyKQogIHJldHVybiBsYXR0aWNlX2luX3NhbWVfYW1iaWVudF9zcGFjZShM\nLCBtKQplbmQKCmZ1bmN0aW9uIF9pbnRlcnNlY3RfdmlhX3Jlc3RyaWN0aW9u\nX29mX3NjYWxhcnMoTDo6QWJzdHJhY3RMYXQsIE06OkFic3RyYWN0TGF0KQog\nIEBhc3NlcnQgaGFzX2FtYmllbnRfc3BhY2UoTCkgJiYgaGFzX2FtYmllbnRf\nc3BhY2UoTSkKICBAYXNzZXJ0IGFtYmllbnRfc3BhY2UoTCkgPT09IGFtYmll\nbnRfc3BhY2UoTSkKICBAYXNzZXJ0ICEoTCBpc2EgWlpMYXQpCiAgTHJlcywg\nZiA9IHJlc3RyaWN0X3NjYWxhcnNfd2l0aF9tYXAoTCwgUVEpCiAgTXJlcyA9\nIHJlc3RyaWN0X3NjYWxhcnMoTSwgZikKICBOcmVzID0gaW50ZXJzZWN0KExy\nZXMsIE1yZXMpCiAgQnJlcyA9IGJhc2lzX21hdHJpeChOcmVzKQogIGdlbnMg\nPSBbZih2ZWMoY29sbGVjdChCcmVzW2ksOl0pKSkgZm9yIGkgaW4gMTpucm93\ncyhCcmVzKV0KICByZXR1cm4gbGF0dGljZShhbWJpZW50X3NwYWNlKEwpLCBn\nZW5zKQplbmQKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nCiMKIyAgU2NhbGFyIG11bHRpcGxpY2F0aW9uCiMKIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMKCkBkb2MgcmF3IiIiCiAgICAqKGE6Ok51\nbUZpZWxkRWxlbSwgTDo6QWJzdHJhY3RMYXQpIC0+IEFic3RyYWN0TGF0CgpS\nZXR1cm4gdGhlIGxhdHRpY2UgJGFMJCBpbnNpZGUgdGhlIGFtYmllbnQgc3Bh\nY2Ugb2YgdGhlIGxhdHRpY2UgYExgLgoiIiIKZnVuY3Rpb24gQmFzZS46KCop\nKGE6Ok51bUZpZWxkRWxlbSwgTDo6QWJzdHJhY3RMYXQpCiAgQGFzc2VydCBo\nYXNfYW1iaWVudF9zcGFjZShMKQogIE8gPSBtYXhpbWFsX29yZGVyKHBhcmVu\ndChhKSkKICBtID0gX21vZHVsZV9zY2FsZV9pZGVhbChhKk8sIHBzZXVkb19t\nYXRyaXgoTCkpCiAgcmV0dXJuIGxhdHRpY2VfaW5fc2FtZV9hbWJpZW50X3Nw\nYWNlKEwsIG0pCmVuZAoKZnVuY3Rpb24gQmFzZS46KCopKEw6OlF1YWRMYXQs\nIGEpCiAgcmV0dXJuIGEgKiBMCmVuZAoKQGRvYyByYXciIiIKICAgICooYTo6\nTnVtRmllbGRPcmRlcklkZWFsLCBMOjpBYnN0cmFjdExhdCkgLT4gQWJzdHJh\nY3RMYXQKClJldHVybiB0aGUgbGF0dGljZSAkYUwkIGluc2lkZSB0aGUgYW1i\naWVudCBzcGFjZSBvZiB0aGUgbGF0dGljZSBgTGAuCiIiIgpCYXNlLjooKiko\nOjpOdW1GaWVsZE9yZGVySWRlYWwsIDo6QWJzdHJhY3RMYXQpCgpmdW5jdGlv\nbiBCYXNlLjooKikoYTo6VW5pb257UmVsTnVtRmllbGRPcmRlcklkZWFsLCBB\nYnNOdW1GaWVsZE9yZGVySWRlYWx9LCBMOjpBYnN0cmFjdExhdCkKICBAYXNz\nZXJ0IGhhc19hbWJpZW50X3NwYWNlKEwpCiAgbSA9IF9tb2R1bGVfc2NhbGVf\naWRlYWwoYSwgcHNldWRvX21hdHJpeChMKSkKICByZXR1cm4gbGF0dGljZV9p\nbl9zYW1lX2FtYmllbnRfc3BhY2UoTCwgbSkKZW5kCgpAZG9jIHJhdyIiIgog\nICAgKihhOjpOdW1GaWVsZE9yZGVyRnJhY3Rpb25hbElkZWFsLCBMOjpBYnN0\ncmFjdExhdCkgLT4gQWJzdHJhY3RMYXQKClJldHVybiB0aGUgbGF0dGljZSAk\nYUwkIGluc2lkZSB0aGUgYW1iaWVudCBzcGFjZSBvZiB0aGUgbGF0dGljZSBg\nTGAuCiIiIgpCYXNlLjooKikoOjpOdW1GaWVsZE9yZGVyRnJhY3Rpb25hbElk\nZWFsLCA6OkFic3RyYWN0TGF0KQoKZnVuY3Rpb24gQmFzZS46KCopKGE6OlVu\naW9ue1JlbE51bUZpZWxkT3JkZXJGcmFjdGlvbmFsSWRlYWwsIEFic051bUZp\nZWxkT3JkZXJGcmFjdGlvbmFsSWRlYWx9LCBMOjpBYnN0cmFjdExhdCkKICBA\nYXNzZXJ0IGhhc19hbWJpZW50X3NwYWNlKEwpCiAgbSA9IF9tb2R1bGVfc2Nh\nbGVfaWRlYWwoYSwgcHNldWRvX21hdHJpeChMKSkKICByZXR1cm4gbGF0dGlj\nZV9pbl9zYW1lX2FtYmllbnRfc3BhY2UoTCwgbSkKZW5kCgojIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMgIEFic29sdXRlIGJhc2lz\nCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCkBkb2Mg\ncmF3IiIiCiAgICBhYnNvbHV0ZV9iYXNpcyhMOjpBYnN0cmFjdExhdCkgLT4g\nVmVjdG9yCgpSZXR1cm4gYSAkXG1hdGhiZntafSQtYmFzaXMgb2YgdGhlIGxh\ndHRpY2UgYExgLgoiIiIKZnVuY3Rpb24gYWJzb2x1dGVfYmFzaXMoTDo6QWJz\ndHJhY3RMYXQpCiAgcGIgPSBwc2V1ZG9fYmFzaXMoTCkKICB6ID0gVmVjdG9y\ne1ZlY3RvcntlbGVtX3R5cGUoYmFzZV9maWVsZChMKSl9fSgpCiAgZm9yICh2\nLCBhKSBpbiBwYgogICAgZm9yIHcgaW4gYWJzb2x1dGVfYmFzaXMoYSkKICAg\nICAgcHVzaCEoeiwgdyAuKiB2KQogICAgZW5kCiAgZW5kCiAgQGFzc2VydCBs\nZW5ndGgoeikgPT0gYWJzb2x1dGVfZGVncmVlKGJhc2VfZmllbGQoTCkpICog\ncmFuayhMKQogIHJldHVybiB6CmVuZAoKIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMKIwojICBBYnNvbHV0ZSBiYXNpcyBtYXRyaXgKIwoj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKQGRvYyByYXci\nIiIKICAgIGFic29sdXRlX2Jhc2lzX21hdHJpeChMOjpBYnN0cmFjdExhdCkg\nLT4gTWF0RWxlbQoKUmV0dXJuIGEgJFxtYXRoYmZ7Wn0kLWJhc2lzIG1hdHJp\neCBvZiB0aGUgbGF0dGljZSBgTGAuCiIiIgpmdW5jdGlvbiBhYnNvbHV0ZV9i\nYXNpc19tYXRyaXgoTDo6QWJzdHJhY3RMYXQpCiAgcGIgPSBwc2V1ZG9fYmFz\naXMoTCkKICBFID0gYmFzZV9maWVsZChMKQogIGMgPSBuY29scyhtYXRyaXgo\ncHNldWRvX21hdHJpeChMKSkpCiAgeiA9IHplcm9fbWF0cml4KEUsIHJhbmso\nTCkgKiBhYnNvbHV0ZV9kZWdyZWUoRSksIGMpCiAgayA9IDEKICBmb3IgKHYs\nIGEpIGluIHBiCiAgICBmb3IgdyBpbiBhYnNvbHV0ZV9iYXNpcyhhKQogICAg\nICBmb3IgaiBpbiAxOmMKICAgICAgICB6W2ssIGpdID0gdyAqIHZbal0KICAg\nICAgZW5kCiAgICAgIGsgKz0gMQogICAgZW5kCiAgZW5kCiAgcmV0dXJuIHoK\nZW5kCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMg\nIE5vcm0KIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoK\nQGRvYyByYXciIiIKICAgIG5vcm0oTDo6QWJzdHJhY3RMYXQpIC0+IEFic051\nbUZpZWxkT3JkZXJGcmFjdGlvbmFsSWRlYWwKClJldHVybiB0aGUgbm9ybSBv\nZiB0aGUgbGF0dGljZSBgTGAuIFRoaXMgaXMgYSBmcmFjdGlvbmFsIGlkZWFs\nIG9mIHRoZSBmaXhlZCBmaWVsZApvZiBgTGAuCiIiIgpub3JtKDo6QWJzdHJh\nY3RMYXQpCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoj\nCiMgIFNjYWxlCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMKCkBkb2MgcmF3IiIiCiAgICBzY2FsZShMOjpBYnN0cmFjdExhdCkgLT4g\nQWJzU2ltcGxlTnVtRmllbGRPcmRlckZyYWN0aW9uYWxJZGVhbAoKUmV0dXJu\nIHRoZSBzY2FsZSBvZiB0aGUgbGF0dGljZSBgTGAuCiIiIgpzY2FsZShMOjpB\nYnN0cmFjdExhdCkKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjCiMKIyAgUmVzY2FsZQojCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjCgpAZG9jIHJhdyIiIgogICAgcmVzY2FsZShMOjpBYnN0cmFj\ndExhdCwgYTo6TnVtRmllbGRFbGVtKSAtPiBBYnN0cmFjdExhdAoKUmV0dXJu\nIHRoZSByZXNjYWxlZCBsYXR0aWNlICRMXmEkLiBOb3RlIHRoYXQgdGhpcyBo\nYXMgYSBkaWZmZXJlbnQgYW1iaWVudApzcGFjZSB0aGFuIHRoZSBsYXR0aWNl\nIGBMYC4KIiIiCnJlc2NhbGUoOjpBYnN0cmFjdExhdCwgOjpOdW1GaWVsZEVs\nZW07IGNhY2hlZD10cnVlKQoKQmFzZS46KF4pKEw6OkFic3RyYWN0TGF0LCBh\nOjpSaW5nRWxlbWVudCkgPSByZXNjYWxlKEwsIGE7IGNhY2hlZD1mYWxzZSkK\nCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMKIyAgSXMg\naW50ZWdyYWwKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIwoKQGRvYyByYXciIiIKICAgIGlzX2ludGVncmFsKEw6OkFic3RyYWN0TGF0\nKSAtPiBCb29sCgpSZXR1cm4gd2hldGhlciB0aGUgbGF0dGljZSBgTGAgaXMg\naW50ZWdyYWwuCiIiIgpmdW5jdGlvbiBpc19pbnRlZ3JhbChMOjpBYnN0cmFj\ndExhdCkKICByZXR1cm4gaXNfaW50ZWdyYWwoc2NhbGUoTCkpCmVuZAoKIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIwojICBEdWFsIGxh\ndHRpY2UKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoK\nQGRvYyByYXciIiIKICAgIGR1YWwoTDo6QWJzdHJhY3RMYXQpIC0+IEFic3Ry\nYWN0TGF0CgpSZXR1cm4gdGhlIGR1YWwgbGF0dGljZSBvZiB0aGUgbGF0dGlj\nZSBgTGAuCiIiIgpkdWFsKDo6QWJzdHJhY3RMYXQpCgojIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMgIFZvbHVtZQojCiMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpAZG9jIHJhdyIiIgogICAg\ndm9sdW1lKEw6OkFic3RyYWN0TGF0KSAtPiBBYnNTaW1wbGVOdW1GaWVsZE9y\nZGVyRnJhY3Rpb25hbElkZWFsCgpSZXR1cm4gdGhlIHZvbHVtZSBvZiB0aGUg\nbGF0dGljZSBgTGAuCiIiIgpmdW5jdGlvbiB2b2x1bWUoTDo6QWJzdHJhY3RM\nYXQpCiAgcmV0dXJuIGRpc2NyaW1pbmFudChMKQplbmQKCiMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMKIyAgTW9kdWxhcml0eQojCiMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCgpAZG9jIHJhdyIi\nIgogICAgaXNfbW9kdWxhcihMOjpBYnN0cmFjdExhdCkgLT4gQm9vbCwgQWJz\nU2ltcGxlTnVtRmllbGRPcmRlckZyYWN0aW9uYWxJZGVhbAoKUmV0dXJuIHdo\nZXRoZXIgdGhlIGxhdHRpY2UgYExgIGlzIG1vZHVsYXIuIEluIHRoaXMgY2Fz\nZSwgdGhlIHNlY29uZCByZXR1cm5lZCB2YWx1ZQppcyBhIGZyYWN0aW9uYWwg\naWRlYWwgJFxtYXRoZnJhayBhJCBvZiB0aGUgYmFzZSBhbGdlYnJhIG9mIGBM\nYCBzdWNoIHRoYXQKJFxtYXRoZnJhayBhIExeXCMgPSBMJCwgd2hlcmUgJExe\nXCMkIGlzIHRoZSBkdWFsIG9mIGBMYC4KIiIiCmZ1bmN0aW9uIGlzX21vZHVs\nYXIoTDo6QWJzdHJhY3RMYXQpCiAgYSA9IHNjYWxlKEwpCiAgaWYgdm9sdW1l\nKEwpID09IGFecmFuayhMKQogICAgcmV0dXJuIHRydWUsIGEKICBlbHNlCiAg\nICByZXR1cm4gZmFsc2UsIGEKICBlbmQKZW5kCgpAZG9jIHJhdyIiIgogICAg\naXNfbW9kdWxhcihMOjpBYnN0cmFjdExhdCwgcCkgLT4gQm9vbCwgSW50CgpS\nZXR1cm4gd2hldGhlciB0aGUgY29tcGxldGlvbiAkTF97cH0kIG9mIHRoZSBs\nYXR0aWNlIGBMYCBhdCB0aGUgcHJpbWUgaWRlYWwgb3IKaW50ZWdlciBgcGAg\naXMgbW9kdWxhci4gSWYgaXQgaXMgdGhlIGNhc2UgdGhlIHNlY29uZCByZXR1\ncm5lZCB2YWx1ZSBpcyBhbgppbnRlZ2VyIGB2YCBzdWNoIHRoYXQgJExfe3B9\nJCBpcyAkcF52JC1tb2R1bGFyLgoiIiIKaXNfbW9kdWxhcig6OkFic3RyYWN0\nTGF0LCBwKQoKZnVuY3Rpb24gaXNfbW9kdWxhcihMOjpBYnN0cmFjdExhdHs8\nOiBOdW1GaWVsZH0sIHApCiAgYSA9IHNjYWxlKEwpCiAgaWYgYmFzZV9yaW5n\nKEwpID09IG9yZGVyKHApCiAgICB2ID0gdmFsdWF0aW9uKGEsIHApCiAgICBp\nZiB2ICogcmFuayhMKSA9PSB2YWx1YXRpb24odm9sdW1lKEwpLCBwKQogICAg\nICByZXR1cm4gdHJ1ZSwgdgogICAgZWxzZQogICAgICByZXR1cm4gZmFsc2Us\nIDAKICAgIGVuZAogIGVsc2UKICAgIEBhc3NlcnQgYmFzZV9yaW5nKGJhc2Vf\ncmluZyhMKSkgPT0gb3JkZXIocCkKICAgIHEgPSBwcmltZV9kZWNvbXBvc2l0\naW9uKGJhc2VfcmluZyhMKSwgcClbMV1bMV0KICAgIHYgPSB2YWx1YXRpb24o\nYSwgcSkKICAgIGlmIHYgKiByYW5rKEwpID09IHZhbHVhdGlvbih2b2x1bWUo\nTCksIHEpCiAgICAgIHJldHVybiB0cnVlLCB2CiAgICBlbHNlCiAgICAgIHJl\ndHVybiBmYWxzZSwgMAogICAgZW5kCiAgZW5kCmVuZAoKIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIwojICBMb2NhbCBiYXNpcyBtYXRy\naXgKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoKQGRv\nYyByYXciIiIKICAgIGxvY2FsX2Jhc2lzX21hdHJpeChMOjpBYnN0cmFjdExh\ndCwgcDo6QWJzTnVtRmllbGRPcmRlcklkZWFse0Fic1NpbXBsZU51bUZpZWxk\nLCBBYnNTaW1wbGVOdW1GaWVsZEVsZW19OyB0eXBlID0gOmFueSkgLT4gTWF0\nRWxlbQoKR2l2ZW4gYSBwcmltZSBpZGVhbCBgcGAgYW5kIGEgbGF0dGljZSBg\nTGAsIHJldHVybiBhIGJhc2lzIG1hdHJpeCBvZiBhIGxhdHRpY2UKYE1gIHN1\nY2ggdGhhdCAkTV97cH0gPSBMX3twfSQuIE5vdGUgdGhhdCBpZiBgcGAgaXMg\nYW4gaWRlYWwgaW4gdGhlIGJhc2UgcmluZyBvZgpgTGAsIHRoZSBjb21wbGV0\naW9ucyBhcmUgdGFrZW4gYXQgdGhlIG1pbmltdW0gb2YgYHBgICh3aGljaCBp\ncyBhbiBpZGVhbCBpbiB0aGUKYmFzZSByaW5nIG9mIHRoZSBvcmRlciBvZiBg\ncGApLgoKLSBJZiBgdHlwZSA9PSA6c3VibW9kdWxlYCwgdGhlIGxhdHRpY2Ug\nYE1gIHdpbGwgYmUgYSBzdWJsYXR0aWNlIG9mIGBMYC4KLSBJZiBgdHlwZSA9\nPSA6c3VwZXJtb2R1bGVgLCB0aGUgbGF0dGljZSBgTWAgd2lsbCBiZSBhIHN1\ncGVybGF0dGljZSBvZiBgTGAuCi0gSWYgYHR5cGUgPT0gOmFueWAsIHRoZXJl\nIG1heSBub3QgYmUgYW55IGNvbnRhaW5tZW50IHJlbGF0aW9uIGJldHdlZW4g\nYE1gIGFuZAogIGBMYC4KIiIiCmZ1bmN0aW9uIGxvY2FsX2Jhc2lzX21hdHJp\neChMOjpBYnN0cmFjdExhdCwgcDsgdHlwZTo6U3ltYm9sID0gOmFueSkKICBS\nID0gYmFzZV9yaW5nKEwpCiAgUyA9IG9yZGVyKHApCiAgaWYgUiA9PT0gUwog\nICAgcmV0dXJuIGxvY2FsX2Jhc2lzX21hdHJpeChMLCBtaW5pbXVtKHApLCB0\neXBlID0gdHlwZSkKICAgICNpZiB0eXBlID09IDphbnkKICAgICMgIHJldHVy\nbiBfbG9jYWxfYmFzaXNfbWF0cml4KHBzZXVkb19tYXRyaXgoTCksIHApCiAg\nICAjZWxzZWlmIHR5cGUgPT0gOnN1Ym1vZHVsZQogICAgIyAgcmV0dXJuIF9s\nb2NhbF9iYXNpc19zdWJtb2R1bGVfbWF0cml4KHBzZXVkb19tYXRyaXgoTCks\nIHApCiAgICAjZWxzZWlmIHR5cGUgPT0gOnN1cGVybW9kdWxlCiAgICAjICBy\nZXR1cm4gX2xvY2FsX2Jhc2lzX3N1cGVybW9kdWxlX21hdHJpeChwc2V1ZG9f\nbWF0cml4KEwpLCBwKQogICAgI2Vsc2UKICAgICMgIGVycm9yKCIiIkludmFs\naWQgOnR5cGUga2V5d29yZCA6JCh0eXBlKS4KICAgICMgICAgICAgICAgIE11\nc3QgYmUgZWl0aGVyIDphbnksIDpzdWJtb2R1bGUsIG9yIDpzdXBlcm1vZHVs\nZSIiIikKICAgICNlbmQKICBlbHNlaWYgUyA9PT0gYmFzZV9yaW5nKFIpCiAg\nICBpZiB0eXBlID09IDphbnkKICAgICAgcmV0dXJuIF9sb2NhbF9iYXNpc19t\nYXRyaXhfcHJpbWVfYmVsb3cocHNldWRvX21hdHJpeChMKSwgcCkKICAgIGVs\nc2VpZiB0eXBlID09IDpzdWJtb2R1bGUKICAgICAgcmV0dXJuIF9sb2NhbF9i\nYXNpc19tYXRyaXhfcHJpbWVfYmVsb3dfc3VibW9kdWxlKHBzZXVkb19tYXRy\naXgoTCksIHApCiAgICBlbHNlaWYgdHlwZSA9PSA6c3VwZXJtb2R1bGUKICAg\nICAgdGhyb3coTm90SW1wbGVtZW50ZWQoKSkKICAgIGVsc2UKICAgICAgZXJy\nb3IoIiIiSW52YWxpZCA6dHlwZSBrZXl3b3JkIDokKHR5cGUpLgogICAgICAg\nICAgICAgICBNdXN0IGJlIGVpdGhlciA6YW55LCA6c3VibW9kdWxlLCBvciA6\nc3VwZXJtb2R1bGUiIiIpCiAgICBlbmQKICBlbHNlCiAgICBlcnJvcigiU29t\nZXRoaW5nIHdyb25nIikKICBlbmQKZW5kCgojIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIwojCiMgIEpvcmRhbiBkZWNvbXBvc2l0aW9uCiMK\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCkBkb2MgcmF3\nIiIiCiAgICBqb3JkYW5fZGVjb21wb3NpdGlvbihMOjpBYnN0cmFjdExhdCwg\ncDo6QWJzTnVtRmllbGRPcmRlcklkZWFse0Fic1NpbXBsZU51bUZpZWxkLCBB\nYnNTaW1wbGVOdW1GaWVsZEVsZW19KQogICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgIC0+IFZlY3RvcntNYXRFbGVtfSwgVmVjdG9ye01hdEVsZW19\nLCBWZWN0b3J7SW50fQoKUmV0dXJuIGEgSm9yZGFuIGRlY29tcG9zaXRpb24g\nb2YgdGhlIGNvbXBsZXRpb24gb2YgdGhlIGxhdHRpY2UgYExgIGF0IGEgcHJp\nbWUKaWRlYWwgYHBgLgoKVGhlIHJldHVybmVkIHZhbHVlIGNvbnNpc3RzIG9m\nIHRocmVlIGxpc3RzICQoTV9pKV9pJCwgJChHX2kpX2kkIGFuZCAkKHNfaSlf\naSQgb2YKdGhlIHNhbWUgbGVuZ3RoICRyJC4gVGhlIGNvbXBsZXRpb25zIG9m\nIHRoZSByb3cgc3BhbnMgb2YgdGhlIG1hdHJpY2VzICRNX2kkCnlpZWxkIGEg\nSm9yZGFuIGRlY29tcG9zaXRpb24gb2YgJExfe3B9JCBpbnRvIG1vZHVsYXIg\nc3VibGF0dGljZXMKJExfaSQgd2l0aCBHcmFtIG1hdHJpY2VzICRHX2kkIGFu\nZCBzY2FsZSBvZiAkcCQtYWRpYyB2YWx1YXRpb24gJHNfaSQuCiIiIgpqb3Jk\nYW5fZGVjb21wb3NpdGlvbihMOjpBYnN0cmFjdExhdCwgcDo6QWJzTnVtRmll\nbGRPcmRlcklkZWFse0Fic1NpbXBsZU51bUZpZWxkLCBBYnNTaW1wbGVOdW1G\naWVsZEVsZW19KQoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMKIwojICBMb2NhbCBpc29tZXRyeQojCiMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjCgpAZG9jIHJhdyIiIgogICAgaXNfbG9jYWxseV9p\nc29tZXRyaWMoTDo6QWJzdHJhY3RMYXQsIE06OkFic3RyYWN0TGF0LCBwOjpB\nYnNOdW1GaWVsZE9yZGVySWRlYWx7QWJzU2ltcGxlTnVtRmllbGQsIEFic1Np\nbXBsZU51bUZpZWxkRWxlbX0pIC0+IEJvb2wKClJldHVybiB3aGV0aGVyIHRo\nZSBjb21wbGV0aW9ucyBvZiB0aGUgbGF0dGljZXMgYExgIGFuZCBgTWAgYXQg\ndGhlIHByaW1lIGlkZWFsCmBwYCBhcmUgaXNvbWV0cmljLgoiIiIKaXNfbG9j\nYWxseV9pc29tZXRyaWMoOjpBYnN0cmFjdExhdCwgOjpBYnN0cmFjdExhdCwg\nOjpBYnNOdW1GaWVsZE9yZGVySWRlYWx7QWJzU2ltcGxlTnVtRmllbGQsIEFi\nc1NpbXBsZU51bUZpZWxkRWxlbX0pCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIwojCiMgIElzb3Ryb3B5CiMKIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMKCkBkb2MgcmF3IiIiCiAgICBpc19pc290\ncm9waWMoTDo6QWJzdHJhY3RMYXQsIHA6OlVuaW9ue0Fic051bUZpZWxkT3Jk\nZXJJZGVhbHtBYnNTaW1wbGVOdW1GaWVsZCwgQWJzU2ltcGxlTnVtRmllbGRF\nbGVtfSwgSW5mUGxjfSkgLT4gQm9vbAoKUmV0dXJuIHdoZXRoZXIgdGhlIGNv\nbXBsZXRpb24gb2YgdGhlIGxhdHRpY2UgYExgIGF0IHRoZSBwbGFjZSBgcGAg\naXMKaXNvdHJvcGljLgoiIiIKaXNfaXNvdHJvcGljKEw6OkFic3RyYWN0TGF0\nLCBwKSA9IGlzX2lzb3Ryb3BpYyhyYXRpb25hbF9zcGFuKEwpLCBwKQoKIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKIwojICBSZXN0cmlj\ndCBzY2FsYXJzCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMKCkBkb2MgcmF3IiIiCiAgICByZXN0cmljdF9zY2FsYXJzKEw6OkFic3Ry\nYWN0TGF0LCBLOjpRUUZpZWxkLAogICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgYWxwaGE6OkZpZWxkRWxlbSA9IG9uZShiYXNlX2ZpZWxk\nKEwpKSkgLT4gWlpMYXQKCkdpdmVuIGEgbGF0dGljZSBgTGAgaW4gYSBzcGFj\nZSAkKFYsIFxQaGkpJCwgcmV0dXJuIHRoZSAkXG1hdGhjYWwgT19LJC1sYXR0\naWNlCm9idGFpbmVkIGJ5IHJlc3RyaWN0aW5nIHRoZSBzY2FsYXJzIG9mICQo\nViwgXGFscGhhXFBoaSkkIHRvIHRoZSBudW1iZXIgZmllbGQgYEtgLgpUaGUg\ncmVzY2FsaW5nIGZhY3RvciAkXGFscGhhJCBpcyBzZXQgdG8gMSBieSBkZWZh\ndWx0LgoKTm90ZSB0aGF0IGZvciBub3cgb25lIGNhbiBvbmx5IHJlc3RyaWN0\nIHNjYWxhcnMgdG8gJFxtYXRoYmIgUSQuCiIiIgpmdW5jdGlvbiByZXN0cmlj\ndF9zY2FsYXJzKEw6OkFic3RyYWN0TGF0LCBLOjpRUUZpZWxkLAogICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTo6Rmll\nbGRFbGVtID0gb25lKGJhc2VfZmllbGQoTCkpKQogIFYgPSBhbWJpZW50X3Nw\nYWNlKEwpCiAgVmFicywgZiA9IHJlc3RyaWN0X3NjYWxhcnMoViwgSywgYWxw\naGEpCiAgQmFicyA9IGFic29sdXRlX2Jhc2lzKEwpCiAgTWFicyA9IHplcm9f\nbWF0cml4KFFRLCBsZW5ndGgoQmFicyksIHJhbmsoVmFicykpCiAgZm9yIGkg\naW4gMTpsZW5ndGgoQmFicykKICAgIHYgPSBmXChCYWJzW2ldKQogICAgZm9y\nIGogaW4gMTpsZW5ndGgodikKICAgICAgTWFic1tpLCBqXSA9IHZbal0KICAg\nIGVuZAogIGVuZAogIHJldHVybiBaWkxhdChWYWJzLCBNYWJzKQplbmQKCkBk\nb2MgcmF3IiIiCiAgICByZXN0cmljdF9zY2FsYXJzX3dpdGhfbWFwKEw6OkFi\nc3RyYWN0TGF0LCBLOjpRUUZpZWxkLAogICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6OkZpZWxkRWxlbSA9IG9u\nZShiYXNlX2ZpZWxkKEwpKSkKICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBUdXBsZXtaWkxhdCwg\nQWJzdHJhY3RTcGFjZVJlc30KCkdpdmVuIGEgbGF0dGljZSBgTGAgaW4gYSBz\ncGFjZSAkKFYsIFxQaGkpJCwgcmV0dXJuIHRoZSAkXG1hdGhjYWwgT19LJC1s\nYXR0aWNlCm9idGFpbmVkIGJ5IHJlc3RyaWN0aW5nIHRoZSBzY2FsYXJzIG9m\nICQoViwgXGFscGhhXFBoaSkkIHRvIHRoZSBudW1iZXIgZmllbGQgYEtgLAp0\nb2dldGhlciB3aXRoIHRoZSBtYXAgYGZgIGZvciBleHRlbmRpbmcgc2NhbGFy\ncyBiYWNrLgpUaGUgcmVzY2FsaW5nIGZhY3RvciAkXGFscGhhJCBpcyBzZXQg\ndG8gMSBieSBkZWZhdWx0LgoKTm90ZSB0aGF0IGZvciBub3cgb25lIGNhbiBv\nbmx5IHJlc3RyaWN0IHNjYWxhcnMgdG8gJFxtYXRoYmIgUSQuCiIiIgpmdW5j\ndGlvbiByZXN0cmljdF9zY2FsYXJzX3dpdGhfbWFwKEw6OkFic3RyYWN0TGF0\nLCBLOjpRUUZpZWxkLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICBhbHBoYTo6RmllbGRFbGVtID0gb25lKGJh\nc2VfZmllbGQoTCkpKQogIFYgPSBhbWJpZW50X3NwYWNlKEwpCiAgVmFicywg\nZiA9IHJlc3RyaWN0X3NjYWxhcnMoViwgSywgYWxwaGEpCiAgQmFicyA9IGFi\nc29sdXRlX2Jhc2lzKEwpCiAgTWFicyA9IHplcm9fbWF0cml4KFFRLCBsZW5n\ndGgoQmFicyksIHJhbmsoVmFicykpCiAgZm9yIGkgaW4gMTpsZW5ndGgoQmFi\ncykKICAgIHYgPSBmXChCYWJzW2ldKQogICAgZm9yIGogaW4gMTpsZW5ndGgo\ndikKICAgICAgTWFic1tpLCBqXSA9IHZbal0KICAgIGVuZAogIGVuZAogIHJl\ndHVybiBaWkxhdChWYWJzLCBNYWJzKSwgZgplbmQKCkBkb2MgcmF3IiIiCiAg\nICByZXN0cmljdF9zY2FsYXJzKEw6OkFic3RyYWN0TGF0LCBmOjpBYnN0cmFj\ndFNwYWNlUmVzKSAtPiBaWkxhdAoKR2l2ZW4gYSBsYXR0aWNlIGBMYCBpbiBh\nIHNwYWNlICQoViwgXFBoaSkkIGFuZCBhIG1hcCBgZmAgZm9yIHJlc3RyaWN0\naW5nIHRoZQpzY2FsYXJzIG9mICQoViwgXGFscGhhXFBoaSkkIHRvIGEgbnVt\nYmVyIGZpZWxkIGBLYCwgd2hlcmUgJFxhbHBoYSQgaXMgaW4gdGhlCmJhc2Ug\nYWxnZWJyYSBvZiBgTGAsIHJldHVybiB0aGUgYXNzb2NpYXRlZCAkXG1hdGhj\nYWwgT19LJC1sYXR0aWNlIG9idGFpbmVkIGZyb20KYExgIHdpdGggcmVzcGVj\ndCB0byBgZmAuCgpOb3RlIHRoYXQgZm9yIG5vdyBvbmUgY2FuIG9ubHkgcmVz\ndHJpY3Qgc2NhbGFycyB0byAkXG1hdGhiYiBRJC4KIiIiCmZ1bmN0aW9uIHJl\nc3RyaWN0X3NjYWxhcnMoTDo6QWJzdHJhY3RMYXQsIGY6OkFic3RyYWN0U3Bh\nY2VSZXMpCiAgQHJlcSBhbWJpZW50X3NwYWNlKEwpID09PSBjb2RvbWFpbihm\nKSAiSW5jb21wYXRpYmxlIGFyZ3VtZW50czogYW1iaWVudCBzcGFjZSBvZiBM\nIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIGNvZG9tYWluIG9mIGYiCiAgVmFi\ncyA9IGRvbWFpbihmKQogIEJhYnMgPSBhYnNvbHV0ZV9iYXNpcyhMKQogIE1h\nYnMgPSB6ZXJvX21hdHJpeChRUSwgbGVuZ3RoKEJhYnMpLCByYW5rKFZhYnMp\nKQogIGZvciBpIGluIDE6bGVuZ3RoKEJhYnMpCiAgICB2ID0gZlwoQmFic1tp\nXSkKICAgIGZvciBqIGluIDE6bGVuZ3RoKHYpCiAgICAgIE1hYnNbaSwgal0g\nPSB2W2pdCiAgICBlbmQKICBlbmQKICByZXR1cm4gWlpMYXQoVmFicywgTWFi\ncykKZW5kCgojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoj\nCiMgIFRyYWNlIGVxdWl2YWxlbmNlCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMKCiMgVE9ETzogYWRkIGpsZG9jdGVzdApAZG9jIHJh\ndyIiIgogICAgdHJhY2VfbGF0dGljZV93aXRoX2lzb21ldHJ5KEg6OkFic3Ry\nYWN0TGF0e1R9OwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFs\ncGhhOjpGaWVsZEVsZW0gPSBvbmUoYmFzZV9maWVsZChIKSksCiAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgYmV0YTo6RmllbGRFbGVtID0gZ2Vu\nKGJhc2VfZmllbGQoSCkpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgIG9yZGVyOjpJbnRlZ2VyID0gMikgd2hlcmUgVCAgLT4gWlpMYXQsIFFR\nTWF0cml4CgpHaXZlbiBhIGxhdHRpY2UgYEhgIHdoaWNoIGlzIGVpdGhlcjoK\nCiAgIC0gYSAkXG1hdGhiYiBaJC1sYXR0aWNlIChpLmUuIG9mIHR5cGUgYFpa\nTGF0YCk7CiAgIC0gYSBoZXJtaXRpYW4gbGF0dGljZSBvdmVyIGEgQ00tZXh0\nZW5zaW9uICRFL0skLCB3aGVyZSAkRS9cbWF0aGJie1F9JCBpcyBkZWZpbmVk\nCiAgICAgYnkgYW4gaXJyZWR1Y2libGUgbW9uaWMgcG9seW5vbWlhbCAkcCQg\nd2l0aCAkcCgwKSA9IDEkCgpyZXR1cm4gdGhlIHBhaXIgJChMLCBmKSQgd2hl\ncmUgJEwkIGlzIGEgJFxtYXRoYmJ7Wn0kLWxhdHRpY2Ugb2J0YWluZWQgYXMg\ndGhlIHRyYWNlCmxhdHRpY2Ugb2YgJEgkIFtgcmVzdHJpY3Rfc2NhbGFycyg6\nOkFic3RyYWN0TGF0KWBdKEByZWYpKSBhbmQgJGYkIGlzIGFuIGlzb21ldHJ5\nCm9mICRMJCBnaXZlbiBieToKCiAgIC0gdGhlIGlkZW50aXR5IGlmICRIJCBp\ncyBhIGBaWkxhdGAgYW5kIGBvcmRlciA9PSAxYDsKICAgLSB0aGUgb3Bwb3Np\ndGUgb2YgdGhlIGlkZW50aXR5IGlmICRIJCBpcyBhIGBaWkxhdGAgYW5kIGBv\ncmRlciA9PSAyYDsKICAgLSBnaXZlbiBieSB0aGUgbXVsdGlwbGljYXRpb24g\nYnkgYW4gZWxlbWVudCBgYmV0YWAgb2Ygbm9ybSAxIGluICRFJAogICAgIG90\naGVyd2lzZS4KCk5vdGUgdGhhdCB0aGUgb3B0aW9uYWwgYXJndW1lbnQgYG9y\nZGVyYCBoYXMgbm8gZWZmZWN0IGlmIGBIYCBpcyBub3QgYQokXG1hdGhiYiBa\nJC1sYXR0aWNlLgoKVGhlIGNob2ljZSBvZiBgYWxwaGFgIGNvcnJlc3BvbmRz\nIHRvIHRoZSBjaG9pY2Ugb2YgYSByZXNjYWxpbmcgb2YgdGhlIGZvcm0gb24g\nJEgkCmZvciB0aGUgdHJhY2UgY29uc3RydWN0aW9uIHVzaW5nIFtgcmVzdHJp\nY3Rfc2NhbGFyc2BdKEByZWYpLgoKVGhlIGNob2ljZSBvZiBgYmV0YWAgY29y\ncmVzcG9uZHMgdG8gdGhlIGNob2ljZSBvZiBhbiBlbGVtZW50IG9mIG5vcm0g\nMSBpbiB0aGUKYmFzZSBmaWVsZCBvZiAkSCQsIGluIHRoZSBoZXJtaXRpYW4g\nY2FzZSwgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGlzb21ldHJ5IGBmYC4KCk5v\ndGUgdGhhdCB0aGUgaXNvbWV0cnkgYGZgIGNvbXB1dGVkIGlzIGdpdmVuIGJ5\nIGl0cyBhY3Rpb24gb24gdGhlIGFtYmllbnQgc3BhY2Ugb2YgdGhlCnRyYWNl\nIGxhdHRpY2Ugb2YgYEhgLgoiIiIKZnVuY3Rpb24gdHJhY2VfbGF0dGljZV93\naXRoX2lzb21ldHJ5KEg6OkFic3RyYWN0TGF0e1R9OyBhbHBoYTo6RmllbGRF\nbGVtID0gb25lKGJhc2VfZmllbGQoSCkpLAogICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJldGE6OkZp\nZWxkRWxlbSA9IGdlbihiYXNlX2ZpZWxkKEgpKSwKICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRl\ncjo6SW50ZWdlciA9IDIpIHdoZXJlIFQKCiAgcmV0dXJuIHRyYWNlX2xhdHRp\nY2Vfd2l0aF9pc29tZXRyeV9hbmRfdHJhbnNmZXJfZGF0YShIOyBhbHBoYSwg\nYmV0YSwgb3JkZXIpWzE6Ml0KZW5kCgojIFRPRE86IGFkZCBqbGRvY3Rlc3QK\nQGRvYyByYXciIiIKICAgIHRyYWNlX2xhdHRpY2Vfd2l0aF9pc29tZXRyeV9h\nbmRfdHJhbnNmZXJfZGF0YShIOjpBYnN0cmFjdExhdHtUfTsKICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBo\nYTo6RmllbGRFbGVtID0gb25lKGJhc2VfZmllbGQoSCkpLAogICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJldGE6\nOkZpZWxkRWxlbSA9IGdlbihiYXNlX2ZpZWxkKEgpKSwKICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjo6\nSW50ZWdlciA9IDIpIHdoZXJlIFQKICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IFpaTGF0LCBRUU1h\ndHJpeCwgQWJzdHJhY3RTcGFjZVJlcwoKUmV0dXJuIHRoZSB0cmFjZSBsYXR0\naWNlIG9mIGBIYCB0b2dldGhlciB3aXRoIHRoZSBhc3NvY2lhdGVkIGlzb21l\ndHJ5IGNvcnJlc3BvbmRpbmcKdG8gbXVsdGlwbGljYXRpb24gYnkgYGJldGFg\nIChzZWUgW2B0cmFjZV9sYXR0aWNlKDo6QWJzdHJhY3RMYXQpYF0oQHJlZikp\nIGFuZCB3aXRoCnRoZSBtYXAgb2YgY2hhbmdlIG9mIHNjYWxhcnMgYXNzb2Np\nYXRlZCB0byB0aGUgdW5kZXJseWluZyB0cmFjZSBjb25zdHJ1Y3Rpb24uCiIi\nIgpmdW5jdGlvbiB0cmFjZV9sYXR0aWNlX3dpdGhfaXNvbWV0cnlfYW5kX3Ry\nYW5zZmVyX2RhdGEoSDo6QWJzdHJhY3RMYXR7VH07IGFscGhhOjpGaWVsZEVs\nZW0gPSBvbmUoYmFzZV9maWVsZChIKSksCiAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgYmV0YTo6RmllbGRFbGVtID0gZ2VuKGJhc2VfZmllbGQoSCkp\nLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyOjpJbnRlZ2Vy\nID0gMiwgY2hlY2s6OkJvb2w9dHJ1ZSkgd2hlcmUgVAogIEUgPSBiYXNlX2Zp\nZWxkKEgpCgogICMgV2Ugb25seSBjb25zaWRlciBmdWxsIHJhbmsgbGF0dGlj\nZXMgZm9yIHNpbXBsaWNpdHkKICBAcmVxIGRlZ3JlZShIKSA9PSByYW5rKEgp\nICJMYXR0aWNlIG11c3QgYmUgb2YgZnVsbCByYW5rIgogIEByZXEgcGFyZW50\nKGJldGEpID09PSBFICJiZXRhIG11c3QgYmUgYW4gZWxlbWVudCBvZiB0aGUg\nYmFzZSBhbGdlYnJhIG9mIEgiCiAgaWYgY2hlY2sKICAgIEByZXEgKGJldGEg\nPT0gUVEoMSkgfHwgbm9ybShiZXRhKSA9PSAxKSAiYmV0YSBtdXN0IGJlIG9m\nIG5vcm0gMSIKICBlbmQKICBAcmVxICFpc196ZXJvKGFscGhhKSAiYWxwaGEg\nbXVzdCBiZSBub24gemVybyIKCiAgbiA9IGRlZ3JlZShIKQoKICBpZiBFID09\nIFFRCiAgICBAcmVxIG9yZGVyIGluIFsxLDJdICJGb3IgWlpMYXQgdGhlIG9y\nZGVyIG11c3QgYmUgMSBvciAyIgogICAgViA9IGFtYmllbnRfc3BhY2UoSCkK\nICAgIGlmIG9yZGVyID09IDEKICAgICAgZiA9IGlkZW50aXR5X21hdHJpeChF\nLCBuKQogICAgZWxzZQogICAgICBmID0gLWlkZW50aXR5X21hdHJpeChFLCBu\nKQogICAgZW5kCiAgICByZXR1cm4gSCwgZiwgQWJzdHJhY3RTcGFjZVJlcyhW\nLCBWLCBpZGVudGl0eV9tYXRyaXgoRSwgbiksIGlkZW50aXR5X21hdHJpeChF\nLCBuKSkKICBlbmQKCiAgQHJlcSBIIGlzYSBIZXJtTGF0ICJIIG11c3QgYmUg\naGVybWl0aWFuIG9yIGRlZmluZWQgb3ZlciB0aGUgaW50ZWdlcnMiCiAgI0By\nZXEgbWF4aW1hbF9vcmRlcihFKSA9PSBlcXVhdGlvbl9vcmRlcihFKSAiRXF1\nYXRpb24gb3JkZXIgYW5kIG1heGltYWwgb3JkZXIgbXVzdCBjb2luY2lkZSIK\nCiAgIyBUaGlzIGZ1bmN0aW9uIHBlcmZvcm0gdGhlIHRyYWNlIGNvbnN0cnVj\ndGlvbiBvbiB0aGUgbGV2ZWwgb2YgdGhlCiAgIyBhbWJpZW50IHNwYWNlcyAt\nIHdlIGp1c3QgbmVlZCB0byB0cmFuc3BvcnQgdGhlIGxhdHRpY2UKICBMcmVz\nLCByZXMgPSByZXN0cmljdF9zY2FsYXJzX3dpdGhfbWFwKEgsIFFRLCBhbHBo\nYSkKCiAgIyBUaGlzIHdpbGwgY29ycmVzcG9uZCB0byBtdWx0aXBsaWNhdGlv\nbiBieSBiZXRhIGFsb25nIHRoZSB0cmFuc2ZlcgogIGlzbyA9IHplcm9fbWF0\ncml4KFFRLCAwLCBkZWdyZWUoTHJlcykpCgogIHYgPSB6ZXJvX21hdHJpeChR\nUSwgMSwgZGVncmVlKExyZXMpKQoKICBmb3IgaSBpbiAxOmRlZ3JlZShMcmVz\nKQogICAgdltpXSA9IG9uZShRUSkKICAgIHYyID0gcmVzKHYpCiAgICB2MiA9\nIGJldGEuKnYyCiAgICB2MyA9IChyZXNcdjIpCiAgICBpc28gPSB2Y2F0KGlz\nbywgbWF0cml4KFFRLCAxLCBsZW5ndGgodjMpLCB2MykpOjpRUU1hdHJpeAog\nICAgdltpXSA9IHplcm8oUVEpCiAgZW5kCgogIEBoYXNzZXJ0IDpMYXR0aWNl\nIDIgaXNvKmdyYW1fbWF0cml4KGFtYmllbnRfc3BhY2UoTHJlcykpKnRyYW5z\ncG9zZShpc28pID09IGdyYW1fbWF0cml4KGFtYmllbnRfc3BhY2UoTHJlcykp\nCgogIHJldHVybiBMcmVzLCBpc28sIHJlcwplbmQKCiMgVE9ETzogYWRkIGps\nZG9jdGVzdApAZG9jIHJhdyIiIgogICAgdHJhY2VfbGF0dGljZV93aXRoX2lz\nb21ldHJ5KEg6Okhlcm1MYXQsIHJlczo6QWJzdHJhY3RTcGFjZVJlcykgd2hl\ncmUgVAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgLT4gWlpMYXQsIFFRTWF0cml4LCBBYnN0cmFjdFNw\nYWNlUmVzCgpSZXR1cm4gdGhlIHRyYWNlIGxhdHRpY2Ugb2YgYEhgIHRvZ2V0\naGVyIHdpdGggdGhlIGFzc29jaWF0ZWQgaXNvbWV0cnkgKHNlZQpbYHRyYWNl\nX2xhdHRpY2UoOjpBYnN0cmFjdExhdClgXShAcmVmKSkgd2l0aCByZXNwZWN0\nIHRvIHRoZSBnaXZlbiBtYXAgb2YgY2hhbmdlIG9mIHNjYWxhcnMKYHJlc2Au\nCiIiIgpmdW5jdGlvbiB0cmFjZV9sYXR0aWNlX3dpdGhfaXNvbWV0cnkoSDo6\nSGVybUxhdCwgcmVzOjpBYnN0cmFjdFNwYWNlUmVzOyBiZXRhOjpGaWVsZEVs\nZW0gPSBnZW4oYmFzZV9maWVsZChIKSkpCiAgRSA9IGJhc2VfZmllbGQoSCkK\nCiAgQHJlcSBjb2RvbWFpbihyZXMpID09PSBhbWJpZW50X3NwYWNlKEgpICJm\nIG11c3QgYmUgYSBtYXAgb2YgcmVzdHJpY3Rpb24gb2Ygc2NhbGFycyBhc3Nv\nY2lhdGVkIHRvIHRoZSBhbWJpZW50IHNwYWNlIG9mIEgiCiAgQHJlcSBkZWdy\nZWUoSCkgPT0gcmFuayhIKSAiTGF0dGljZSBtdXN0IGJlIG9mIGZ1bGwgcmFu\nayIKICBAcmVxIHBhcmVudChiZXRhKSA9PT0gRSAiYmV0YSBtdXN0IGJlIGFu\nIGVsZW1lbnQgb2YgdGhlIGJhc2UgYWxnZWJyYSBvZiBIIgogIEByZXEgKGJl\ndGEgPT0gUVEoMSkgfHwgbm9ybShiZXRhKSA9PSAxKSAiYmV0YSBtdXN0IGJl\nIG9mIG5vcm0gMSIKCiAgQHJlcSBtYXhpbWFsX29yZGVyKEUpID09IGVxdWF0\naW9uX29yZGVyKEUpICJFcXVhdGlvbiBvcmRlciBhbmQgbWF4aW1hbCBvcmRl\nciBtdXN0IGNvaW5jaWRlIgoKICBMcmVzID0gcmVzdHJpY3Rfc2NhbGFycyhI\nLCByZXMpCgogIGlzbyA9IHplcm9fbWF0cml4KFFRLCAwLCBkZWdyZWUoTHJl\ncykpCgogIHYgPSB6ZXJvX21hdHJpeChRUSwgMSwgZGVncmVlKExyZXMpKQoK\nICBmb3IgaSBpbiAxOmRlZ3JlZShMcmVzKQogICAgdltpXSA9IG9uZShRUSkK\nICAgIHYyID0gcmVzKHYpCiAgICB2MiA9IGJldGEuKnYyCiAgICB2MyA9IChy\nZXNcdjIpCiAgICBpc28gPSB2Y2F0KGlzbywgbWF0cml4KFFRLCAxLCBsZW5n\ndGgodjMpLCB2MykpOjpRUU1hdHJpeAogICAgdltpXSA9IHplcm8oUVEpCiAg\nZW5kCgogIEBoYXNzZXJ0IDpMYXR0aWNlIDIgaXNvKmdyYW1fbWF0cml4KGFt\nYmllbnRfc3BhY2UoTHJlcykpKnRyYW5zcG9zZShpc28pID09IGdyYW1fbWF0\ncml4KGFtYmllbnRfc3BhY2UoTHJlcykpCgogIHJldHVybiBMcmVzLCBpc28K\nZW5kCgojIElmIHRoZSBtaW5wb2x5IG9mIGYgaXMgaXJyZWR1Y2libGUsIHJl\ndHVybiBhIGJhc2lzIG9mIHRoZSBRUS12ZWN0b3Igc3BhY2UKIyBvbiB3aGlj\naCBmIGFjdHMgc3VjaCB0aGF0LCBhZnRlciBleHRlbnNpb24gb2Ygc2NhbGFy\ncyB0byBhIHZlY3RvciBzcGFjZQojIG92ZXIgdGhlIHBhcmVudCBvZiBiLCB0\naGUgYXNzb2NpYXRlZCBmLWFjdGlvbiBpcyBnaXZlbiBieSBtdWx0aXBsaWNh\ndGlvbgojIGJ5IGIuIFRoaXMgZnVuY3Rpb24gcmVxdWlyZXMgZiB0byBiZSBp\nbnZlcnRpYmxlLCBiIHRvIGJlIGhhdmUgbm9ybSAxLAojIGIgYW5kIGYgbXVz\ndCBoYXZlIHRoZSBzYW1lIChhYnNvbHV0ZSkgbWluaW1hbCBwb2x5bm9taWFs\nIGFuZCB0aGUgbnVtYmVyCiMgb2Ygcm93cyBvZiBmIHNob3VsZCBiZSBkaXZp\nc2libGUgYnkgdGhlIGFic29sdXRlIGRlZ3JlZSBvZiB0aGUgcGFyZW50IG9m\nIGIKIwojIEhlcmUgX21iIGlzIHRoZSBhc29sdXRlIG11bHRpcGxpY2F0aW9u\nIG1hdHJpeCBvZiBiIGFuZCBtYiBpcyBhIGJsb2NrIGRpYWdvbmFsCiMgbWF0\ncml4IGNvbnNpc3Rpbmcgb2YgYW4gYXBwcm9wcmlhdGUgbnVtYmVyIG9mIGNv\ncGllcyBvZiBfbWIKZnVuY3Rpb24gX2FkbWlzc2libGVfYmFzaXMoZjo6UVFN\nYXRyaXgsIF9tYjo6UVFNYXRyaXgsIG1iOjpRUU1hdHJpeCkKICAjIHdlIGxv\nb2sgZm9yIGEgYmFzaXMgb24gd2hpY2ggZiBhY3RzIGJsb2Nrd2lzZQogICMg\nYXMgbXVsdGlwbGljYXRpb24gYnkgYiBhbG9uZyBleHRlbnNpb24gb2Ygc2Nh\nbGFycwogIGJjYSA9IEhlY2tlLl9iYXNpc19vZl9jb21tdXRhdG9yX2FsZ2Vi\ncmEoZiwgX21iKQogIEBhc3NlcnQgIWlzX2VtcHR5KGJjYSkKCiAgIyBsIHdp\nbGwgYmUgb3VyIG5ldyBiYXNpcywgaXQgaXMgbWFkZSBvZiBzZXZlcmFsIGJs\nb2NrcywKICAjIG0gYmxvY2tzIHRvIGJlIGV4YWN0LgogIGwgPSB6ZXJvX21h\ndHJpeChRUSwgMCwgbmNvbHMoZikpCiAgd2hpbGUgcmFuayhsKSAhPSBuY29s\ncyhmKQogICAgX20gPSBwb3BmaXJzdCEoYmNhKQogICAgX2wgPSB2Y2F0KGws\nIF9tKQogICAgaWYgcmFuayhfbCkgPiByYW5rKGwpCiAgICAgIGwgPSBfbAog\nICAgZW5kCiAgZW5kCgogIEBhc3NlcnQgZGV0KGwpICE9IDAKICBAYXNzZXJ0\nIGwqZiA9PSBtYipsCiAgcmV0dXJuIGwKZW5kCgojVE9ETzogYWRkIGpsZG9j\ndGVzdApAZG9jIHJhdyIiIgogICAgaGVybWl0aWFuX3N0cnVjdHVyZShMOjpa\nWkxhdCwgZjo6UVFNYXRyaXg7IGNoZWNrOjpCb29sID0gdHJ1ZQogICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtYmll\nbnRfcmVwcmVzZW50YXRpb246OkJvb2wgPSB0cnVlKQogICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAtPiBIZXJtTGF0CgpHaXZlbiBhICRcbWF0aGJie1p9JC1s\nYXR0aWNlIGBMYCB0b2dldGhlciB3aXRoIGFuIGlzb21ldHJ5IGBmYCB3aXRo\nIGlycmVkdWNpYmxlIG1pbmltYWwgcG9seW5vbWlhbCwKcmV0dXJuIHRoZSBh\nc3NvY2lhdGVkIGhlcm1pdGlhbiBzdHJ1Y3R1cmUgb24gYChMLCBmKWAuCgpO\nb3RlIHRoYXQgYGZgIG11c3QgYmUgb2YgaW5maW5pdGUgb3JkZXIgb3Igb2Yg\nb3JkZXIgYXQgbGVhc3QgMy4gSW4gd2hpY2ggY2FzZSwgdGhlIHJhbmsgb2Yg\ndGhlIGxhdHRpY2UgYExgCnNob3VsZCBiZSBkaXZpc2libGUgYnkgdGhlIGRl\nZ3JlZSBvZiB0aGUgbWluaW1hbCBwb2x5bm9taWFsIG9mIGBmYC4KCklmIGBM\nYCBpcyBub3Qgb2YgZnVsbCByYW5rLCB0aGVuIHRoZSBhc3NvY2lhdGVkIG1h\ncCBvZiBjaGFuZ2Ugb2Ygc2NhbGFycyBpcyBkZWZpbmVkIG9uIHRoZSByYXRp\nb25hbApzcGFuIG9mIGBMYCAoc2VlIFtgcmF0aW9uYWxfc3Bhbig6OlpaTGF0\nKWBdKEByZWYpKSwgc2luY2Ugb25seSB0aGUgYWN0aW9uIG9uIHRoZSByYXRp\nb25hbCBzcGFuIG9mIHRoZSBsYXR0aWNlCm1hdHRlcnMgZm9yIHRoZSB0cmFj\nZSBlcXVpdmFsZW5jZS4gSWYgYExgIGlzIG9mIGZ1bGwgcmFuaywgd2UgdXNl\nIGl0cyBhbWJpZW50IHNwYWNlIGFzIHJhdGlvbmFsIHNwYW4gc2luY2UgYm90\naAphcmUgaXNvbWV0cmljIChzZWUgW2BhbWJpZW50X3NwYWNlKDo6WlpMYXQp\nYF0oQHJlZikpCgpJZiBgYW1iaWVudF9yZXByZXNlbnRhdGlvbmAgaXMgc2V0\nIHRvIHRydWUsIHRoZW4gdGhlIGlzb21ldHJ5IGBmYCBpcyBzZWVuIGFzIGFu\nIGlzb21ldHJ5IG9mIHRoZSBhbWJpZW50IHNwYWNlIG9mIGBMYC4KSWYgYGNo\nZWNrID09IHRydWVgLCB0aGVuIHRoZSBmdW5jdGlvbiBjaGVja3Mgd2hldGhl\nciB0aGUgbWluaW1hbCBwb2x5bm9taWFsIG9mIHRoZSBhY3Rpb24gb2YgYGZg\nIG9uIHRoZSByYXRpb25hbApzcGFuIG9mIGBMYCBpcyBpcnJlZHVjaWJsZS4K\nIiIiCmZ1bmN0aW9uIGhlcm1pdGlhbl9zdHJ1Y3R1cmUoTDo6WlpMYXQsIGY6\nOlFRTWF0cml4OyBjaGVjazo6Qm9vbCA9IHRydWUsCiAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWJpZW50\nX3JlcHJlc2VudGF0aW9uOjpCb29sID0gdHJ1ZSwKICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlczo6VW5p\nb257Tm90aGluZywgQWJzdHJhY3RTcGFjZVJlc30gPSBub3RoaW5nLAogICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgRTo6VW5pb257Tm90aGluZywgUmVsU2ltcGxlTnVtRmllbGR9ID0gbm90\naGluZykKCiAgcmV0dXJuIGhlcm1pdGlhbl9zdHJ1Y3R1cmVfd2l0aF90cmFu\nc2Zlcl9kYXRhKEwsIGY7IGNoZWNrLCBhbWJpZW50X3JlcHJlc2VudGF0aW9u\nLCByZXMsIEUpWzFdCmVuZAoKIyBUT0RPOiBhZGQgamxkb2N0ZXN0CkBkb2Mg\ncmF3IiIiCiAgICBoZXJtaXRpYW5fc3RydWN0dXJlX3dpdGhfdHJhbnNmZXJf\nZGF0YShMOjpaWkxhdCwgZjo6UVFNYXRyaXg7IGNoZWNrOjpCb29sID0gdHJ1\nZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgYW1iaWVudF9yZXByZXNlbnRhdGlv\nbjo6Qm9vbCA9IHRydWUpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgIC0+IEhlcm1MYXQsIEFic3RyYWN0U3BhY2VSZXMKCkdpdmVuIGEgJFxt\nYXRoYmJ7Wn0kLWxhdHRpY2UgYExgIHRvZ2V0aGVyIHdpdGggYW4gaXNvbWV0\ncnkgYGZgIHdpdGggaXJyZWR1Y2libGUgbWluaW1hbCBwb2x5bm9taWFsLApy\nZXR1cm4gdGhlIGFzc29jaWF0ZWQgaGVybWl0aWFuIHN0cnVjdHVyZSBvbiBg\nKEwsIGYpYCB0b2dldGhlciB3aXRoIHRoZSBtYXAgb2YgY2hhbmdlIG9mIHNj\nYWxhcnMuCgpOb3RlIHRoYXQgYGZgIG11c3QgYmUgb2YgaW5maW5pdGUgb3Jk\nZXIgb3Igb2Ygb3JkZXIgYXQgbGVhc3QgMy4gSW4gd2hpY2ggY2FzZSwgdGhl\nIHJhbmsgb2YgdGhlIGxhdHRpY2UgYExgCnNob3VsZCBiZSBkaXZpc2libGUg\nYnkgdGhlIGRlZ3JlZSBvZiB0aGUgbWluaW1hbCBwb2x5bm9taWFsIG9mIGBm\nYC4KCklmIGBMYCBpcyBub3Qgb2YgZnVsbCByYW5rLCB0aGVuIHRoZSBhc3Nv\nY2lhdGVkIG1hcCBvZiBjaGFuZ2Ugb2Ygc2NhbGFycyBpcyBkZWZpbmVkIG9u\nIHRoZSByYXRpb25hbApzcGFuIG9mIGBMYCAoc2VlIFtgcmF0aW9uYWxfc3Bh\nbig6OlpaTGF0KWBdKEByZWYpKSwgc2luY2Ugb25seSB0aGUgYWN0aW9uIG9u\nIHRoZSByYXRpb25hbCBzcGFuIG9mIHRoZSBsYXR0aWNlCm1hdHRlcnMgZm9y\nIHRoZSB0cmFjZSBlcXVpdmFsZW5jZS4gSWYgYExgIGlzIG9mIGZ1bGwgcmFu\naywgd2UgdXNlIGl0cyBhbWJpZW50IHNwYWNlIGFzIHJhdGlvbmFsIHNwYW4g\nc2luY2UgYm90aAphcmUgaXNvbWV0cmljIChzZWUgW2BhbWJpZW50X3NwYWNl\nKDo6WlpMYXQpYF0oQHJlZikpCgpJZiBgYW1iaWVudF9yZXByZXNlbnRhdGlv\nbmAgaXMgc2V0IHRvIHRydWUsIHRoZW4gdGhlIGlzb21ldHJ5IGBmYCBpcyBz\nZWVuIGFzIGFuIGlzb21ldHJ5IG9mIHRoZSBhbWJpZW50IHNwYWNlIG9mIGBM\nYC4KSWYgYGNoZWNrID09IHRydWVgLCB0aGVuIHRoZSBmdW5jdGlvbiBjaGVj\na3Mgd2hldGhlciB0aGUgbWluaW1hbCBwb2x5bm9taWFsIG9mIHRoZSBhY3Rp\nb24gb2YgYGZgIG9uIHRoZSByYXRpb25hbApzcGFuIG9mIGBMYCBpcyBpcnJl\nZHVjaWJsZS4KIiIiCmZ1bmN0aW9uIGhlcm1pdGlhbl9zdHJ1Y3R1cmVfd2l0\naF90cmFuc2Zlcl9kYXRhKF9MOjpaWkxhdCwgZjo6UVFNYXRyaXg7IGNoZWNr\nOjpCb29sID0gdHJ1ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1i\naWVudF9yZXByZXNlbnRhdGlvbjo6Qm9vbCA9IHRydWUsCiAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgIHJlczo6VW5pb257Tm90aGluZywgQWJzdHJhY3RT\ncGFjZVJlc30gPSBub3RoaW5nLAogICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICBFOjpVbmlvbntOb3RoaW5nLCBSZWxTaW1wbGVOdW1GaWVsZH0gPSBub3Ro\naW5nKQoKICAjIFNpbmNlIHRoZSBtaW5pbWFsIHBvbHlub21pYWwgb2YgZiBt\naWdodCBub3QgYmUgaXJyZWR1Y2libGUsIGJ1dCB0aGUgb25lCiAgIyBvZiBp\ndHMgcmVzdHJpY3Rpb24gdG8gX0wgaXMsIHdlIGFyZSBvbmx5IGNvbmNlcm5l\nZCBhYm91dCBfTCBpbnNpZGUKICAjIGl0cyByYXRpb25hbCBzcGFuLiBTbyBp\nZiBfTCBpcyBub3Qgb2YgZnVsbCByYW5rLCB3ZSBjb25zaWRlciBpdHMKICAj\nICJmdWxsIHJhbmsgdmVyc2lvbiIuIE90aGVyd2lzZSwgd2Uga2VlcCBpdCBh\ncyBpcyBhbmQgY29uc2lkZXIgZiBhcwogICMgYWN0aW5nIG9uIHRoZSBhbWJp\nZW50IHNwYWNlICh3aGljaCBpcyBpc29tZXRyaWMgdG8gdGhlIHJhdGlvbmFs\nIHNwYW4gb2YgX0wpCiAgaWYgcmFuayhfTCkgIT0gZGVncmVlKF9MKQogICAg\nTCA9IGludGVnZXJfbGF0dGljZSg7Z3JhbSA9IGdyYW1fbWF0cml4KF9MKSkK\nICAgIGlmIGFtYmllbnRfcmVwcmVzZW50YXRpb24KICAgICAgb2ssIGYgPSBj\nYW5fc29sdmVfd2l0aF9zb2x1dGlvbihiYXNpc19tYXRyaXgoX0wpLCBiYXNp\nc19tYXRyaXgoX0wpKmY7IHNpZGU9OmxlZnQpCiAgICAgIEByZXEgb2sgIklz\nb21ldHJ5IGRvZXMgbm90IHJlc3RyaWN0IHRvIEwiCiAgICBlbmQKICBlbHNl\nCiAgICBMID0gX0wKICAgIGlmICFhbWJpZW50X3JlcHJlc2VudGF0aW9uCiAg\nICAgIEIgPSBiYXNpc19tYXRyaXgoX0wpCiAgICAgIGYgPSBpbnYoQikqZipC\nCiAgICBlbmQKICBlbmQKCiAgbiA9IG11bHRpcGxpY2F0aXZlX29yZGVyKGYp\nCgogIG1wZiA9IG1pbnBvbHkoZikKICBuMiA9IGRlZ3JlZShtcGYpCgogIEBy\nZXEgIWlzX2Zpbml0ZShuKSB8fCBuID4gMiAiSXNvbWV0cnkgbXVzdCBoYXZl\nIGluZmluaXRlIG9yZGVyIG9yIG9yZGVyIGJpZ2dlciB0aGFuIDIiCgogIGlm\nIGNoZWNrCiAgICBncmFtID0gZ3JhbV9tYXRyaXgoYW1iaWVudF9zcGFjZShM\nKSkKICAgIEByZXEgaXNfaXJyZWR1Y2libGUobXBmKSAiVGhlIG1pbmltYWwg\ncG9seW5vbWlhbCBvZiBmIG11c3QgYmUgaXJyZWR1Y2libGUiCiAgICBAcmVx\nIGYqZ3JhbSp0cmFuc3Bvc2UoZikgPT0gZ3JhbSAiZiBkb2VzIG5vdCBkZWZp\nbmUgYW4gaXNvbWV0cnkgb2YgdGhlIHNwYWNlIG9mIEwiCiAgICBAcmVxIGlz\nX2RpdmlzaWJsZV9ieShyYW5rKEwpLCBuMikgIlRoZSBkZWdyZWUgb2YgdGhl\nIG1pbmltYWwgcG9seW5vbWlhbCBvZiBmIG11c3QgZGl2aWRlIHRoZSByYW5r\nIG9mIEwiCiAgZW5kCgogICMgZm9yIHJlZ3VsYXIgdXNlcnMsIGByZXNgIGFu\nZCBgRWAgd2lsbCBhbHdheXMgYmUgYG5vdGhpbmdgCiAgaWYgcmVzICE9PSBu\nb3RoaW5nCiAgICBAYXNzZXJ0IGRvbWFpbihyZXMpID09PSBhbWJpZW50X3Nw\nYWNlKEwpCiAgICBiID0gZ2VuKGJhc2VfcmluZyhjb2RvbWFpbihyZXMpKSkK\nICBlbHNlaWYgRSA9PT0gbm90aGluZwogICAgaWYgaXNfZmluaXRlKG4pCiAg\nICAgIEUsIGIgPSBjeWNsb3RvbWljX2ZpZWxkX2FzX2NtX2V4dGVuc2lvbihu\nOyBjYWNoZWQ9ZmFsc2UpCiAgICBlbHNlCiAgICAgIEV0ZW1wLCBidGVtcCA9\nIG51bWJlcl9maWVsZChtcGYpCiAgICAgIEssIGEgPSBudW1iZXJfZmllbGQo\nbWlucG9seShidGVtcCArIGludihidGVtcCkpLCAiYSI7IGNhY2hlZD1mYWxz\nZSkKICAgICAgS3QsIHQgPSBLWyJ0Il0KICAgICAgRSwgYiA9IG51bWJlcl9m\naWVsZCh0XjItYSp0KzEsICJiIjsgY2FjaGVkPWZhbHNlKQogICAgZW5kCiAg\nZWxzZQogICAgQHJlcSBkZWdyZWUoRSkgPT0gMiAiRSBtdXN0IGJlIGEgZGVn\ncmVlIDIgZXh0ZW5zaW9uIG9mIGEgbnVtYmVyIGZpZWxkIgogICAgYiA9IGdl\nbihFKQogICAgY2hpID0gYWJzb2x1dGVfbWlucG9seShiKQogICAgUiA9IHBh\ncmVudChjaGkpCiAgICBAcmVxIG1pbnBvbHkoUiwgZikgPT0gY2hpICJUaGUg\nYWJzb2x1dGUgZGVmaW5pbmcgcG9seW5vbWlhbCBvZiBFIHNob3VsZCBiZSB0\naGUgc2FtZSBhcyB0aGUgbWluaW1hbCBwb2x5bm9taWFsIG9mIGYiCiAgZW5k\nCgogIG0gPSBkaXZleGFjdChyYW5rKEwpLCBuMikKICBfbWIgPSBhYnNvbHV0\nZV9yZXByZXNlbnRhdGlvbl9tYXRyaXgoYikKICBtYiA9IGJsb2NrX2RpYWdv\nbmFsX21hdHJpeChbX21iIGZvciBqIGluIDE6bV0pCgogICMgcmVndWxhciB1\nc2VycyBzaG91bGQgbm90IGhhdmUgdG8gY2FyZSBhYm91dCB0aGlzLgogICMg\nSWYgcmVzIGlzIHNwZWNpZmllZCBhbmQgZiBpcyBjb21wYXRpYmxlLCBpbiB0\naGUgc2Vuc2Ugb2YKICAjICJfYWRtaXNzaWJsZV9iYXNpcyIsIHRoZW4gd2Ug\ndHJhbnNmZXIgdGhlIGxhdHRpY2UgYWxvbmcgdGhpcyBtYXAKICBpZiByZXMg\nIT09IG5vdGhpbmcKICAgIFcgPSBjb2RvbWFpbihyZXMpCiAgICBsID0gcmVz\nLmJ0b3AKICAgIEBhc3NlcnQgbCpmID09IG1iKmwKICAgIEJMID0gYmFzaXNf\nbWF0cml4KEwpCiAgICBnZW5lID0gVmVjdG9ye2VsZW1fdHlwZShiYXNlX3Jp\nbmcoVykpfVtyZXMoQkxbaSwgOl0pIGZvciBpIGluIDE6ZGVncmVlKEwpXQog\nICAgTGggPSBsYXR0aWNlKFcsIGdlbmUpCiAgICByZXR1cm4gTGgsIHJlcwog\nIGVuZAoKICAjIGhlcmUgd2UgZ2V0IGFuICJhZG1pc3NpYmxlIGJhc2lzIiwg\naS5lLiBhIG5pY2UgYmFzaXMgb24gd2hpY2gKICAjIGYgYWN0cyBhcyBtdWx0\naXBsaWNhdGlvbiBieSBiIGFmdGVyIGV4dGVuZGluZyBzY2FsYXJzCiAgbCA9\nIF9hZG1pc3NpYmxlX2Jhc2lzKGYsIF9tYiwgbWIpCgogICMgd2UgY29uc3Ry\ndWN0IHRoZSBncmFtIG1hdHJpeCBvZiB0aGUgaGVybWl0aWFuIHNwYWNlIGlu\nIHdoaWNoIHRvIGV4dGVuZCB0aGUgc2NhbGFycy4KICAjIEZvciB0aGlzIHdl\nIGNoYW5nZSB0aGUgYmFzaXMgb2YgdGhlIGFtYmllbnQgc3BhY2UvcmF0aW9u\nYWwgc3BhbiBvZiBMIGFuZAogICMgd2UgdXNlIHRoZSB0cmFuc2ZlciBmb3Jt\ndWxhIHRvIHJldmVydCB0aGUgdHJhY2UgY29uc3RydWN0aW9uICh0aGlzIGlz\nCiAgIyB3aGVyZSB3ZSBhY3R1YWxseSBuZWVkIGEgYmFzaXMgb24gd2hpY2gg\ndGhlIGlzb21ldHJ5IGlzIGdpdmVuIGJ5IG11bHRpcGxpY2F0aW9uCiAgIyBi\neSBgYmAuCiAgZ3JhbSA9IHplcm9fbWF0cml4KEUsIG0sIG0pCiAgcyA9IGlu\ndm9sdXRpb24oRSkKICBHID0gbCpncmFtX21hdHJpeChhbWJpZW50X3NwYWNl\nKEwpKSp0cmFuc3Bvc2UobCkKICBicyA9IGFic29sdXRlX2Jhc2lzKEUpCiAg\ndHJhY2VfbWF0ID0gemVyb19tYXRyaXgoUVEsIG4yLCBuMikKICBmb3IgaSBp\nbiAxOm4yCiAgICBmb3IgaiBpbiAwOm4yLTEKICAgICAgdHJhY2VfbWF0W2ks\nIGorMV0gPSB0cmFjZShiXmoqYnNbaV0sIFFRKQogICAgZW5kCiAgZW5kCgog\nIGZvciBpPTE6bQogICAgZm9yIGo9MTptCiAgICAgIGEgPSByZWR1Y2UoaGNh\ndCwgdmlldyhtYl5rLCAxKyhpLTEpKm4yOjErKGktMSkqbjIsIDopKnZpZXco\nRywgOiwgMSsoai0xKSpuMjoxKyhqLTEpKm4yKSBmb3IgayBpbiAwOm4yLTEp\nCiAgICAgIGNvID0gc29sdmUodHJhY2VfbWF0LCBhOyBzaWRlID0gOmxlZnQp\nCiAgICAgIGdyYW1baSxqXSA9IG9ubHkoY28qYnMpCiAgICBlbmQKICBlbmQK\nCiAgQGFzc2VydCB0cmFuc3Bvc2UobWFwX2VudHJpZXMocywgZ3JhbSkpID09\nIGdyYW0KCiAgVyA9IGhlcm1pdGlhbl9zcGFjZShFLCBncmFtOyBjYWNoZWQ9\nZmFsc2UpCgogICMgd2UgY3JlYXRlIHRoZSBtYXAgZm9yIGV4dGVuZGluZy9y\nZXN0cmljdGluZyBzY2FsYXJzCiAgIyBjb25zaWRlcmluZyBvdXIgIm5pY2Ui\nIGJhc2lzIGtlZXBpbmcgdHJhY2sgb2YgdGhlIGFjdGlvbiBvZiB0aGUgaXNv\nbWV0cnkKICAjIG9uIHRoZSBhbWJpZW50IHNwYWNlLiBUaGlzIHdpbGwgYmUg\nbmVlZGVkIGZvciB0aGUgaGVybWl0aWFuIE1pcmFuZGEtTW9ycmlzb24KICAj\nIHRoZW9yeS4KICByZXMgPSBBYnN0cmFjdFNwYWNlUmVzKGFtYmllbnRfc3Bh\nY2UoTCksIFcsIGwsIGlkZW50aXR5X21hdHJpeChFLCBtKSkKCiAgIyBvbmNl\nIHdlIGhhdmUgdGhlIG1hcCBiZXR3ZWVuIHRoZSBhbWJpZW50IHNwYWNlcywg\naXQganVzdCByZW1haW4gdG8gdHJhbnNmZXIKICAjIHRoZSBsYXR0aWNlCiAg\nQkwgPSBiYXNpc19tYXRyaXgoTCkKICBnZW5lID0gVmVjdG9ye2VsZW1fdHlw\nZShFKX1bcmVzKEJMW2ksIDpdKSBmb3IgaSBpbiAxOmRlZ3JlZShMKV0KCiAg\nTGggPSBsYXR0aWNlKFcsIGdlbmUpCiAgcmV0dXJuIExoLCByZXMKZW5kCgoj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMgIEF1dG9t\nb3JwaGlzbSBncm91cAojCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjCgojIERldGVybWluZSB0aGUgZ3JhbSBtYXRyaWNlcyBvZiB0aGUg\nYmlsaW5lYXIgZm9ybXMKIyBWIHggViAtPiBRLCAoeCwgeSkgLT4gVHJfSy9R\nKGEqQih4LCB5KSkKIyB3aXRoIHJlc3BlY3QgdG8gYW4gYWJzb2x1dGUgYmFz\naXMgb2YgTCwgZm9yIGFsbCBhIGluIGdlbmVyYXRvcnMuCmZ1bmN0aW9uIFpm\nb3JtcyhMOjpBYnN0cmFjdExhdHs8OiBOdW1GaWVsZH0sIGdlbmVyYXRvcnMp\nCiAgcmV0dXJuIF9aZm9ybXMoTCwgZ2VuZXJhdG9ycykKZW5kCgpmdW5jdGlv\nbiBaZm9ybXMoTDo6QWJzdHJhY3RMYXR7PDogTnVtRmllbGR9KQogIEUgPSBi\nYXNlX3JpbmcoYW1iaWVudF9zcGFjZShMKSkKICBpZiBkZWdyZWUoRSkgPiAx\nCiAgICBnZW5lcmF0b3JzID0gZWxlbV90eXBlKEUpW0UoMSksIGFic29sdXRl\nX3ByaW1pdGl2ZV9lbGVtZW50KEUpXQogIGVsc2UKICAgIGdlbmVyYXRvcnMg\nPSBlbGVtX3R5cGUoRSlbRSgxKV0KICBlbmQKICByZXR1cm4gX1pmb3JtcyhM\nLCBnZW5lcmF0b3JzKQplbmQKCmZ1bmN0aW9uIF9aZm9ybXMoTDo6QWJzdHJh\nY3RMYXR7PDogTnVtRmllbGR9LCBnZW5lcmF0b3JzOjpWZWN0b3IpCiAgViA9\nIGFtYmllbnRfc3BhY2UoTCkKICBFID0gYmFzZV9yaW5nKFYpCiAgQmFicyA9\nIGFic29sdXRlX2Jhc2lzKEwpCiAgQmFic21hdCA9IG1hdHJpeChFLCBCYWJz\nKQogIGZvcm1zID0gWlpNYXRyaXhbXQogIHNjYWxhcnMgPSBRUUZpZWxkRWxl\nbVtdCiAgZm9yIGIgaW4gZ2VuZXJhdG9ycwogICAgVnJlcywgVnJlc1RvViA9\nIHJlc3RyaWN0X3NjYWxhcnMoViwgUVEsIGIpCiAgICBHID0gZ3JhbV9tYXRy\naXgoVnJlcywgbWFwKHQgLT4gcHJlaW1hZ2UoVnJlc1RvViwgdCksIEJhYnMp\nKQogICAgZCA9IGRlbm9taW5hdG9yKEcpCiAgICBHaW50ID0gY2hhbmdlX2Jh\nc2VfcmluZyhaWiwgZCAqIEcpCiAgICBjID0gY29udGVudChHaW50KQogICAg\nRyA9IGRpdmV4YWN0KEdpbnQsIGMpCiAgICBwdXNoIShmb3JtcywgRykKICAg\nIHB1c2ghKHNjYWxhcnMsIGQvL2MpCiAgZW5kCiAgcmV0dXJuIGZvcm1zLCBz\nY2FsYXJzLCBCYWJzbWF0LCBnZW5lcmF0b3JzCmVuZAoKIyBDb21wdXRlIHRo\nZSBhdXRvbW9ycGhpc20gZ3JvdXAgb2YgdGhlIGxhdHRpY2UKIyBwZXIgZGVm\nYXVsdCwgdGhlIGFyZSBnaXZlbiB3aXRoIHJlc3BlY3QgdG8gdGhlIGJhc2lz\nIG9mIHRoZSBhbWJpZW50IHNwYWNlCiMgaWYgYW1iaWVudF9yZXByZXNlbnRh\ndGlvbiA9IHRydWUsIHRoZXkgYXJlIGdpdmVuIHdpdGggcmVzcGVjdCB0byB0\naGUgY29vcmRpbmF0ZQojIHNwYWNlL2FtYmllbnQgc3BhY2UKZnVuY3Rpb24g\nYXNzZXJ0X2hhc19hdXRvbW9ycGhpc21zKEw6OkFic3RyYWN0TGF0ezw6IE51\nbUZpZWxkfTsgcmVkbzo6Qm9vbCA9IGZhbHNlLCBkZXB0aDo6SW50ID0gLTEs\nIGJhY2hlcl9kZXB0aDo6SW50ID0gMCkKCiAgaWYgIXJlZG8gJiYgaXNkZWZp\nbmVkKEwsIDphdXRvbW9ycGhpc21fZ3JvdXBfZ2VuZXJhdG9ycykKICAgIHJl\ndHVybiBub3RoaW5nCiAgZW5kCgogIEUgPSBiYXNlX3JpbmcoYW1iaWVudF9z\ncGFjZShMKSkKCiAgWmdyYW1MLCBzY2FsYXJzTCwgQmFic21hdEwsIGdlbmVy\nYXRvcnNMID0gWmZvcm1zKEwpCiAgQGFzc2VydCBpc29uZShnZW5lcmF0b3Jz\nTFsxXSkKCiAgIyBTbyB0aGUgZmlyc3Qgb25lIGlzIGVpdGhlciBwb3NpdGl2\nZSBkZWZpbml0ZSBvciBuZWdhdGl2ZSBkZWZpbml0ZQogICMgTWFrZSBpdCBw\nb3NpdGl2ZSBkZWZpbml0ZS4gVGhpcyBkb2VzIG5vdCBjaGFuZ2UgdGhlIGF1\ndG9tb3JwaGlzbXMuCiAgaWYgWmdyYW1MWzFdWzEsIDFdIDwgMAogICAgWmdy\nYW1MWzFdID0gLVpncmFtTFsxXQogIGVuZAoKICAjIE1ha2UgdGhlIEdyYW0g\nbWF0cml4IHNtYWxsCiAgR2xsbCwgVCA9IGxsbF9ncmFtX3dpdGhfdHJhbnNm\nb3JtKFpncmFtTFsxXSkKICBUdHIgPSB0cmFuc3Bvc2UoVCkKICBaZ3JhbUxv\ncmlnID0gY29weShaZ3JhbUwpCiAgZm9yIGkgaW4gMTpsZW5ndGgoWmdyYW1M\nKQogICAgWmdyYW1MW2ldID0gVCAqIFpncmFtTFtpXSAqIFR0cgogIGVuZAoK\nICAjIENyZWF0ZSB0aGUgYXV0b21vcnBoaXNtIGNvbnRleHQgYW5kIGNvbXB1\ndGUgZ2VuZXJhdG9ycyBhcyB3ZWxsIGFzIG9yZGVycwoKICBDID0gWkxhdEF1\ndG9DdHgoWmdyYW1MKQogIGZsLCBDc21hbGwgPSB0cnlfaW5pdF9zbWFsbChD\nLCBkZXB0aCA9IGRlcHRoLCBiYWNoZXJfZGVwdGggPSBiYWNoZXJfZGVwdGgp\nCiAgaWYgZmwKICAgIGF1dG8oQ3NtYWxsKQogICAgX2dlbnMsIG9yZGVyID0g\nX2dldF9nZW5lcmF0b3JzKENzbWFsbCkKICAgIGdlbnMgPSBaWk1hdHJpeFtt\nYXRyaXgoWlosIGcpIGZvciBnIGluIF9nZW5zXQogIGVsc2UKICAgIGluaXQo\nQywgZGVwdGggPSBkZXB0aCwgYmFjaGVyX2RlcHRoID0gYmFjaGVyX2RlcHRo\nKQogICAgYXV0byhDKQogICAgZ2Vucywgb3JkZXIgPSBfZ2V0X2dlbmVyYXRv\ncnMoQykKICBlbmQKCiAgQGhhc3NlcnQgOkxhdHRpY2UgMSBiZWdpbgogICAg\nZmxhZyA9IHRydWUKICAgIGZvciBnIGluIGdlbnMKICAgICAgZ3QgPSB0cmFu\nc3Bvc2UoZykKICAgICAgZm9yIGkgaW4gMTpsZW5ndGgoWmdyYW1MKQogICAg\nICAgIGlmIGcgKiBaZ3JhbUxbaV0gKiB0cmFuc3Bvc2UoZykgIT0gWmdyYW1M\nW2ldCiAgICAgICAgICBmbGFnID0gZmFsc2UKICAgICAgICBlbmQKICAgICAg\nZW5kCiAgICBlbmQKICAgIGZsYWcKICBlbmQKCiAgIyBOb3cgdW5kbyB0aGUg\nTExMIHRyYW5zZm9ybWF0aW9uCiAgVGludiA9IGludihUKQogIGZvciBpIGlu\nIDE6bGVuZ3RoKGdlbnMpCiAgICBnZW5zW2ldID0gVGludiAqIGdlbnNbaV0g\nKiBUCiAgZW5kCgogICMgTm93IGdlbnMgYXJlIHdpdGggcmVzcGVjdCB0byB0\naGUgYWJzb2x1dGUgYmFzaXMgb2YgTAogIEBoYXNzZXJ0IDpMYXR0aWNlIDEg\nYmVnaW4KICAgIGZsYWcgPSB0cnVlCiAgICBmb3IgaiBpbiAxOmxlbmd0aCha\nZ3JhbUwpCiAgICAgIGZvciBpIGluIDE6bGVuZ3RoKGdlbnMpCiAgICAgICAg\naWYgZ2Vuc1tpXSAqIFpncmFtTG9yaWdbal0gKiB0cmFuc3Bvc2UoZ2Vuc1tp\nXSkgIT0gWmdyYW1Mb3JpZ1tqXQogICAgICAgICAgZmxhZyA9IGZhbHNlCiAg\nICAgICAgZW5kCiAgICAgIGVuZAogICAgZW5kCiAgICBmbGFnCiAgZW5kCgog\nICMgTm93IHRyYW5zbGF0ZSB0byBnZXQgdGhlIGF1dG9tb3JwaGlzbXMgd2l0\naCByZXNwZWN0IHRvIGJhc2lzX21hdHJpeChMKQogIEJtYXRMID0gYmFzaXNf\nbWF0cml4X29mX3JhdGlvbmFsX3NwYW4oTCkKCiAgYjEsIHMxID0gY2FuX3Nv\nbHZlX3dpdGhfc29sdXRpb24oQmFic21hdEwsIEJtYXRMOyBzaWRlID0gOmxl\nZnQpCiAgYjIsIHMyID0gY2FuX3NvbHZlX3dpdGhfc29sdXRpb24oQm1hdEws\nIEJhYnNtYXRMOyBzaWRlID0gOmxlZnQpCgogIHRfZ2VucyA9IFZlY3Rvcnt0\neXBlb2YoQm1hdEwpfSh1bmRlZiwgbGVuZ3RoKGdlbnMpKQoKICBmb3IgaSBp\nbiAxOmxlbmd0aChnZW5zKQogICAgdF9nZW5zW2ldID0gczEgKiBjaGFuZ2Vf\nYmFzZV9yaW5nKEUsIGdlbnNbaV0pICogczIKICBlbmQKCiAgRyA9IGdyYW1f\nbWF0cml4X29mX3JhdGlvbmFsX3NwYW4oTCkKICBAaGFzc2VydCA6TGF0dGlj\nZSAxIGFsbChnICogRyAqIF9tYXAodHJhbnNwb3NlKGcpLCBpbnZvbHV0aW9u\nKEwpKSA9PSBHCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgZyBp\nbiB0X2dlbnMpCgogIHBtID0gcHNldWRvX21hdHJpeChMKQogIEMgPSBjb2Vm\nZmljaWVudF9pZGVhbHMocG0pCgogIGZvciBnIGluIHRfZ2VucwogICAgQGhh\nc3NlcnQgOkxhdHRpY2UgMSBhbGwoZ1tpLCBqXSBpbiBDW2pdICogaW52KENb\naV0pCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciBpIGluIDE6\nbnJvd3MoZyksIGogaW4gMTpucm93cyhnKSkKICBlbmQKCiAgIyBOb3cgc2V0\nIHRoZSBnZW5lcmF0b3JzIGFuZCB0aGUgb3JkZXIKCiAgTC5hdXRvbW9ycGhp\nc21fZ3JvdXBfZ2VuZXJhdG9ycyA9IHRfZ2VucwogIEwuYXV0b21vcnBoaXNt\nX2dyb3VwX29yZGVyID0gb3JkZXIKICByZXR1cm4gbm90aGluZwplbmQKCiMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMKIyAgQXV0b21v\ncnBoaXNtIGdyb3VwIGdlbmVyYXRvcnMKIwojIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIwoKQGRvYyByYXciIiIKICAgIGF1dG9tb3JwaGlz\nbV9ncm91cF9nZW5lcmF0b3JzKEw6OkFic3RyYWN0TGF0OyBhbWJpZW50X3Jl\ncHJlc2VudGF0aW9uOjpCb29sID0gdHJ1ZSwKICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXB0aDo6SW50ID0g\nLTEsIGJhY2hlcl9kZXB0aDo6SW50ID0gMCkKICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0+IFZl\nY3RvcntNYXRFbGVtfQoKR2l2ZW4gYSBkZWZpbml0ZSBsYXR0aWNlIGBMYCwg\ncmV0dXJuIGdlbmVyYXRvcnMgZm9yIHRoZSBhdXRvbW9ycGhpc20gZ3JvdXAg\nb2YgYExgLgpJZiBgYW1iaWVudF9yZXByZXNlbnRhdGlvbiA9PSB0cnVlYCAo\ndGhlIGRlZmF1bHQpLCB0aGUgdHJhbnNmb3JtYXRpb25zIGFyZSByZXByZXNl\nbnRlZAp3aXRoIHJlc3BlY3QgdG8gdGhlIGFtYmllbnQgc3BhY2Ugb2YgYExg\nLiBPdGhlcndpc2UsIHRoZSB0cmFuc2Zvcm1hdGlvbnMgYXJlIHJlcHJlc2Vu\ndGVkCndpdGggcmVzcGVjdCB0byB0aGUgKHBzZXVkby0pYmFzaXMgb2YgYExg\nLgoKU2V0dGluZyB0aGUgcGFyYW1ldGVycyBgZGVwdGhgIGFuZCBgYmFjaGVy\nX2RlcHRoYCB0byBhIHBvc2l0aXZlIHZhbHVlIG1heSBpbXByb3ZlCnBlcmZv\ncm1hbmNlLiBJZiBzZXQgdG8gYC0xYCAoZGVmYXVsdCksIHRoZSB1c2VkIHZh\nbHVlIG9mIGBkZXB0aGAgaXMgY2hvc2VuCmhldXJpc3RpY2FsbHkgZGVwZW5k\naW5nIG9uIHRoZSByYW5rIG9mIGBMYC4gQnkgZGVmYXVsdCwgYGJhY2hlcl9k\nZXB0aGAgaXMgc2V0IHRvIGAwYC4KIiIiCmF1dG9tb3JwaGlzbV9ncm91cF9n\nZW5lcmF0b3JzKEw6OkFic3RyYWN0TGF0OyBhbWJpZW50X3JlcHJlc2VudGF0\naW9uOjpCb29sID0gdHJ1ZSwgZGVwdGg6OkludCA9IC0xLCBiYWNoZXJfZGVw\ndGg6OkludCA9IDApCgpmdW5jdGlvbiBhdXRvbW9ycGhpc21fZ3JvdXBfZ2Vu\nZXJhdG9ycyhMOjpBYnN0cmFjdExhdDsgYW1iaWVudF9yZXByZXNlbnRhdGlv\nbjo6Qm9vbCA9IHRydWUsIGNoZWNrID0gZmFsc2UsIGRlcHRoOjpJbnQgPSAt\nMSwgYmFjaGVyX2RlcHRoOjpJbnQgPSAwKQoKICBhc3NlcnRfaGFzX2F1dG9t\nb3JwaGlzbXMoTDsgZGVwdGgsIGJhY2hlcl9kZXB0aCkKCiAgZ2VucyA9IEwu\nYXV0b21vcnBoaXNtX2dyb3VwX2dlbmVyYXRvcnMKCiAgaWYgIWFtYmllbnRf\ncmVwcmVzZW50YXRpb24KICAgIGlmIGNoZWNrCiAgICAgIEdyZWwgPSBncmFt\nX21hdHJpeChyYXRpb25hbF9zcGFuKEwpKQogICAgICBmb3IgZyBpbiBnZW5z\nCiAgICAgICAgQGFzc2VydCBnICogR3JlbCAqIF9tYXAodHJhbnNwb3NlKGcp\nLCBpbnZvbHV0aW9uKEwpKSA9PSBHcmVsCiAgICAgIGVuZAogICAgZW5kCiAg\nICByZXR1cm4gY29weShnZW5zKQogIGVsc2UKICAgIGJtID0gYmFzaXNfbWF0\ncml4X29mX3JhdGlvbmFsX3NwYW4oTCkKICAgIGJtMiA9IG9ydGhvZ29uYWxf\nY29tcGxlbWVudChhbWJpZW50X3NwYWNlKEwpLCBibSkKICAgIEIgPSB2Y2F0\nKGJtMiwgYm0pCiAgICBpZGUgPSBpZGVudGl0eV9tYXRyaXgoYmFzZV9maWVs\nZChMKSwgbnJvd3MoYm0yKSkKICAgIGdlbnMgPSBbYmxvY2tfZGlhZ29uYWxf\nbWF0cml4KFtpZGUsIGddKSBmb3IgZyBpbiBnZW5zXQogICAgZ2VucyA9IHR5\ncGVvZihibSlbaW52KEIpKmcqQiBmb3IgZyBpbiBnZW5zXQogICAgQGhhc3Nl\ncnQgOkxhdHRpY2UgMSBiZWdpbgogICAgICBmbGFnID0gdHJ1ZQogICAgICBH\nYW1iID0gZ3JhbV9tYXRyaXgoYW1iaWVudF9zcGFjZShMKSkKICAgICAgZm9y\nIGcgaW4gZ2VucwogICAgICAgIGlmIGcgKiBHYW1iICogX21hcCh0cmFuc3Bv\nc2UoZyksIGludm9sdXRpb24oTCkpICE9IEdhbWIKICAgICAgICAgIGZsYWcg\nPSBmYWxzZQogICAgICAgIGVuZAogICAgICBlbmQKICAgICAgZmxhZwogICAg\nZW5kCiAgICByZXR1cm4gZ2VucwogIGVuZAplbmQKCiMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMKIyAgQXV0b21vcnBoaXNtIGdyb3Vw\nIG9yZGVyCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMK\nCkBkb2MgcmF3IiIiCiAgICBhdXRvbW9ycGhpc21fZ3JvdXBfb3JkZXIoTDo6\nQWJzdHJhY3RMYXQ7IGRlcHRoOjpJbnQgPSAtMSwgYmFjaGVyX2RlcHRoOjpJ\nbnQgPSAwKSAtPiBJbnQKCkdpdmVuIGEgZGVmaW5pdGUgbGF0dGljZSBgTGAs\nIHJldHVybiB0aGUgb3JkZXIgb2YgdGhlIGF1dG9tb3JwaGlzbSBncm91cCBv\nZiBgTGAuCgpTZXR0aW5nIHRoZSBwYXJhbWV0ZXJzIGBkZXB0aGAgYW5kIGBi\nYWNoZXJfZGVwdGhgIHRvIGEgcG9zaXRpdmUgdmFsdWUgbWF5IGltcHJvdmUK\ncGVyZm9ybWFuY2UuIElmIHNldCB0byBgLTFgIChkZWZhdWx0KSwgdGhlIHVz\nZWQgdmFsdWUgb2YgYGRlcHRoYCBpcyBjaG9zZW4KaGV1cmlzdGljYWxseSBk\nZXBlbmRpbmcgb24gdGhlIHJhbmsgb2YgYExgLiBCeSBkZWZhdWx0LCBgYmFj\naGVyX2RlcHRoYCBpcyBzZXQgdG8gYDBgLgoiIiIKYXV0b21vcnBoaXNtX2dy\nb3VwX29yZGVyKEw6OkFic3RyYWN0TGF0OyByZWRvOjpCb29sID0gZmFsc2Us\nIGRlcHRoOjpJbnQgPSAtMSwgYmFjaGVyX2RlcHRoOjpJbnQgPSAwKQoKZnVu\nY3Rpb24gYXV0b21vcnBoaXNtX2dyb3VwX29yZGVyKEw6OkFic3RyYWN0TGF0\nOyByZWRvOjpCb29sID0gZmFsc2UsIGRlcHRoOjpJbnQgPSAtMSwgYmFjaGVy\nX2RlcHRoOjpJbnQgPSAwKQogICMgSW4gY2FzZSBvbmUgc2V0cyB1cCB0aGUg\nYXV0b21vcnBoaXNtIGdyb3VwIG9yZGVyLCBmcm9tIGV4dGVybmFsIGtub3ds\nZWRnZQogIGlmIGlzZGVmaW5lZChMLCA6YXV0b21vcnBoaXNtX2dyb3VwX29y\nZGVyKQogICAgcmV0dXJuIEwuYXV0b21vcnBoaXNtX2dyb3VwX29yZGVyCiAg\nZW5kCgogIGFzc2VydF9oYXNfYXV0b21vcnBoaXNtcyhMOyByZWRvLCBkZXB0\naCwgYmFjaGVyX2RlcHRoKQogIHJldHVybiBMLmF1dG9tb3JwaGlzbV9ncm91\ncF9vcmRlcgplbmQKCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjCiMKIyAgSXNvbWV0cnkKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIwoKQGRvYyByYXciIiIKICAgIGlzX2lzb21ldHJpYyhMOjpB\nYnN0cmFjdExhdCwgTTo6QWJzdHJhY3RMYXQ7IGRlcHRoOjpJbnQgPSAtMSwg\nYmFjaGVyX2RlcHRoOjpJbnQgPSAwKSAtPiBCb29sCgpSZXR1cm4gd2hldGhl\nciB0aGUgbGF0dGljZXMgYExgIGFuZCBgTWAgYXJlIGlzb21ldHJpYy4KClNl\ndHRpbmcgdGhlIHBhcmFtZXRlcnMgYGRlcHRoYCBhbmQgYGJhY2hlcl9kZXB0\naGAgdG8gYSBwb3NpdGl2ZSB2YWx1ZSBtYXkgaW1wcm92ZQpwZXJmb3JtYW5j\nZS4gSWYgc2V0IHRvIGAtMWAgKGRlZmF1bHQpLCB0aGUgdXNlZCB2YWx1ZSBv\nZiBgZGVwdGhgIGlzIGNob3NlbgpoZXVyaXN0aWNhbGx5IGRlcGVuZGluZyBv\nbiB0aGUgcmFuayBvZiBgTGAuIEJ5IGRlZmF1bHQsIGBiYWNoZXJfZGVwdGhg\nIGlzIHNldCB0byBgMGAuCiIiIgppc19pc29tZXRyaWMoTDo6QWJzdHJhY3RM\nYXQsIE06OkFic3RyYWN0TGF0OyBkZXB0aDo6SW50ID0gLTEsIGJhY2hlcl9k\nZXB0aDo6SW50ID0gMCkgPSBpc19pc29tZXRyaWNfd2l0aF9pc29tZXRyeShM\nLCBNOyBkZXB0aCA9IGRlcHRoLCBiYWNoZXJfZGVwdGggPSBiYWNoZXJfZGVw\ndGgpWzFdCgoKQGRvYyByYXciIiIKICAgIGlzX2lzb21ldHJpY193aXRoX2lz\nb21ldHJ5KEw6OkFic3RyYWN0TGF0LCBNOjpBYnN0cmFjdExhdDsgYW1iaWVu\ndF9yZXByZXNlbnRhdGlvbjo6Qm9vbCA9IHRydWUKICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgZGVwdGg6OkludCA9IC0xLCBiYWNoZXJfZGVwdGg6OkludCA9IDApCiAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgLT4gKEJvb2wsIE1hdEVsZW0pCgpSZXR1cm4gd2hl\ndGhlciB0aGUgbGF0dGljZXMgYExgIGFuZCBgTWAgYXJlIGlzb21ldHJpYy4g\nSWYgdGhpcyBpcyB0aGUgY2FzZSwgdGhlCnNlY29uZCByZXR1cm5lZCB2YWx1\nZSBpcyBhbiBpc29tZXRyeSBgVGAgZnJvbSBgTGAgdG8gYE1gLgoKVGhlIGlz\nb21ldHJ5IGlzIHJlcHJlc2VudGVkIHdpdGggcmVzcGVjdCB0byB0aGUgKHBz\nZXVkby0pYmFzZXMgb2YgYExgIGFuZCBgTWAsCnRoYXQgaXMsICRUIEdfTSBU\nXnQgPSBHX0wkIHdoZXJlICRHX00kIGFuZCAkR19MJCBhcmUgdGhlIEdyYW0g\nbWF0cmljZXMgb2YgdGhlCihwc2V1ZG8tKWJhc2VzIG9mIGBMYCBhbmQgYE1g\nCnJlc3BlY3RpdmVseS4KClNldHRpbmcgdGhlIHBhcmFtZXRlcnMgYGRlcHRo\nYCBhbmQgYGJhY2hlcl9kZXB0aGAgdG8gYSBwb3NpdGl2ZSB2YWx1ZSBtYXkg\naW1wcm92ZQpwZXJmb3JtYW5jZS4gSWYgc2V0IHRvIGAtMWAgKGRlZmF1bHQp\nLCB0aGUgdXNlZCB2YWx1ZSBvZiBgZGVwdGhgIGlzIGNob3NlbgpoZXVyaXN0\naWNhbGx5IGRlcGVuZGluZyBvbiB0aGUgcmFuayBvZiBgTGAuIEJ5IGRlZmF1\nbHQsIGBiYWNoZXJfZGVwdGhgIGlzIHNldCB0byBgMGAuCiIiIgppc19pc29t\nZXRyaWNfd2l0aF9pc29tZXRyeShMOjpBYnN0cmFjdExhdCwgTTo6QWJzdHJh\nY3RMYXQ7IGRlcHRoOjpJbnQgPSAtMSwgYmFjaGVyX2RlcHRoOjpJbnQgPSAw\nKSA9IHRocm93KE5vdEltcGxlbWVudGVkKCkpCgoKZnVuY3Rpb24gaXNfaXNv\nbWV0cmljX3dpdGhfaXNvbWV0cnkoTDo6QWJzdHJhY3RMYXR7PDogTnVtRmll\nbGR9LCBNOjpBYnN0cmFjdExhdHs8OiBOdW1GaWVsZH07CiAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoOjpJbnQgPSAtMSwgYmFj\naGVyX2RlcHRoOjpJbnQgPSAwKQogIFYgPSBhbWJpZW50X3NwYWNlKEwpCiAg\nVyA9IGFtYmllbnRfc3BhY2UoTSkKICBFID0gYmFzZV9yaW5nKFYpCiAgSyA9\nIGJhc2VfZmllbGQoRSkKICBAYXNzZXJ0IGJhc2VfcmluZyhWKSA9PSBiYXNl\nX3JpbmcoVykKICBAYXNzZXJ0IGJhc2VfcmluZyhMKSA9PSBiYXNlX3Jpbmco\nTSkKCiAgWmdyYW1MLCBzY2FsYXJzTCwgQmFic21hdEwsIGdlbmVyYXRvcnNM\nID0gWmZvcm1zKEwpCiAgWmdyYW1NLCBzY2FsYXJzTSwgQmFic21hdE0sIGdl\nbmVyYXRvcnNNID0gWmZvcm1zKE0sIGdlbmVyYXRvcnNMKQogIEBhc3NlcnQg\nZ2VuZXJhdG9yc0wgPT0gZ2VuZXJhdG9yc00KICBpZiBzY2FsYXJzTCAhPSBz\nY2FsYXJzTQogICAgcmV0dXJuIGZhbHNlLCB6ZXJvX21hdHJpeChFLCAwLCAw\nKQogIGVuZAoKICAjIFNvIHRoZSBmaXJzdCBvbmUgaXMgZWl0aGVyIHBvc2l0\naXZlIGRlZmluaXRlIG9yIG5lZ2F0aXZlIGRlZmluaXRlCiAgIyBNYWtlIGl0\nIHBvc2l0aXZlIGRlZmluaXRlLiBUaGlzIGRvZXMgbm90IGNoYW5nZSB0aGUg\nYXV0b21vcnBoaXNtcy4KICBpZiBaZ3JhbUxbMV1bMSwgMV0gPCAwCiAgICBa\nZ3JhbUxbMV0gPSAtWmdyYW1MWzFdCiAgICBaZ3JhbU1bMV0gPSAtWmdyYW1N\nWzFdCiAgZW5kCgogIFpncmFtTHNtYWxsID0gY29weShaZ3JhbUwpCiAgWmdy\nYW1Nc21hbGwgPSBjb3B5KFpncmFtTSkKCiAgIyBNYWtlIHRoZSBHcmFtIG1h\ndHJpeCBzbWFsbAogIF8sIFRMID0gbGxsX2dyYW1fd2l0aF90cmFuc2Zvcm0o\nWmdyYW1MWzFdKQogIF8sIFRNID0gbGxsX2dyYW1fd2l0aF90cmFuc2Zvcm0o\nWmdyYW1NWzFdKQogIFRMdHIgPSB0cmFuc3Bvc2UoVEwpCiAgVE10ciA9IHRy\nYW5zcG9zZShUTSkKICBmb3IgaSBpbiAxOmxlbmd0aChaZ3JhbUwpCiAgICBa\nZ3JhbUxzbWFsbFtpXSA9IFRMICogWmdyYW1MW2ldICogVEx0cgogICAgWmdy\nYW1Nc21hbGxbaV0gPSBUTSAqIFpncmFtTVtpXSAqIFRNdHIKICBlbmQKCiAg\nZmwsIENMc21hbGwsIENNc21hbGwgPSBfdHJ5X2lzb19zZXR1cF9zbWFsbCha\nZ3JhbUxzbWFsbCwgWmdyYW1Nc21hbGwsIGRlcHRoID0gZGVwdGgsIGJhY2hl\ncl9kZXB0aCA9IGJhY2hlcl9kZXB0aCkKICBpZiBmbAogICAgYiwgX1QgPSBp\nc29tZXRyeShDTHNtYWxsLCBDTXNtYWxsKQogICAgVCA9IG1hdHJpeChaWiwg\nX1QpCiAgZWxzZQogICAgQ0wsIENNID0gX2lzb19zZXR1cChaZ3JhbUxzbWFs\nbCwgWmdyYW1Nc21hbGwsIGRlcHRoID0gZGVwdGgsIGJhY2hlcl9kZXB0aCA9\nIGJhY2hlcl9kZXB0aCkKICAgIGIsIFQgPSBpc29tZXRyeShDTCwgQ00pCiAg\nZW5kCgogIGlmIGIKICAgIFQgPSBjaGFuZ2VfYmFzZV9yaW5nKFFRLCBpbnYo\nVEwpKlQqVE0pCiAgICBmbCwgczEgPSBjYW5fc29sdmVfd2l0aF9zb2x1dGlv\nbihCYWJzbWF0TCwgYmFzaXNfbWF0cml4X29mX3JhdGlvbmFsX3NwYW4oTCk7\nIHNpZGUgPSA6bGVmdCkKICAgIGZsLCBzMiA9IGNhbl9zb2x2ZV93aXRoX3Nv\nbHV0aW9uKGJhc2lzX21hdHJpeF9vZl9yYXRpb25hbF9zcGFuKE0pLCBCYWJz\nbWF0TTsgc2lkZSA9IDpsZWZ0KQogICAgVCA9IHMxICogY2hhbmdlX2Jhc2Vf\ncmluZyhFLCBUKSAqIHMyCiAgICBAaGFzc2VydCA6TGF0dGljZSAxIFQgKiBn\ncmFtX21hdHJpeChyYXRpb25hbF9zcGFuKE0pKSAqCiAgICAgICAgICAgICAg\nICAgICAgICAgICAgICBfbWFwKHRyYW5zcG9zZShUKSwgaW52b2x1dGlvbihM\nKSkgPT0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFtX21h\ndHJpeChyYXRpb25hbF9zcGFuKEwpKQogICAgcmV0dXJuIHRydWUsIFQKICBl\nbHNlCiAgICByZXR1cm4gZmFsc2UsIHplcm9fbWF0cml4KEUsIDAsIDApCiAg\nZW5kCmVuZAoKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMK\nIwojICBNYXhpbWFsIHN1YmxhdHRpY2VzCiMKIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMKCmZ1bmN0aW9uIG1heGltYWxfc3VibGF0dGlj\nZXMoTDo6QWJzdHJhY3RMYXQsIHA7IHVzZV9hdXRvOjpCb29sID0gZmFsc2Us\nCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBj\nYWxsYmFjayA9IGZhbHNlLCBtYXggPSBpbmYpCiAgQHJlcSBiYXNlX3Jpbmco\nTCkgPT0gb3JkZXIocCkgIkluY29tcGF0aWJsZSBhcmd1bWVudHM6IHAgbXVz\ndCBiZSBhbiBpZGVhbCBpbiB0aGUgYmFzZSByaW5nIG9mIEwiCgogIEIgPSBs\nb2NhbF9iYXNpc19tYXRyaXgoTCwgcDsgdHlwZSA9IDpzdWJtb2R1bGUpCiAg\nZnVsbF9yYW5rID0gcmFuayhtYXRyaXgoTC5wbWF0KSkgPT0gSGVja2UubWF4\nKG5yb3dzKEwucG1hdCksIG5jb2xzKEwucG1hdCkpCiAgbiA9IG5yb3dzKEIp\nCiAgUiA9IGJhc2VfcmluZyhMKQogIEsgPSBuZihSKQogIGssIGggPSByZXNp\nZHVlX2ZpZWxkKFIsIHApCiAgaGV4dCA9IGV4dGVuZChoLCBLKQogIHVzZV9h\ndXRvID0gKGlzX2RlZmluaXRlKEwpICYmIGZ1bGxfcmFuaykgPyB1c2VfYXV0\nbyA6IGZhbHNlCgogIGlmIHVzZV9hdXRvCiAgICBHID0gYXV0b21vcnBoaXNt\nX2dyb3VwX2dlbmVyYXRvcnMoTCkKICAgIEJpbnYgPSBpbnYoQikKICAgIGFk\nanVzdF9nZW5zID0gW3RyYW5zcG9zZShCKmcqQmludikgZm9yIGcgaW4gR10K\nICAgIGFkanVzdF9nZW5zX21vZF9wID0gW21hcF9lbnRyaWVzKGhleHQsIGcp\nIGZvciBnIGluIGFkanVzdF9nZW5zXQogICAgYWRqdXN0X2dlbnNfbW9kX3Ag\nPSBbZyBmb3IgZyBpbiBhZGp1c3RfZ2Vuc19tb2RfcCBpZiAhaXNfZGlhZ29u\nYWwoZyldCiAgICB1c2VfYXV0byA9IGxlbmd0aChhZGp1c3RfZ2Vuc19tb2Rf\ncCkgPj0gMQogIGVuZAoKICBpZiB1c2VfYXV0bwogICAgTHMgPSBsaW5lX29y\nYml0cyhhZGp1c3RfZ2Vuc19tb2RfcCkKICBlbHNlCiAgICBMcyA9IG1heGlt\nYWxfc3Vic3BhY2VzKGssIG4pCiAgZW5kCgogIHBNTCA9IHAgKiBwc2V1ZG9f\nbWF0cml4KEwpCiAgcmVzdWx0ID0gdHlwZW9mKEwpW10KICBrZWVwID0gdHJ1\nZQogIGNvbnQgPSB0cnVlCiAgRSA9IEludFtdCiAgZm9yIGkgaW4gMTpsZW5n\ndGgoTHMpCiAgICBpZiB1c2VfYXV0bwogICAgICBtID0gbWFwX2VudHJpZXMo\neSAtPiBoZXh0XHksIChrZXJuZWwobWF0cml4KExzW2ldWzFdKTsgc2lkZSA9\nIDpsZWZ0KSkpCiAgICBlbHNlCiAgICAgIG0gPSBtYXBfZW50cmllcyh5IC0+\nIGhleHRceSwgTHNbaV0pCiAgICBlbmQKICAgIExMID0gbGF0dGljZShhbWJp\nZW50X3NwYWNlKEwpLCBfc3VtX21vZHVsZXMoTCwgcHNldWRvX21hdHJpeCht\nICogQiksIHBNTCkpCiAgICBpZiAhKGNhbGxiYWNrIGlzYSBCb29sKQogICAg\nICBrZWVwLCBjb250ID0gY2FsbGJhY2socmVzdWx0LCBMTCk6OlR1cGxle0Jv\nb2wsIEJvb2x9CiAgICBlbmQKICAgIGlmIGtlZXAKICAgICAgcHVzaCEocmVz\ndWx0LCBMTCkKICAgICAgcHVzaCEoRSwgdXNlX2F1dG8gPyBMc1tpXVsyXSA6\nIDEpCiAgICBlbmQKICAgIGlmICFjb250CiAgICAgIGJyZWFrCiAgICBlbmQK\nICAgIGlmIGxlbmd0aChyZXN1bHQpID49IG1heAogICAgICBicmVhawogICAg\nZW5kCiAgZW5kCiAgcmV0dXJuIHJlc3VsdCwgRQplbmQKCiMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMKIyAgTWluaW1hbCBzdXBlcmxh\ndHRpY2VzCiMKIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMK\nCmZ1bmN0aW9uIG1pbmltYWxfc3VwZXJsYXR0aWNlcyhMOjpBYnN0cmFjdExh\ndCwgcDsgdXNlX2F1dG86OkJvb2wgPSBmYWxzZSwKICAgICAgICAgICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmYWxz\nZSwgbWF4ID0gaW5mKQogIEByZXEgYmFzZV9yaW5nKEwpID09IG9yZGVyKHAp\nICJJbmNvbXBhdGlibGUgYXJndW1lbnRzOiBwIG11c3QgYmUgYW4gaWRlYWwg\naW4gdGhlIGJhc2UgcmluZyBvZiBMIgoKICBCID0gbG9jYWxfYmFzaXNfbWF0\ncml4KEwsIHA7IHR5cGUgPSA6c3VibW9kdWxlKQogIGZ1bGxfcmFuayA9IHJh\nbmsobWF0cml4KEwucG1hdCkpID09IEhlY2tlLm1heChucm93cyhMLnBtYXQp\nLCBuY29scyhMLnBtYXQpKQogIG4gPSBucm93cyhCKQogIFIgPSBiYXNlX3Jp\nbmcoTCkKICBLID0gbmYoUikKICBrLCBoID0gcmVzaWR1ZV9maWVsZChSLCBw\nKQogIGhleHQgPSBleHRlbmQoaCwgSykKICB1c2VfYXV0byA9IChpc19kZWZp\nbml0ZShMKSAmJiBmdWxsX3JhbmspID8gdXNlX2F1dG8gOiBmYWxzZQoKICBp\nZiB1c2VfYXV0bwogICAgRyA9IGF1dG9tb3JwaGlzbV9ncm91cF9nZW5lcmF0\nb3JzKEwpCiAgICBCaW52ID0gaW52KEIpCiAgICBhZGp1c3RfZ2VucyA9IFtC\nKmcqQmludiBmb3IgZyBpbiBHXQogICAgYWRqdXN0X2dlbnNfbW9kX3AgPSBb\nbWFwX2VudHJpZXMoaGV4dCwgZykgZm9yIGcgaW4gYWRqdXN0X2dlbnNdCiAg\nICBhZGp1c3RfZ2Vuc19tb2RfcCA9IFtnIGZvciBnIGluIGFkanVzdF9nZW5z\nX21vZF9wIGlmICFpc19kaWFnb25hbChnKV0KICAgIHVzZV9hdXRvID0gbGVu\nZ3RoKGFkanVzdF9nZW5zX21vZF9wKSA+PSAxCiAgZW5kCgogIGlmIHVzZV9h\ndXRvCiAgICBMcyA9IGxpbmVfb3JiaXRzKGFkanVzdF9nZW5zX21vZF9wKQog\nIGVsc2UKICAgIExzID0gZW51bWVyYXRlX2xpbmVzKGssIG4pCiAgZW5kCgog\nIHBpbnYgPSBpbnYocCkKICBNTCA9IHBzZXVkb19tYXRyaXgoTCkKICByZXN1\nbHQgPSB0eXBlb2YoTClbXQogIGtlZXAgPSB0cnVlCiAgY29udCA9IHRydWUK\nICBFID0gSW50W10KICBmb3IgdiBpbiBMcwogICAgbCA9IHVzZV9hdXRvID8g\ndHJhbnNwb3NlKG1hdHJpeCh2WzFdKSkgOiB0cmFuc3Bvc2UobWF0cml4KHYp\nKQogICAgbSA9IG1hcF9lbnRyaWVzKHkgLT4gaGV4dFx5LCBsKQogICAgcHBt\nID0gcHNldWRvX21hdHJpeChtKkIsIFtwaW52XSkKICAgIExMID0gbGF0dGlj\nZShhbWJpZW50X3NwYWNlKEwpLCBfc3VtX21vZHVsZXMoTCwgTUwsIHBwbSkp\nCiAgICBpZiAhKGNhbGxiYWNrIGlzYSBCb29sKQogICAgICBrZWVwLCBjb250\nID0gY2FsbGJhY2socmVzdWx0LCBMTCkKICAgIGVuZAogICAgaWYga2VlcAog\nICAgICBwdXNoIShyZXN1bHQsIExMKQogICAgICBwdXNoIShFLCB1c2VfYXV0\nbyA/IHZbMl0gOiAxKQogICAgZW5kCiAgICBpZiAhY29udAogICAgICBicmVh\nawogICAgZW5kCiAgICBpZiBsZW5ndGgocmVzdWx0KSA+PSBtYXgKICAgICAg\nYnJlYWsKICAgIGVuZAogIGVuZAogIHJldHVybiByZXN1bHQsIEUKZW5kCgoj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMgIERpcmVj\ndCBzdW1zL2RpcmVjdCBwcm9kdWN0cy9iaXByb2R1Y3RzCiMKIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMKCkBkb2MgcmF3IiIiCiAgICBk\naXJlY3Rfc3VtKHg6OlZhcmFyZ3tUfSkgd2hlcmUgVCA8OiBBYnN0cmFjdExh\ndCAtPiBULCBWZWN0b3J7QWJzdHJhY3RTcGFjZU1vcn0KICAgIGRpcmVjdF9z\ndW0oeDo6VmVjdG9ye1R9KSB3aGVyZSBUIDw6IEFic3RyYWN0TGF0IC0+IFQs\nIFZlY3RvcntBYnN0cmFjdFNwYWNlTW9yfQoKR2l2ZW4gYSBjb2xsZWN0aW9u\nIG9mIHF1YWRyYXRpYyBvciBoZXJtaXRpYW4gbGF0dGljZXMgJExfMSwgXGxk\nb3RzLCBMX24kLApyZXR1cm4gdGhlaXIgZGlyZWN0IHN1bSAkTCA6PSBMXzEg\nXG9wbHVzIFxsZG90cyBcb3BsdXMgTF9uJCBhcyBtb2R1bGVzLCB0b2dldGhl\ncgp3aXRoIHRoZSBpbmplY3Rpb25zICRMX2kgXHRvIEwkIChzZWVuIGFzIG1h\ncHMgYmV0d2VlbiB0aGUgY29ycmVzcG9uZGluZwphbWJpZW50IHNwYWNlcyku\nCgpGb3IgbW9kdWxlcywgZmluaXRlIGRpcmVjdCBzdW1zIGFuZCBmaW5pdGUg\nZGlyZWN0IHByb2R1Y3RzIGFncmVlIGFuZCB0aGV5IGFyZQp0aGVyZWZvcmUg\nY2FsbGVkIGJpcHJvZHVjdHMuCklmIG9uZSB3YW50cyB0byBvYnRhaW4gYExg\nIGFzIGEgZGlyZWN0IHByb2R1Y3Qgd2l0aCB0aGUgcHJvamVjdGlvbnMgJEwg\nXHRvIExfaSQsCm9uZSBzaG91bGQgY2FsbCBgZGlyZWN0X3Byb2R1Y3QoeClg\nLgpJZiBvbmUgd2FudHMgdG8gb2J0YWluIGBMYCBhcyBhIGJpcHJvZHVjdCB3\naXRoIHRoZSBpbmplY3Rpb25zICRMX2kgXHRvIEwkIGFuZCB0aGUKcHJvamVj\ndGlvbnMgJEwgXHRvIExfaSQsIG9uZSBzaG91bGQgY2FsbCBgYmlwcm9kdWN0\nKHgpYC4KCiEhISB3YXJuaW5nCiAgICBUaGUgcHJvamVjdGlvbnMgJExcdG8g\nTF9pJCBhcmUgbW9ycGhpc21zIG9mIG1vZHVsZXMgYnV0IG5vdCBvZiBsYXR0\naWNlcywKICAgIHNpbmNlIHRoZSBhc3NvY2lhdGVkIHF1YWRyYXRpYy9oZXJt\naXRpYW4gZm9ybXMgYXJlIG5vdCBwcmVzZXJ2ZWQuCiIiIgpmdW5jdGlvbiBk\naXJlY3Rfc3VtKHg6OlZlY3RvcntUfTtjYWNoZWQ6OkJvb2w9dHJ1ZSkgd2hl\ncmUgVCA8OiBBYnN0cmFjdExhdAogIFcsIGluaiA9IGRpcmVjdF9zdW0oYW1i\naWVudF9zcGFjZS4oeCk7IGNhY2hlZCkKICBIID0gX2JpcHJvZHVjdCh4KQog\nIHJldHVybiBsYXR0aWNlKFcsIEgpLCBpbmoKZW5kCgpkaXJlY3Rfc3VtKHg6\nOlZhcmFyZ3tBYnN0cmFjdExhdH07Y2FjaGVkOjpCb29sPXRydWUpID0gZGly\nZWN0X3N1bShjb2xsZWN0KHgpO2NhY2hlZCkKCkBkb2MgcmF3IiIiCiAgICBk\naXJlY3RfcHJvZHVjdCh4OjpWYXJhcmd7VH0pIHdoZXJlIFQgPDogQWJzdHJh\nY3RMYXQgLT4gVCwgVmVjdG9ye0Fic3RyYWN0U3BhY2VNb3J9CiAgICBkaXJl\nY3RfcHJvZHVjdCh4OjpWZWN0b3J7VH0pIHdoZXJlIFQgPDogQWJzdHJhY3RM\nYXQgLT4gVCwgVmVjdG9ye0Fic3RyYWN0U3BhY2VNb3J9CgpHaXZlbiBhIGNv\nbGxlY3Rpb24gb2YgcXVhZHJhdGljIG9yIGhlcm1pdGlhbiBsYXR0aWNlcyAk\nTF8xLCBcbGRvdHMsIExfbiQsCnJldHVybiB0aGVpciBkaXJlY3QgcHJvZHVj\ndCAkTCA6PSBMXzEgXHRpbWVzIFxsZG90cyBcdGltZXMgTF9uJCBhcyBtb2R1\nbGVzLCB0b2dldGhlcgp3aXRoIHRoZSBwcm9qZWN0aW9ucyAkTCBcdG8gTF9p\nJCAoc2VlbiBhcyBtYXBzIGJldHdlZW4gdGhlIGNvcnJlc3BvbmRpbmcKYW1i\naWVudCBzcGFjZXMpLgoKRm9yIG1vZHVsZXMsIGZpbml0ZSBkaXJlY3Qgc3Vt\ncyBhbmQgZmluaXRlIGRpcmVjdCBwcm9kdWN0cyBhZ3JlZSBhbmQgdGhleSBh\ncmUKdGhlcmVmb3JlIGNhbGxlZCBiaXByb2R1Y3RzLgpJZiBvbmUgd2FudHMg\ndG8gb2J0YWluIGBMYCBhcyBhIGRpcmVjdCBzdW0gd2l0aCB0aGUgaW5qZWN0\naW9ucyAkTF9pIFx0byBMJCwKb25lIHNob3VsZCBjYWxsIGBkaXJlY3Rfc3Vt\nKHgpYC4KSWYgb25lIHdhbnRzIHRvIG9idGFpbiBgTGAgYXMgYSBiaXByb2R1\nY3Qgd2l0aCB0aGUgaW5qZWN0aW9ucyAkTF9pIFx0byBMJCBhbmQgdGhlCnBy\nb2plY3Rpb25zICRMIFx0byBMX2kkLCBvbmUgc2hvdWxkIGNhbGwgYGJpcHJv\nZHVjdCh4KWAuCgohISEgd2FybmluZwogICAgVGhlIHByb2plY3Rpb25zICRM\nXHRvIExfaSQgYXJlIG1vcnBoaXNtcyBvZiBtb2R1bGVzIGJ1dCBub3Qgb2Yg\nbGF0dGljZXMsCiAgICBzaW5jZSB0aGUgYXNzb2NpYXRlZCBxdWFkcmF0aWMv\naGVybWl0aWFuIGZvcm1zIGFyZSBub3QgcHJlc2VydmVkLgoiIiIKZnVuY3Rp\nb24gZGlyZWN0X3Byb2R1Y3QoeDo6VmVjdG9ye1R9O2NhY2hlZDo6Qm9vbD10\ncnVlKSB3aGVyZSBUIDw6IEFic3RyYWN0TGF0CiAgVywgcHJvaiA9IGRpcmVj\ndF9wcm9kdWN0KGFtYmllbnRfc3BhY2UuKHgpOyBjYWNoZWQpCiAgSCA9IF9i\naXByb2R1Y3QoeCkKICByZXR1cm4gbGF0dGljZShXLCBIKSwgcHJvagplbmQK\nCmRpcmVjdF9wcm9kdWN0KHg6OlZhcmFyZ3tBYnN0cmFjdExhdH0pID0gZGly\nZWN0X3Byb2R1Y3QoY29sbGVjdCh4KSkKCkBkb2MgcmF3IiIiCiAgICBiaXBy\nb2R1Y3QoeDo6VmFyYXJne1R9KSB3aGVyZSBUIDw6IEFic3RyYWN0TGF0IC0+\nIFQsIFZlY3RvcntBYnN0cmFjdFNwYWNlTW9yfSwgVmVjdG9ye0Fic3RyYWN0\nU3BhY2VNb3J9CiAgICBiaXByb2R1Y3QoeDo6VmVjdG9ye1R9KSB3aGVyZSBU\nIDw6IEFic3RyYWN0TGF0IC0+IFQsIFZlY3RvcntBYnN0cmFjdFNwYWNlTW9y\nfSwgVmVjdG9ye0Fic3RyYWN0U3BhY2VNb3J9CgpHaXZlbiBhIGNvbGxlY3Rp\nb24gb2YgcXVhZHJhdGljIG9yIGhlcm1pdGlhbiBsYXR0aWNlcyAkTF8xLCBc\nbGRvdHMsIExfbiQsCnJldHVybiB0aGVpciBiaXByb2R1Y3QgJEwgOj0gTF8x\nIFxvcGx1cyBcbGRvdHMgXG9wbHVzIExfbiQgYXMgbW9kdWxlcywgdG9nZXRo\nZXIKd2l0aCB0aGUgaW5qZWN0aW9ucyAkTF9pIFx0byBMJCBhbmQgdGhlIHBy\nb2plY3Rpb25zICRMIFx0byBMX2kkIChzZWVuIGFzIG1hcHMKYmV0d2VlbiB0\naGUgY29ycmVzcG9uZGluZyBhbWJpZW50IHNwYWNlcykuCgpGb3IgbW9kdWxl\ncywgZmluaXRlIGRpcmVjdCBzdW1zIGFuZCBmaW5pdGUgZGlyZWN0IHByb2R1\nY3RzIGFncmVlIGFuZCB0aGV5IGFyZQp0aGVyZWZvcmUgY2FsbGVkIGJpcHJv\nZHVjdHMuCklmIG9uZSB3YW50cyB0byBvYnRhaW4gYExgIGFzIGEgZGlyZWN0\nIHN1bSB3aXRoIHRoZSBpbmplY3Rpb25zICRMX2kgXHRvIEwkLApvbmUgc2hv\ndWxkIGNhbGwgYGRpcmVjdF9zdW0oeClgLgpJZiBvbmUgd2FudHMgdG8gb2J0\nYWluIGBMYCBhcyBhIGRpcmVjdCBwcm9kdWN0IHdpdGggdGhlIHByb2plY3Rp\nb25zICRMIFx0byBMX2kkLApvbmUgc2hvdWxkIGNhbGwgYGRpcmVjdF9wcm9k\ndWN0KHgpYC4KCiEhISB3YXJuaW5nCiAgICBUaGUgcHJvamVjdGlvbnMgJExc\ndG8gTF9pJCBhcmUgbW9ycGhpc21zIG9mIG1vZHVsZXMgYnV0IG5vdCBvZiBs\nYXR0aWNlcywKICAgIHNpbmNlIHRoZSBhc3NvY2lhdGVkIHF1YWRyYXRpYy9o\nZXJtaXRpYW4gZm9ybXMgYXJlIG5vdCBwcmVzZXJ2ZWQuCiIiIgpmdW5jdGlv\nbiBiaXByb2R1Y3QoeDo6VmVjdG9ye1R9OyBjYWNoZWQ6OkJvb2w9dHJ1ZSkg\nd2hlcmUgVCA8OiBBYnN0cmFjdExhdAogIFcsIGluaiwgcHJvaiA9IGJpcHJv\nZHVjdChhbWJpZW50X3NwYWNlLih4KTsgY2FjaGVkKQogIEggPSBfYmlwcm9k\ndWN0KHgpCiAgcmV0dXJuIGxhdHRpY2UoVywgSCksIGluaiwgcHJvagplbmQK\nCmJpcHJvZHVjdCh4OjpWYXJhcmd7QWJzdHJhY3RMYXR9OyBjYWNoZWQ6OkJv\nb2w9dHJ1ZSkgPSBiaXByb2R1Y3QoY29sbGVjdCh4KTtjYWNoZWQpCgpmdW5j\ndGlvbiBfYmlwcm9kdWN0KHg6OlZlY3RvcntUfSkgd2hlcmUgVCA8OiBBYnN0\ncmFjdExhdAogIHB4ID0gcHNldWRvX21hdHJpeC4oeCkKICBNcHggPSBtYXRy\naXguKHB4KQogIEggPSBwc2V1ZG9fbWF0cml4KGRpYWdvbmFsX21hdHJpeChN\ncHgpLAogICAgICAgICAgICAgICAgICAgIHJlZHVjZSh2Y2F0LCBjb2VmZmlj\naWVudF9pZGVhbHMuKHB4KSkpCiAgcmV0dXJuIEgKZW5kCgojIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwojCiMgIE9ydGhvZ29uYWwgY29t\ncGxlbWVudAojCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nCgpAZG9jIHJhdyIiIgogICAgb3J0aG9nb25hbF9zdWJtb2R1bGUoTDo6QWJz\ndHJhY3RMYXQsIE06OkFic3RyYWN0TGF0KSAtPiBBYnN0cmFjdExhdAoKUmV0\ndXJuIHRoZSBsYXJnZXN0IHN1Ym1vZHVsZSBvZiBgTGAgb3J0aG9nb25hbCB0\nbyBgTWAuCiIiIgpmdW5jdGlvbiBvcnRob2dvbmFsX3N1Ym1vZHVsZShMOjpB\nYnN0cmFjdExhdCwgTTo6QWJzdHJhY3RMYXQpCiAgQHJlcSBhbWJpZW50X3Nw\nYWNlKE0pID09IGFtYmllbnRfc3BhY2UoTCkgIkxhdHRpY2VzIG11c3QgYmUg\naW4gdGhlIHNhbWUgYW1iaWVudCBzcGFjZSIKICBWID0gYW1iaWVudF9zcGFj\nZShMKQogIEVNID0gYmFzaXNfbWF0cml4X29mX3JhdGlvbmFsX3NwYW4oTSkK\nICBNb3J0aCA9IG9ydGhvZ29uYWxfY29tcGxlbWVudChWLCBFTSkKICBOID0g\nbGF0dGljZShWLCBNb3J0aCkKICBOID0gaW50ZXJzZWN0KEwsIE4pCiAgcmV0\ndXJuIHByaW1pdGl2ZV9jbG9zdXJlKEwsIE4pCmVuZAoKIyBkb2VzIG5vdCBz\nZWVtIHRvIHdvcmsgZWl0aGVyCmZ1bmN0aW9uIF9vcnRob2dvbmFsX2NvbXBs\nZW1lbnQodjo6VmVjdG9yLCBMOjpBYnN0cmFjdExhdCkKICBWID0gYW1iaWVu\ndF9zcGFjZShMKQogIE0gPSBtYXRyaXgoYmFzZV9yaW5nKFYpLCAxLCBsZW5n\ndGgodiksIHYpCiAgZ2UgPSBnZW5lcmF0b3JzKEwpCiAgZ2Vfb3IgPSBjb3B5\nKGdlKQogICAgZm9yIGkgaW4gMTpsZW5ndGgoZ2UpCiAgICAjIDx2LCB2PiA9\nIDEKICAgIGdlX29yW2ldID0gZ2VbaV0gLSBpbm5lcl9wcm9kdWN0KFYsIGdl\nW2ldLCB2KSAuKiB2CiAgICBAYXNzZXJ0IGlubmVyX3Byb2R1Y3QoViwgZ2Vf\nb3JbaV0sIHYpID09IDAKICBlbmQKICBwbSA9IHBzZXVkb19obmZfa2IocHNl\ndWRvX21hdHJpeCh0cmFuc3Bvc2UobWF0cml4KGdlX29yKSkpLCA6bG93ZXJs\nZWZ0KQogIGkgPSAxCiAgd2hpbGUgaXNfemVyb19yb3cocG0ubWF0cml4LCBp\nKQogICAgaSArPSAxCiAgZW5kCgogIHBtID0gc3ViKHBtLCBpOm5yb3dzKHBt\nKSwgMTpuY29scyhwbSkpCgogIHJldHVybiBsYXR0aWNlKFYsIHBtKQplbmQK\nCiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMKIyAgTWF4\naW1hbCBpbnRlZ3JhbCBsYXR0aWNlcwojCiMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjCgpAZG9jIHJhdyIiIgogICAgaXNfbWF4aW1hbF9p\nbnRlZ3JhbChMOjpBYnN0cmFjdExhdCwgcDo6QWJzTnVtRmllbGRPcmRlcklk\nZWFse0Fic1NpbXBsZU51bUZpZWxkLCBBYnNTaW1wbGVOdW1GaWVsZEVsZW19\nKSAtPiBCb29sLCBBYnN0cmFjdExhdAoKR2l2ZW4gYSBsYXR0aWNlIGBMYCBh\nbmQgYSBwcmltZSBpZGVhbCBgcGAgb2YgdGhlIGZpeGVkIHJpbmcgJFxtYXRo\nY2FsIE9fSyQgb2YKYExgLCByZXR1cm4gd2hldGhlciB0aGUgY29tcGxldGlv\nbiBvZiBgTGAgYXQgYHBgIGhhcyBpbnRlZ3JhbCBub3JtIGFuZCB0aGF0IGBM\nYCBoYXMgbm8KcHJvcGVyIG92ZXJsYXR0aWNlIHNhdGlzZnlpbmcgdGhpcyBw\ncm9wZXJ0eS4KCklmIHRoZSBub3JtIG9mIGBMYCBpcyBub3QgaW50ZWdyYWwg\nYXQgYHBgLCB0aGUgc2Vjb25kIG91dHB1dCBpcyBgTGAgYnkgZGVmYXVsdC4K\nT3RoZXJ3aXNlLCBlaXRoZXIgYExgIGlzIG1heGltYWwgYXQgYHBgIGFuZCB0\naGUgc2Vjb25kIG91dHB1dCBpcyBgTGAsIG9yIHRoZQpzZWNvbmQgb3V0cHV0\nIGlzIGEgbGF0dGljZSBgTWAgaW4gdGhlIGFtYmllbnQgc3BhY2Ugb2YgYExg\nIHdob3NlIGNvbXBsZXRpb24KYXQgYHBgIGlzIGEgbWluaW1hbCBvdmVybGF0\ndGljZSBvZiAkTF9wJCB3aXRoIGludGVncmFsIG5vcm0uCiIiIgppc19tYXhp\nbWFsX2ludGVncmFsKDo6QWJzdHJhY3RMYXQsIHApCgpAZG9jIHJhdyIiIgog\nICAgaXNfbWF4aW1hbF9pbnRlZ3JhbChMOjpBYnN0cmFjdExhdCkgLT4gQm9v\nbCwgQWJzdHJhY3RMYXQKCkdpdmVuIGEgbGF0dGljZSBgTGAsIHJldHVybiB3\naGV0aGVyIGBMYCBoYXMgaW50ZWdyYWwgbm9ybSBhbmQgaGFzIG5vIHByb3Bl\ncgpvdmVybGF0dGljZSBzYXRpc2Z5aW5nIHRoaXMgcHJvcGVydHkuCgpJZiB0\naGUgbm9ybSBvZiBgTGAgaXMgbm90IGludGVncmFsLCB0aGUgc2Vjb25kIG91\ndHB1dCBpcyBgTGAgYnkgZGVmYXVsdC4KT3RoZXJ3aXNlLCBlaXRoZXIgYExg\nIGlzIG1heGltYWwgYW5kIHRoZSBzZWNvbmQgb3V0cHV0IGlzIGBMYCwgb3Ig\ndGhlIHNlY29uZApvdXRwdXQgaXMgYSBtaW5pbWFsIG92ZXJsYXR0aWNlIGBN\nYCBvZiBgTGAgd2l0aCBpbnRlZ3JhbCBub3JtLgoiIiIKaXNfbWF4aW1hbF9p\nbnRlZ3JhbCg6OkFic3RyYWN0TGF0KQoKQGRvYyByYXciIiIKICAgIGlzX21h\neGltYWwoTDo6QWJzdHJhY3RMYXQsIHA6OkFic051bUZpZWxkT3JkZXJJZGVh\nbHtBYnNTaW1wbGVOdW1GaWVsZCwgQWJzU2ltcGxlTnVtRmllbGRFbGVtfSkg\nLT4gQm9vbCwgQWJzdHJhY3RMYXQKCkdpdmVuIGEgbGF0dGljZSBgTGAgYW5k\nIGEgcHJpbWUgaWRlYWwgYHBgIGluIHRoZSBmaXhlZCByaW5nICRcbWF0aGNh\nbCBPX0skIG9mCmBMYCBzdWNoIHRoYXQgdGhlIG5vcm0gb2YgJExfcCQgaXMg\naW50ZWdyYWwsIHJldHVybiB3aGV0aGVyIGBMYCBpcyBtYXhpbWFsCmludGVn\ncmFsIGF0IGBwYC4KCklmIGBMYCBpcyBsb2NhbGx5IG1heGltYWwgYXQgYHBg\nLCB0aGUgc2Vjb25kIG91dHB1dCBpcyBgTGAsIG90aGVyd2lzZSBpdCBpcwph\nIGxhdHRpY2UgYE1gIGluIHRoZSBzYW1lIGFtYmllbnQgc3BhY2Ugb2YgYExg\nIHdob3NlIGNvbXBsZXRpb24gYXQgYHBgIGhhcwppbnRlZ3JhbCBub3JtIGFu\nZCBpcyBhIHByb3BlciBvdmVybGF0dGljZSBvZiAkTF9wJC4KIiIiCmlzX21h\neGltYWwoOjpBYnN0cmFjdExhdCwgcCkKCkBkb2MgcmF3IiIiCiAgICBtYXhp\nbWFsX2ludGVncmFsX2xhdHRpY2UoTDo6QWJzdHJhY3RMYXQsIHA6OkFic051\nbUZpZWxkT3JkZXJJZGVhbHtBYnNTaW1wbGVOdW1GaWVsZCwgQWJzU2ltcGxl\nTnVtRmllbGRFbGVtfSkgLT4gQWJzdHJhY3RMYXQKCkdpdmVuIGEgbGF0dGlj\nZSBgTGAgYW5kIGEgcHJpbWUgaWRlYWwgYHBgIG9mIHRoZSBmaXhlZCByaW5n\nICRcbWF0aGNhbCBPX0skIG9mCmBMYCBzdWNoIHRoYXQgdGhlIG5vcm0gb2Yg\nJExfcCQgaXMgaW50ZWdyYWwsIHJldHVybiBhIGxhdHRpY2UgYE1gIGluIHRo\nZQphbWJpZW50IHNwYWNlIG9mIGBMYCB3aGljaCBpcyBtYXhpbWFsIGludGVn\ncmFsIGF0IGBwYCBhbmQgd2hpY2ggYWdyZWVzCndpdGggYExgIGxvY2FsbHkg\nYXQgYWxsIHRoZSBwbGFjZXMgZGlmZmVyZW50IGZyb20gYHBgLgoiIiIKbWF4\naW1hbF9pbnRlZ3JhbF9sYXR0aWNlKDo6QWJzdHJhY3RMYXQsIHApCgpAZG9j\nIHJhdyIiIgogICAgbWF4aW1hbF9pbnRlZ3JhbF9sYXR0aWNlKEw6OkFic3Ry\nYWN0TGF0KSAtPiBBYnN0cmFjdExhdAoKR2l2ZW4gYSBsYXR0aWNlIGBMYCB3\naXRoIGludGVncmFsIG5vcm0sIHJldHVybiBhIG1heGltYWwgaW50ZWdyYWwg\nb3ZlcmxhdHRpY2UKYE1gIG9mIGBMYC4KIiIiCm1heGltYWxfaW50ZWdyYWxf\nbGF0dGljZSg6OkFic3RyYWN0TGF0KQoKQGRvYyByYXciIiIKICAgIG1heGlt\nYWxfaW50ZWdyYWxfbGF0dGljZShWOjpBYnN0cmFjdFNwYWNlKSAtPiBBYnN0\ncmFjdExhdAoKR2l2ZW4gYSBzcGFjZSBgVmAsIHJldHVybiBhIGxhdHRpY2Ug\naW4gYFZgIHdpdGggaW50ZWdyYWwgbm9ybQphbmQgd2hpY2ggaXMgbWF4aW1h\nbCBpbiBgVmAgc2F0aXNmeWluZyB0aGlzIHByb3BlcnR5LgoiIiIKbWF4aW1h\nbF9pbnRlZ3JhbF9sYXR0aWNlKDo6QWJzdHJhY3RTcGFjZSkKCiMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjCiMKIyAgUHJpbWl0aXZlIGNs\nb3N1cmUKIwojIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMj\nIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIwoK\nQGRvYyByYXciIiIKICAgIHByaW1pdGl2ZV9jbG9zdXJlKE06OkFic3RyYWN0\nTGF0LCBOOjpBYnN0cmFjdExhdCkgLT4gQWJzdHJhY3RMYXQKCkdpdmVuIHR3\nbyBsYXR0aWNlcyBgTWAgYW5kIGBOYCBkZWZpbmVkIG92ZXIgYSBudW1iZXIg\nZmllbGQgYEVgLCB3aXRoCiROIFxzdWJzZXRlcSBFXG90aW1lcyBNJCwgcmV0\ndXJuIHRoZSBwcmltaXRpdmUgY2xvc3VyZSAkTSBcY2FwIEVcb3RpbWVzIE4k\nCm9mIGBOYCBpbiBgTWAuCgpPbmUgY2FuIGFsc28gdXNlIHRoZSBhbGlhcyBg\nc2F0dXJhdGUoTCwgTSlgLgoiIiIKZnVuY3Rpb24gcHJpbWl0aXZlX2Nsb3N1\ncmUoTTo6QWJzdHJhY3RMYXQsIE46OkFic3RyYWN0TGF0KQogIEBhc3NlcnQg\naGFzX2FtYmllbnRfc3BhY2UoTikgJiYgaGFzX2FtYmllbnRfc3BhY2UoTSkK\nICBAcmVxIGFtYmllbnRfc3BhY2UoTikgPT09IGFtYmllbnRfc3BhY2UoTSkg\nIkxhdHRpY2VzIG11c3QgYmUgaW4gdGhlIHNhbWUgYW1iaWVudCBzcGFjZSIK\nICBNcmVzLCBmID0gcmVzdHJpY3Rfc2NhbGFyc193aXRoX21hcChNLCBRUSkK\nICBOcmVzID0gcmVzdHJpY3Rfc2NhbGFycyhOLCBmKQogIExyZXMgPSBwcmlt\naXRpdmVfY2xvc3VyZShNcmVzLCBOcmVzKQogIEIgPSBiYXNpc19tYXRyaXgo\nTHJlcykKICBCMiA9IFtmKEJbaSw6XSkgZm9yIGkgaW4gMTpucm93cyhCKV0K\nICByZXR1cm4gbGF0dGljZShhbWJpZW50X3NwYWNlKE0pLCBCMikKZW5kCgpA\nZG9jIHJhdyIiIgogICAgc2F0dXJhdGUoTDo6QWJzdHJhY3RMYXQsIE06OkFi\nc3RyYWN0TGF0KSAtPiBBYnN0cmFjdExhdAoKQWxpYXMgZm9yIGBwcmltaXRp\ndmVfY2xvc3VyZWAuCiIiIgpzYXR1cmF0ZShMOjpBYnN0cmFjdExhdCwgTTo6\nQWJzdHJhY3RMYXQpID0gcHJpbWl0aXZlX2Nsb3N1cmUoTDo6QWJzdHJhY3RM\nYXQsIE06OkFic3RyYWN0TGF0KQo=\n",
  "encoding": "base64",
  "_links": {
    "self": "https://api.github.com/repos/thofma/Hecke.jl/contents/src/QuadForm/Lattices.jl?ref=master",
    "git": "https://api.github.com/repos/thofma/Hecke.jl/git/blobs/2e0dca50541f710c88043fff2c95580fd3049d61",
    "html": "https://github.com/thofma/Hecke.jl/blob/master/src/QuadForm/Lattices.jl"
  }
}
thinking
I found the API response shows the file URL. Let me try to download the raw file properly:
exec
/bin/bash -lc 'curl -sL "https://github.com/thofma/Hecke.jl/raw/master/src/QuadForm/Lattices.jl" 2>&1 | grep -A30 "''^    function is_isometric" | head -40' in /home/dzack/lattice_interface succeeded in 635ms:

thinking
Let me try a different approach - search with context:
exec
/bin/bash -lc 'curl -sL "https://github.com/thofma/Hecke.jl/raw/refs/heads/master/src/QuadForm/Lattices.jl" 2>&1 | grep -A30 "is_isometric" | head -50' in /home/dzack/lattice_interface succeeded in 827ms:
  return is_isometric(rational_span(L), rational_span(M), p)
end

function is_rationally_isometric(L::AbstractLat, M::AbstractLat, p::InfPlc)
  return is_isometric(rational_span(L), rational_span(M), p)
end

@doc raw"""
    is_rationally_isometric(L::AbstractLat, M::AbstractLat) -> Bool

Return whether the rational spans of the lattices `L` and `M` are isometric.
"""
function is_rationally_isometric(L::AbstractLat, M::AbstractLat)
  return is_isometric(rational_span(L), rational_span(M))
end

################################################################################
#
#  Definiteness
#
thinking
This is very useful! I can see the `is_isometric` function definition. Let me get more of the docstring to see what it says about definiteness:
exec
/bin/bash -lc 'curl -sL "https://github.com/thofma/Hecke.jl/raw/refs/heads/master/src/QuadForm/Lattices.jl" 2>&1 | grep -A60 "''^    is_isometric(L::AbstractLat" | head -70' in /home/dzack/lattice_interface succeeded in 557ms:
    is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -> Bool

Return whether the lattices `L` and `M` are isometric.

Setting the parameters `depth` and `bacher_depth` to a positive value may improve
performance. If set to `-1` (default), the used value of `depth` is chosen
heuristically depending on the rank of `L`. By default, `bacher_depth` is set to `0`.
"""
is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) = is_isometric_with_isometry(L, M; depth = depth, bacher_depth = bacher_depth)[1]


@doc raw"""
    is_isometric_with_isometry(L::AbstractLat, M::AbstractLat; ambient_representation::Bool = true
                                                               depth::Int = -1, bacher_depth::Int = 0)
                                                              -> (Bool, MatElem)

Return whether the lattices `L` and `M` are isometric. If this is the case, the
second returned value is an isometry `T` from `L` to `M`.

The isometry is represented with respect to the (pseudo-)bases of `L` and `M`,
thinking
This is key evidence! The source code shows:

```julia
# So the first one is either positive definite or negative definite
# Make it positive definite. This does not change the automorphisms.
if ZgramL[1][1, 1] < 0
    ZgramL[1] = -ZgramL[1]
    ZgramM[1] = -ZgramM[1]
end
```

This is interesting: the implementation internally **converts negative definite to positive definite** by multiplying by -1. This is because "This does not change the automorphisms."

So the question is: **what is the actual upstream contract** for `is_isometric`? Let me check what the docs actually say.

Looking at the current docstring:
- It says "Return whether the lattices `L` and `M` are isometric."
- It doesn't explicitly say "definite" like `automorphism_group_generators` does.

But the source code shows they internally handle negative definite by converting to positive definite. So it seems like:
1. The docstring doesn't specify definiteness (unlike `automorphism_group_generators` which says "Given a definite lattice")
2. The code handles both PD and ND internally

So the question becomes: is `[PD]` correct or should it be `[DEFINITE]` (or possibly `[all signatures]` or `[none]`)? 

Actually, the key observation is: the source code shows it works for negative definite too (it converts to positive definite internally). So `[PD]` is technically wrong - it should at least be `[DEFINITE]` or perhaps no tag at all since it handles both.

But wait - there's a subtlety. The conversion `if ZgramL[1][1, 1] < 0` only works if there's a single component. For mixed-signature lattices (indefinite with both positive and negative directions), this might fail or give wrong results.


Now I should check the actual documentation to see what it says about definiteness requirements.
exec
/bin/bash -lc "curl -sL \"https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/\" 2>&1 | grep -B5 -A20 'id=\"is_isometric-Tuple' | head -40" in /home/dzack/lattice_interface succeeded in 72ms:
  over rational field
with gram matrix
[ 4   -2]
[-2    5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L214-L231">source</a></section></details></article><h2 id="Invariants"><a class="docs-heading-anchor" href="#Invariants">Invariants</a><a id="Invariants-1"></a><a class="docs-heading-anchor-permalink" href="#Invariants" title="Permalink"></a></h2><article><details class="docstring"><summary id="rank-Tuple{ZZLat}"><a class="docstring-binding" href="#rank-Tuple{ZZLat}"><code>rank</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rank(L::AbstractLat) -&gt; Int</code></pre><p>Return the rank of the underlying module of the lattice <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L139-L143">source</a></section></details></article><article><details class="docstring"><summary id="det-Tuple{ZZLat}"><a class="docstring-binding" href="#det-Tuple{ZZLat}"><code>det</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">det(L::ZZLat) -&gt; QQFieldElem</code></pre><p>Return the determinant of the gram matrix of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1102-L1106">source</a></section></details></article><article><details class="docstring"><summary id="scale-Tuple{ZZLat}"><a class="docstring-binding" href="#scale-Tuple{ZZLat}"><code>scale</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scale(L::ZZLat) -&gt; QQFieldElem</code></pre><p>Return the scale of <code>L</code>.</p><p>The scale of <code>L</code> is defined as the positive generator of the <span>$\mathbb Z$</span>-ideal generated by <span>$\{\Phi(x, y) : x, y \in L\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1017-L1024">source</a></section></details></article><article><details class="docstring"><summary id="norm-Tuple{ZZLat}"><a class="docstring-binding" href="#norm-Tuple{ZZLat}"><code>norm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">norm(L::ZZLat) -&gt; QQFieldElem</code></pre><p>Return the norm of <code>L</code>.</p><p>The norm of <code>L</code> is defined as the positive generator of the <span>$\mathbb Z$</span>- ideal generated by <span>$\{\Phi(x,x) : x \in L\}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1046-L1053">source</a></section></details></article><article><details class="docstring"><summary id="iseven-Tuple{ZZLat}"><a class="docstring-binding" href="#iseven-Tuple{ZZLat}"><code>iseven</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">iseven(L::ZZLat) -&gt; Bool</code></pre><p>Return whether <code>L</code> is even.</p><p>An integer lattice <code>L</code> in the rational quadratic space <span>$(V,\Phi)$</span> is called even if <span>$\Phi(x,x) \in 2\mathbb{Z}$</span> for all <span>$x in L$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1073-L1080">source</a></section></details></article><article><details class="docstring"><summary id="is_integral-Tuple{ZZLat}"><a class="docstring-binding" href="#is_integral-Tuple{ZZLat}"><code>is_integral</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_integral(L::AbstractLat) -&gt; Bool</code></pre><p>Return whether the lattice <code>L</code> is integral.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L748-L752">source</a></section></details></article><article><details class="docstring"><summary id="is_primary_with_prime-Tuple{ZZLat}"><a class="docstring-binding" href="#is_primary_with_prime-Tuple{ZZLat}"><code>is_primary_with_prime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_primary_with_prime(L::ZZLat) -&gt; Bool, ZZRingElem</code></pre><p>Given a <span>$\mathbb Z$</span>-lattice <code>L</code>, return whether <code>L</code> is primary, that is whether <code>L</code> is integral and its discriminant group (see <a href="../discriminant_group/#discriminant_group-Tuple{ZZLat}"><code>discriminant_group</code></a>) is a <code>p</code>-group for some prime number <code>p</code>. In case it is, <code>p</code> is also returned as second output.</p><p>Note that for unimodular lattices, this function returns <code>(true, 1)</code>. If the lattice is not primary, the second return value is <code>-1</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L3252-L3262">source</a></section></details></article><article><details class="docstring"><summary id="is_primary-Tuple{ZZLat, Union{Integer, ZZRingElem}}"><a class="docstring-binding" href="#is_primary-Tuple{ZZLat, Union{Integer, ZZRingElem}}"><code>is_primary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_primary(L::ZZLat, p::Union{Integer, ZZRingElem}) -&gt; Bool</code></pre><p>Given an integral <span>$\mathbb Z$</span>-lattice <code>L</code> and a prime number <code>p</code>, return whether <code>L</code> is <code>p</code>-primary, that is whether its discriminant group (see <a href="../discriminant_group/#discriminant_group-Tuple{ZZLat}"><code>discriminant_group</code></a>) is a <code>p</code>-group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L3276-L3282">source</a></section></details></article><article><details class="docstring"><summary id="is_elementary_with_prime-Tuple{ZZLat}"><a class="docstring-binding" href="#is_elementary_with_prime-Tuple{ZZLat}"><code>is_elementary_with_prime</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_elementary_with_prime(L::ZZLat) -&gt; Bool, ZZRingElem</code></pre><p>Given a <span>$\mathbb Z$</span>-lattice <code>L</code>, return whether <code>L</code> is elementary, that is whether <code>L</code> is integral and its discriminant group (see <a href="../discriminant_group/#discriminant_group-Tuple{ZZLat}"><code>discriminant_group</code></a>) is an elemenentary <code>p</code>-group for some prime number <code>p</code>. In case it is, <code>p</code> is also returned as second output.</p><p>Note that for unimodular lattices, this function returns <code>(true, 1)</code>. If the lattice is not elementary, the second return value is <code>-1</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L3297-L3307">source</a></section></details></article><article><details class="docstring"><summary id="is_elementary-Tuple{ZZLat, Union{Integer, ZZRingElem}}"><a class="docstring-binding" href="#is_elementary-Tuple{ZZLat, Union{Integer, ZZRingElem}}"><code>is_elementary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_elementary(L::ZZLat, p::Union{Integer, ZZRingElem}) -&gt; Bool</code></pre><p>Given an integral <span>$\mathbb Z$</span>-lattice <code>L</code> and a prime number <code>p</code>, return whether <code>L</code> is <code>p</code>-elementary, that is whether its discriminant group (see <a href="../discriminant_group/#discriminant_group-Tuple{ZZLat}"><code>discriminant_group</code></a>) is an elementary <code>p</code>-group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L3317-L3323">source</a></section></details></article><h3 id="The-Genus"><a class="docs-heading-anchor" href="#The-Genus">The Genus</a><a id="The-Genus-1"></a><a class="docs-heading-anchor-permalink" href="#The-Genus" title="Permalink"></a></h3><p>For an integral lattice The genus of an integer lattice collects its local invariants. <a href="../Zgenera/#genus-Tuple{ZZLat}"><code>genus(::ZZLat)</code></a></p><article><details class="docstring"><summary id="mass-Tuple{ZZLat}"><a class="docstring-binding" href="#mass-Tuple{ZZLat}"><code>mass</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">mass(L::ZZLat) -&gt; QQFieldElem</code></pre><p>Return the mass of the genus of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1272-L1276">source</a></section></details></article><article><details class="docstring"><summary id="genus_representatives-Tuple{ZZLat}"><a class="docstring-binding" href="#genus_representatives-Tuple{ZZLat}"><code>genus_representatives</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">genus_representatives(L::ZZLat) -&gt; Vector{ZZLat}</code></pre><p>Return representatives for the isometry classes in the genus of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1288-L1292">source</a></section></details></article><h3 id="Real-invariants"><a class="docs-heading-anchor" href="#Real-invariants">Real invariants</a><a id="Real-invariants-1"></a><a class="docs-heading-anchor-permalink" href="#Real-invariants" title="Permalink"></a></h3><article><details class="docstring"><summary id="signature_tuple-Tuple{ZZLat}"><a class="docstring-binding" href="#signature_tuple-Tuple{ZZLat}"><code>signature_tuple</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">signature_tuple(L::ZZLat) -&gt; Tuple{Int,Int,Int}</code></pre><p>Return the number of (positive, zero, negative) inertia of <code>L</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1129-L1133">source</a></section></details></article><article><details class="docstring"><summary id="is_positive_definite-Tuple{ZZLat}"><a class="docstring-binding" href="#is_positive_definite-Tuple{ZZLat}"><code>is_positive_definite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_positive_definite(L::AbstractLat) -&gt; Bool</code></pre><p>Return whether the rational span of the lattice <code>L</code> is positive definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L499-L503">source</a></section></details></article><article><details class="docstring"><summary id="is_negative_definite-Tuple{ZZLat}"><a class="docstring-binding" href="#is_negative_definite-Tuple{ZZLat}"><code>is_negative_definite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_negative_definite(L::AbstractLat) -&gt; Bool</code></pre><p>Return whether the rational span of the lattice <code>L</code> is negative definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L506-L510">source</a></section></details></article><article><details class="docstring"><summary id="is_definite-Tuple{ZZLat}"><a class="docstring-binding" href="#is_definite-Tuple{ZZLat}"><code>is_definite</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_definite(L::AbstractLat) -&gt; Bool</code></pre><p>Return whether the rational span of the lattice <code>L</code> is definite.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L513-L517">source</a></section></details></article><h2 id="Isometries"><a class="docs-heading-anchor" href="#Isometries">Isometries</a><a id="Isometries-1"></a><a class="docs-heading-anchor-permalink" href="#Isometries" title="Permalink"></a></h2><article><details class="docstring"><summary id="automorphism_group_generators-Tuple{ZZLat}"><a class="docstring-binding" href="#automorphism_group_generators-Tuple{ZZLat}"><code>automorphism_group_generators</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">automorphism_group_generators(E::EllipticCurve) -&gt; Vector{EllCrvIso}</code></pre><p>Return generators of the automorphism group of <span>$E$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/EllCrv/Isomorphisms.jl#L438-L441">source</a></section><section><div><pre><code class="language-julia hljs">automorphism_group_generators(L::AbstractLat; ambient_representation::Bool = true,
                                              depth::Int = -1, bacher_depth::Int = 0)
                                                      -&gt; Vector{MatElem}</code></pre><p>Given a definite lattice <code>L</code>, return generators for the automorphism group of <code>L</code>. If <code>ambient_representation == true</code> (the default), the transformations are represented with respect to the ambient space of <code>L</code>. Otherwise, the transformations are represented with respect to the (pseudo-)basis of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1526-L1539">source</a></section></details></article><article><details class="docstring"><summary id="automorphism_group_order-Tuple{ZZLat}"><a class="docstring-binding" href="#automorphism_group_order-Tuple{ZZLat}"><code>automorphism_group_order</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">automorphism_group_order(L::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -&gt; Int</code></pre><p>Given a definite lattice <code>L</code>, return the order of the automorphism group of <code>L</code>.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1583-L1591">source</a></section></details></article><article><details class="docstring"><summary id="is_isometric-Tuple{ZZLat, ZZLat}"><a class="docstring-binding" href="#is_isometric-Tuple{ZZLat, ZZLat}"><code>is_isometric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -&gt; Bool</code></pre><p>Return whether the lattices <code>L</code> and <code>M</code> are isometric.</p><p>Setting the parameters <code>depth</code> and <code>bacher_depth</code> to a positive value may improve performance. If set to <code>-1</code> (default), the used value of <code>depth</code> is chosen heuristically depending on the rank of <code>L</code>. By default, <code>bacher_depth</code> is set to <code>0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Lattices.jl#L1610-L1618">source</a></section></details></article><article><details class="docstring"><summary id="is_locally_isometric-Tuple{ZZLat, ZZLat, Int64}"><a class="docstring-binding" href="#is_locally_isometric-Tuple{ZZLat, ZZLat, Int64}"><code>is_locally_isometric</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_locally_isometric(L::ZZLat, M::ZZLat, p::Int) -&gt; Bool</code></pre><p>Return whether <code>L</code> and <code>M</code> are isometric over the <code>p</code>-adic integers.</p><p>i.e. whether <span>$L \otimes \mathbb{Z}_p \cong M\otimes \mathbb{Z}_p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/thofma/Hecke.jl/blob/v0.39.12/src/QuadForm/Quad/ZLattices.jl#L1213-L1219">source</a></section></details></article><h1 id="Root-lattices"><a class="docs-heading-anchor" href="#Root-lattices">Root lattices</a><a id="Root-lattices-1"></a><a class="docs-heading-anchor-permalink" href="#Root-lattices" title="Permalink"></a></h1><article><details class="docstring"><summary id="root_lattice_recognition-Tuple{ZZLat}"><a class="docstring-binding" href="#root_lattice_recognition-Tuple{ZZLat}"><code>root_lattice_recognition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">root_lattice_recognition(L::ZZLat)</code></pre><p>Return the ADE type of the root sublattice of <code>L</code>.</p><p>The root sublattice is the lattice spanned by the vectors of squared length <span>$1$</span> and <span>$2$</span>.  The odd lattice of rank 1 and determinant <span>$1$</span> is denoted by <code>(:I, 1)</code>.</p><p>Input:</p><p><code>L</code> – a definite and integral <span>$\mathbb{Z}$</span>-lattice.</p><p>Output:</p><p>Two lists, the first one containing the ADE types and the second one the irreducible root sublattices.</p><p>For more recognizable gram matrices use <a href="#root_lattice_recognition_fundamental-Tuple{ZZLat}"><code>root_lattice_recognition_fundamental</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; L = integer_lattice(; gram=ZZ[4  0 0  0 3  0 3  0;
                                     0 16 8 12 2 12 6 10;
                                     0  8 8  6 2  8 4  5;
                                     0 12 6 10 2  9 5  8;
                                     3  2 2  2 4  2 4  2;
                                     0 12 8  9 2 12 6  9;
                                     3  6 4  5 4  6 6  5;
                                     0 10 5  8 2  9 5  8])
Integer lattice of rank 8 and degree 8
with gram matrix
[4    0   0    0   3    0   3    0]
[0   16   8   12   2   12   6   10]
[0    8   8    6   2    8   4    5]
[0   12   6   10   2    9   5    8]
[3    2   2    2   4    2   4    2]
thinking
Now I have confirmation. Looking at the grep output, I can see the following key details:

1. The `automorphism_group_order` method has documentation that explicitly states "Given a **definite** lattice `L`" — not "positive definite".

2. Looking at the `is_isometric` method in the Hecke source code:
```julia
is_isometric(L::AbstractLat, M::AbstractLat; depth::Int = -1, bacher_depth::Int = 0) -> Bool

Return whether the lattices `L` and `M` are isometric.
```

The docstring doesn't mention a definiteness requirement at all! It just says "Return whether the lattices L and M are isometric."

3. And importantly, the implementation of `is_isometric_with_isometry` has this code:
```julia
# So the first one is either positive definite or negative definite
# Make it positive definite. This does not change the automorphisms.
if ZgramL[1][1, 1] < 0
    ZgramL[1] = -ZgramL[1]
    ZgramM[1] = -ZgramM[1]
end
```

This clearly shows that **negative definite lattices ARE supported** by `is_isometric`. The function automatically flips the sign to make it positive definite for the computation.

So my hypothesis is correct: `is_isometric` should be `[DEFINITE]` (not `[PD]`) because it works for both positive and negative definite lattices. The documentation incorrectly tags it as `[PD]` when the actual implementation supports both.

Now I need to fix this. Let me update the relevant documentation files to change `[PD]` to `[DEFINITE]` for `is_isometric` and `is_isometric_with_isometry`.
Plan update
Verifying and correcting the definiteness constraint for is_isometric methods - source code shows both PD and ND lattices are supported
  → Verify is_isometric definiteness constraint in source
  • Fix Julia lattice reference: is_isometric [PD] -> [DEFINITE]
  • Fix Hecke lattice reference: is_isometric [PD] -> [DEFINITE]
  • Fix Julia methods checklist: is_isometric [PD] -> [DEFINITE]
  • Update TODO.md with completed item
  • Write continuity memory and commit
thinking
Now I need to apply the edits to fix the `is_isometric` and `is_isometric_with_isometry` definiteness constraints. Based on the source code analysis:

1. `is_isometric(L::AbstractLat, M::AbstractLat; ...)` - No explicit definiteness mentioned in the docstring
2. `is_isometric_with_isometry` - The code explicitly handles both positive and negative definite by flipping signs: `if ZgramL[1][1, 1] < 0; ZgramL[1] = -ZgramL[1]; ZgramM[1] = -ZgramM[1]; end`

This confirms that both PD and ND lattices are supported. Let me apply the fixes now.
tool serena.read_file({"relative_path":"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md","start_line":230})
serena.read_file({"relative_path":"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md","start_line":230}) success in 363ms:
{
  "content": [
    {
      "type": "text",
      "text": "| `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)` | Generators of `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite); `ambient_representation=true` returns matrices in ambient-space coordinates | `[DEFINITE, GAP]` |\n| `automorphism_group_order(L::AbstractLat; depth::Int=-1, bacher_depth::Int=0)` | Order of `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite) | `[DEFINITE]` |\n| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |\n| `is_locally_isometric(L1, L2, p)` | $p$-adic isometry test | |\n| `is_rationally_isometric(L1, L2)` | Rational (ℚ) isometry test | `[INDEF ok]` |\n| `hasse_invariant(L, p)` | Hasse invariant at prime $p$ | |\n| `witt_invariant(L, p)` | Witt invariant at prime $p$ | |\n\n- DEFINITE (PD or ND): `automorphism_group_generators` / `automorphism_group_order` support both positive and negative definite lattices; finite groups computed via shortest vectors + symmetries (e.g. $E_8$ Weyl group); negative definite lattices may be passed directly (no need to rescale by $-1$ first)\n- Oscar also exposes \"Lattices with isometry\" and \"Groups of automorphisms\" sections\n- INDEF: Aut(L) infinite; use Indefinite.jl or Vinberg's algorithm for reflection subgroups\n- Rational/local isometry tests work for all signatures and are key ingredients in genus theory\n\n### 2.9 Module operations and embeddings\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `direct_sum(L1, L2)` | Orthogonal direct sum; returns $(L, i_1, i_2)$ with injection maps | |\n| `direct_product(L1, L2)` | Direct product; returns $(L, p_1, p_2)$ with projection maps | |\n| `biproduct(L1, L2)` | Biproduct; returns $(L, i_1, i_2, p_1, p_2)$ | |\n| `intersect(L1, L2)` | Intersection in common ambient space | |\n| `+(L1, L2)` | Sum of lattices in common ambient | |\n| `*(n, L)` | Scalar multiple of lattice | |\n| `lattice_in_same_ambient_space(L, B)` | Sublattice with basis B in ambient of L | |\n| `orthogonal_submodule(L, S)` | Orthogonal complement of S in L | |\n| `dual(L)` | Dual lattice $L^\\vee$ | |\n| `is_sublattice(L, S)` | Whether $S \\subseteq L$ | |\n| `is_sublattice_with_relations(L, S)` | Sublattice test + inclusion relations | |\n| `is_primitive(L, S)` | Whether S is primitive in L ($L/S$ torsion-free) | |\n| `primitive_closure(L, S)` | Smallest primitive sublattice of $L$ containing $S$ | |\n| `divisibility(L, v)` | Divisibility of vector $v$ in $L$ | |\n| `in(v, L)` | Vector membership test | |\n| `irreducible_components(L)` | Decompose into orthogonally irreducible components | |\n\n#### Overlattices and embeddings\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `glue_map(L, S, gen_imgs)` | Construct glue map for primitive extension | |\n| `overlattice(glue_map)` | Build overlattice from a glue map | |\n| `primitive_extension(L1, L2, glue_map)` | Nikulin gluing: lattice from isometric discriminant subquotients | |\n| `local_modification(M, L, p)` | Local modification at prime $p$; docs assume `M` is $\\mathbf{Z}_p$-maximal and `L` is isomorphic to `M` over $\\mathbf{Q}_p$ | |\n| `maximal_integral_lattice(L)` | Maximal integral overlattice | |\n| `is_maximal_integral(L)` | Whether $L$ is already maximal integral | |\n| `is_maximal(L)` | Whether $L$ is maximal | |\n| `embed(L, gen)` | Embed lattice into a genus | |\n| `embed_in_unimodular(L, ...)` | Embed into a unimodular lattice; current Hecke docs note this presently works only for even lattices | |\n\n#### Endomorphism-based sublattices\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `kernel_lattice(L, f)` | Kernel of endomorphism $f$ on $L$ | |\n| `invariant_lattice(::ZZLat, ::MatGroup)` | Fixed-point sublattice $L^G$ under finite group action | |\n| `coinvariant_lattice(::ZZLat, ::MatGroup)` | Orthogonal complement of $L^G$ in $L$ for finite group action | |\n| `invariant_coinvariant_pair(::ZZLat, ::Union{QQMatrix, Vector{QQMatrix}, MatGroup})` | Compute invariant/coinvariant pair simultaneously from a single isometry, a list of matrices, or a matrix group action | |\n\n#### Root lattice recognition\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `root_lattice_recognition(L)` | Identify ADE type of root sublattice | `[PD]` |\n| `root_lattice_recognition_fundamental(L)` | Find fundamental root system | `[PD]` |\n| `ADE_type(L)` | Determine root lattice type | `[PD]` |\n| `coxeter_number(L)` | Coxeter number | `[PD]` |\n| `highest_root(L)` | Highest root coordinates | `[PD]` |\n\n### 2.10 Vinberg's algorithm\n\n`[INDEF]` — For hyperbolic lattices (signature $(1,n)$). Enumerates simple roots defining the Weyl chamber of the reflection group.\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `vinberg_algorithm(Q::ZZMatrix, ub; v0, root_lengths, direction_vector)` | Fundamental roots of hyperbolic reflection lattice from Gram matrix | `[INDEF]` |\n| `vinberg_algorithm(S::ZZLat, ub; v0, root_lengths, direction_vector)` | Same, from `ZZLat` of signature $(1,0,n)$ | `[INDEF]` |\n| `short_vectors_affine(S, v, α, d)` | Vectors $x$ with $x^2 = d$, $x \\cdot v = \\alpha$ (used internally by Vinberg) | `[INDEF]` |\n\nComputes Coxeter diagram of reflecting hyperplanes. Applicable to even hyperbolic lattices ($U \\oplus E_8(-1)$, etc.). Implementation follows Algorithm 2.2 of Jingyu Shi 2015.\n\n### 2.11 Discriminant groups (`TorQuadModule`)\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `torsion_quadratic_module(M, N)` | Torsion quadratic module $M/N$ | |\n| `torsion_quadratic_module(q::QQMatrix)` | From rational Gram matrix | |\n| `discriminant_group(L)` | $L^\\vee / L$ as `TorQuadModule` | |\n| `abelian_group(T)` | Underlying abelian group | |\n| `cover(T)` / `relations(T)` | Cover lattice / relation lattice | |\n| `gram_matrix_bilinear(T)` | Bilinear Gram matrix over $\\mathbb{Q}/\\mathbb{Z}$ | |\n| `gram_matrix_quadratic(T)` | Quadratic Gram matrix over $\\mathbb{Q}/2\\mathbb{Z}$ | |\n| `value_module(T)` | Value module of bilinear form | |\n| `value_module_quadratic_form(T)` | Value module of quadratic form | |\n| `modulus_bilinear_form(T)` | Modulus of bilinear form | |\n| `modulus_quadratic_form(T)` | Modulus of quadratic form | |\n| `quadratic_product(a)` | $q(a)$ for element $a \\in T$ | |\n| `inner_product(a, b)` | $b(a,b)$ for elements $a,b \\in T$ | |\n| `lift(a)` / `representative(a)` | Lift element to cover lattice | |\n| `orthogonal_submodule(T, S)` | Orthogonal complement of submodule $S$ in $T$ | |\n| `is_isometric_with_isometry(T, U)` | Isometry test returning `(Bool, map)` (or `(false, 0)` if no isometry). Upstream states the contract assumes either equal quadratic-form moduli or prior rescaling to match, plus semiregular decomposition checks on `T ⊕ U` and `T ⊕ U^{-1}` | |\n| `is_anti_isometric_with_anti_isometry(T, U)` | Anti-isometry test returning `(Bool, anti_map)` (or `(false, 0)` if absent). Upstream documents the same modulus-matching/rescale precondition and semiregular decomposition checks | |\n| `is_degenerate(T)` | Degeneracy test | |\n| `is_semi_regular(T)` | Semi-regularity test | |\n| `radical_bilinear(T)` | Radical of bilinear form | |\n| `radical_quadratic(T)` | Radical of quadratic form | |\n| `normal_form(T; partial=false)` | Normal form of torsion quadratic module | |\n| `brown_invariant(T)` | Brown invariant (mod 8) | |\n| `snf(T)` / `is_snf(T)` | Smith normal form / test | |\n| `rescale(T, k)` | Rescaled module | |\n| `genus(T, sig_pair)` | Genus from discriminant form + signature | |\n| `is_genus(T, sig_pair)` | Check if a genus with this discriminant form exists | |\n| `direct_sum(T1, T2)` / `direct_product` / `biproduct` | Categorical constructions | |\n| `submodules(T::TorQuadModule; order::Int, index::Int, subtype::Vector{Int}, quotype::Vector{Int})` | Iterator over submodules of `T`; keyword filters: `order` (by cardinality), `index` (by index in `T`), `subtype` (by abelian-group invariants of the submodule), `quotype` (by abelian-group invariants of the quotient) | |\n| `stable_submodules(T::TorQuadModule, act::Vector{TorQuadModuleMap}; quotype::Vector{Int})` | Iterator over submodules of `T` stable under the endomorphisms in `act`; keyword `quotype` filters by quotient abelian-group invariants | |\n\n### 2.12 Hermitian lattices (`HermLat` / `QuadLat`)\n\nMethods shared with `ZZLat` (construction, rank, det, etc.) are listed in §2.2–2.8. Additional methods specific to lattices over number fields:\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `base_field(L)` / `base_ring(L)` | Base field $K$ / ring of integers $\\mathcal{O}_K$ | |\n| `fixed_field(L)` / `fixed_ring(L)` | Fixed field under involution / its ring | |\n| `involution(L)` | Involution of the hermitian form | |\n| `pseudo_matrix(L)` / `pseudo_basis(L)` | Pseudo-matrix / pseudo-basis (fractional ideals + vectors) | |\n| `coefficient_ideals(L)` | Coefficient ideals of pseudo-basis | |\n| `absolute_basis(L)` / `absolute_basis_matrix(L)` | Absolute $\\mathbb{Z}$-basis | |\n| `generators(L)` / `gram_matrix_of_generators(L)` | Generators and their Gram matrix | |\n| `local_basis_matrix(L, p)` | Basis matrix of $L_p$ | |\n| `jordan_decomposition(L, p)` | Jordan decomposition at prime $p$ | |\n| `is_isotropic(L, p)` | Whether $L_p$ is isotropic | |\n| `is_modular(L)` / `is_modular(L, p)` | Modular lattice test (global / local) | |\n| `can_scale_totally_positive(L)` | Whether the form can be rescaled to totally positive | |\n| `volume(L)` | Volume ideal | |\n| `is_maximal_integral(L)` / `is_maximal(L)` | Maximality tests | |\n| `maximal_integral_lattice(L)` | Maximal integral overlattice | |\n\n### 2.13 Quadratic spaces with isometry (`QuadSpaceWithIsom`)\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `quadratic_space_with_isometry(V, f; check)` | Pair space $V$ with isometry matrix $f$ (pass `check` explicitly; upstream docs currently show conflicting default wording) | |\n| `quadratic_space_with_isometry(V; neg=false)` | Pair with identity (or negation) | |\n| `space(Vf)` / `isometry(Vf)` / `order_of_isometry(Vf)` | Accessors (`order_of_isometry(Vf)=PosInf` for infinite-order isometries; rank-0 case uses `-1`) | |\n| `rank(Vf)` / `dim(Vf)` / `gram_matrix(Vf)` / `det(Vf)` / `discriminant(Vf)` | Space attributes | |\n| `diagonal(Vf)` / `signature_tuple(Vf)` | Diagonal / signature | |\n| `is_definite(Vf)` / `is_positive_definite(Vf)` / `is_negative_definite(Vf)` | Definiteness | |\n| `characteristic_polynomial(Vf)` / `minimal_polynomial(Vf)` | Polynomials of isometry | |\n| `^(Vf, n)` | Raise isometry to power | |\n| `direct_sum(Vf::Union{QuadSpaceWithIsom, Vector{QuadSpaceWithIsom}}...)` | Equivariant direct sum of quadratic spaces with isometry; current upstream signatures accept varargs and vector input, with binary form returning `(Vf, emb1, emb2)` | |\n| `rescale(Vf, a)` | Rescale preserving isometry | |\n| `rational_spinor_norm(Vf; b)` | Rational spinor norm | |\n\n### 2.14 Lattices with isometry (`ZZLatWithIsom`)\n\nPairs an integer lattice with a finite- or infinite-order isometry. Used for equivariant classification and K3/hyperkähler applications.\n\n#### Construction\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `integer_lattice_with_isometry(L, f; check, ambient_representation)` | Pair lattice $L$ with isometry matrix $f$; `ambient_representation` selects whether `f` is interpreted in the ambient-space basis (`true`) or in the fixed basis of `L` (`false`) | |\n| `integer_lattice_with_isometry(L; neg=false)` | Pair with identity (or negation if `neg=true`) | |\n| `lattice(Vf::QuadSpaceWithIsom)` | Extract lattice from space-with-isometry | |\n| `lattice(Vf::QuadSpaceWithIsom, B)` | Construct an integral lattice in ambient `Vf` from basis/generator matrix `B`; induced isometry is defined when the lattice is stable under ambient action | |\n| `lattice_in_same_ambient_space(Lf, B)` | Sublattice preserving ambient isometry | |\n\n#### Accessors\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `isometry(Lf)` | Isometry matrix | |\n| `ambient_isometry(Lf)` | Isometry on ambient space | |\n| `ambient_space(Lf)` | Ambient quadratic space carrying the isometry | |\n| `lattice(Lf)` | Underlying `ZZLat` | |\n| `basis_matrix(Lf)` | Basis matrix of underlying lattice | |\n| `order_of_isometry(Lf)` | Order of lattice isometry `f`; upstream defines it as a divisor of the ambient isometry order and documents support for both finite- and infinite-order isometries | |\n| `characteristic_polynomial(Lf)` / `minimal_polynomial(Lf)` | Polynomials of the isometry | |\n\n#### Attributes\n\nUpstream docs explicitly expose many `ZZLat` attributes on `ZZLatWithIsom`; these methods report invariants of the underlying lattice `L` in the pair `(L, f)` unless stated otherwise.\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `rank(Lf)` / `degree(Lf)` | Rank and ambient degree inherited from the underlying lattice | |\n| `gram_matrix(Lf)` / `det(Lf)` / `discriminant(Lf)` | Gram/determinant/discriminant invariants forwarded from `L` | |\n| `signature_tuple(Lf)` | Lattice signature tuple `(n_{+}, n_{0}, n_{-})`; distinct from eigenspace signatures returned by `signatures(Lf)` | `[INDEF]` |\n| `rational_span(Lf::ZZLatWithIsom)` | Returns `QuadSpaceWithIsom` — the rational span of the underlying lattice, carrying the induced isometry | `[INDEF]` |\n| `genus(Lf)` | Genus of the underlying lattice `L` | `[INDEF]` |\n| `minimum(Lf)` | Minimum of the underlying lattice; same positive-definite precondition as `minimum(L)` | `[PD]` |\n| `scale(Lf)` / `norm(Lf)` | Scale and norm ideals forwarded from `L` | |\n| `is_even(Lf)` / `is_integral(Lf)` / `is_unimodular(Lf)` | Arithmetic predicates of the underlying lattice | |\n| `is_primary(Lf, p)` / `is_primary_with_prime(Lf)` | `p`-primary discriminant-group predicates forwarded from `L` | |\n| `is_elementary(Lf, p)` / `is_elementary_with_prime(Lf)` | Elementary discriminant-group predicates forwarded from `L` | |\n| `is_positive_definite(Lf)` / `is_negative_definite(Lf)` / `is_definite(Lf)` | Definiteness predicates inherited from `L` | |\n\n#### Type classification\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `type(Lf)` | Type of lattice-with-isometry (dictionary of invariants) | |\n| `is_of_type(Lf, t)` | Test against a type | |\n| `is_of_same_type(Lf, Mg)` | Whether two lattices-with-isometry share the same type | |\n| `is_of_hermitian_type(Lf)` | Whether the isometry gives a hermitian structure | |\n| `hermitian_structure(Lf)` | Extract hermitian lattice from hermitian-type isometry | |\n| `trace_lattice_with_isometry(H)` | Recover `ZZLatWithIsom` from hermitian lattice via trace form | |\n| `trace_lattice_with_isometry(H, res)` | Recover `ZZLatWithIsom` from hermitian lattice with an explicit residue-field embedding choice used in trace-equivalence setup | |\n| `is_hermitian(t::Dict)` | Whether a type dictionary corresponds to hermitian type | |\n\n#### Operations\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `^(Lf, n)` | Raise isometry to power $n$ | |\n| `direct_sum(Lf::Union{ZZLatWithIsom, Vector{ZZLatWithIsom}}...)` | Equivariant direct sum of lattices with isometry; current upstream signatures accept varargs and vector input, with binary form returning `(Lf, emb1, emb2)` | |\n| `dual(Lf)` | Dual with induced isometry | |\n| `lll(Lf)` | LLL with isometry carried along | |\n| `rescale(Lf, a)` | Rescale with isometry preserved | |\n| `orthogonal_submodule(Lf, B)` | Orthogonal complement with induced isometry | |\n\n#### Kernel sublattices\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `kernel_lattice(Lf::ZZLatWithIsom, p::Union{ZZPolyRingElem, QQPolyRingElem})` | Kernel of polynomial $p$ applied to the isometry $f$, as a sublattice with induced action; primitive in $L$ (non-degeneracy ensures this) | |\n| `kernel_lattice(Lf::ZZLatWithIsom, l::Integer)` | Kernel of $f^l - 1$ as a sublattice with induced action; primitive in $L$ | |\n| `invariant_lattice(Lf::ZZLatWithIsom)` | Returns `ZZLatWithIsom` — fixed sublattice $L^f$ with induced isometry | |\n| `coinvariant_lattice(Lf::ZZLatWithIsom)` | Returns `ZZLatWithIsom` — orthogonal complement of $L^f$ with induced isometry | |\n| `invariant_coinvariant_pair(Lf::ZZLatWithIsom)` | Returns `(ZZLatWithIsom, ZZLatWithIsom)` — invariant and coinvariant sublattices simultaneously | |\n\n#### Discriminant groups\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `discriminant_group(Lf::ZZLatWithIsom)` | Returns `(TorQuadModule, AutomorphismGroupElem)` — discriminant module plus the element of `O(D_L)` induced by `f` | |\n| `discriminant_group(::Type{TorQuadModuleWithIsom}, Lf::ZZLatWithIsom; ambient_representation::Bool=true)` | Returns a `TorQuadModuleWithIsom` wrapping the discriminant module with induced isometry action; `ambient_representation` selects basis for representing the action | |\n| `image_centralizer_in_Oq(Lf::ZZLatWithIsom)` | Returns `(AutomorphismGroup{TorQuadModule}, GAPGroupHomomorphism)` — image $G_{L,f}$ of the centralizer map $O(L,f) \\to O(D_L, D_f)$; computable directly for definite lattices, ±identity isometries, and Euler-totient-rank cases; general case uses hermitian Miranda-Morrison theory, which **requires $L$ even** (local snapshot `latwithisom.md`) | |\n| `image_in_Oq(Lf)` | Computes image of $\\pi:O(L)\\to O(D_L)$ (Miranda-Morrison setting; documented for both definite and indefinite lattices; distinct from `image_centralizer_in_Oq`) | |\n| `discriminant_representation(L::ZZLat, G::MatGroup; ambient_representation::Bool=true, full::Bool=true, check::Bool=true)` | Returns `GAPGroupHomomorphism` — action of matrix group `G` on the discriminant group; `ambient_representation` selects coordinate system; `full` controls whether full discriminant group representation is computed; `check=true` validates input | |\n\n#### Spinor norm\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `signatures(Lf::ZZLatWithIsom)` | Returns `Dict{Int, Tuple{Int, Int}}` — signatures of the hermitian-type eigenspace decomposition; upstream constrains this to hermitian-type lattices with isometry whose minimal polynomial is irreducible and cyclotomic | |\n| `rational_spinor_norm(Lf::ZZLatWithIsom; b::Int=-1)` | Returns `QQFieldElem` — rational spinor norm of the isometry with respect to the form `b·Φ`; default `b=-1` | |\n\n#### Enumeration\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `enumerate_classes_of_lattices_with_isometry(::Union{ZZGenus, ZZLat}, ::Int)` | Enumerate isomorphism-class representatives for even lattices with finite-order isometry in a fixed genus/lattice context | |\n| `representatives_of_hermitian_type(::Union{ZZLat, ZZGenus}, ::Union{ZZPolyRingElem, QQPolyRingElem}, ::Int)` | Hermitian-type representatives for irreducible reciprocal polynomial input | |\n| `representatives_of_hermitian_type(::Union{ZZGenus, ZZLat}, ::Int, ::Int)` | Cyclotomic finite-order shortcut for hermitian-type representatives | |\n| `admissible_triples(::ZZGenus, ::Int)` | Tuples of genera satisfying $p$-admissibility constraints | |\n| `is_admissible_triple(::ZZGenus, ::ZZGenus, ::ZZGenus, ::Int)` | Validate $p$-admissibility for a genus triple | |\n| `splitting(::ZZLatWithIsom, ::Int, ::Int)` | Generic splitting routine in the finite-order enumeration machinery | |\n| `splitting_of_hermitian_type(::ZZLatWithIsom, ::Int, ::Int)` | Split hermitian-type lattice-with-isometry into hermitian sublattices | |\n| `splitting_of_prime_power(::ZZLatWithIsom, ::Int, ::Int)` | Split lattice-with-isometry at a prime-power stage | |\n| `splitting_of_pure_mixed_prime_power(::ZZLatWithIsom, ::Int)` | Split pure/mixed part at fixed prime | |\n| `splitting_of_mixed_prime_power(::ZZLatWithIsom, ::Int, ::Int)` | Split mixed part at prime-power stage | |\n\n### 2.15 Primitive embeddings\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `primitive_embeddings(L, M)` | Primitive embeddings of $M$ into $L$ | |\n| `primitive_embeddings(G::ZZGenus, M)` | Primitive embeddings into lattices of genus $G$ | |\n| `primitive_embeddings(q::TorQuadModule, sig, M)` | Via discriminant form + signature | |\n| `primitive_extensions(M, N)` | Isomorphism classes of primitive extensions of $M \\oplus N$ | |\n| `equivariant_primitive_extensions(Mf::ZZLatWithIsom, Nf::ZZLatWithIsom; glue_only=false)` | Equivariant primitive extensions (with isometries); returns `Vector{ZZLatWithIsom}` | |\n| `admissible_equivariant_primitive_extensions(Mf, Nf, gen, poly, p)` | Admissible equivariant extensions satisfying type conditions for a target genus | |\n\n### 2.16 Hermitian genera\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `genus(L::HermLat)` | Global genus of hermitian lattice | |\n| `genus(L::HermLat, p)` | Local genus at prime $p$ | |\n| `hermitian_genera(E::NumField, rank::Int, signatures::Vector{Tuple{Int, Int}}, determinant::Vector{QQFieldElem}; min_scale::Int=(determinant[1] != 0 ? 0 : -3), max_scale::Int=(determinant[1] != 0 ? 0 : 3), kwargs...)` | Enumerate hermitian genera; upstream requires `E` imaginary quadratic, `rank > 0`, and all determinants to have the same sign (positive if `rank` is even, negative if `rank` is odd) | |\n| `hermitian_local_genera(E::NumField, p::AbsNumFieldOrderIdeal, rank::Int, determinant::QQFieldElem, min_scale::Int, max_scale::Int)` | Enumerate local hermitian genera at ideal `p` within the explicit scale window `[min_scale, max_scale]` | |\n| `representative(G)` / `representatives(G)` | Representatives of genus classes | |\n| `genus_representatives(L)` | All representatives in genus of $L$ | |\n| `mass(L)` | Mass of hermitian lattice | |\n| `rank(G)` / `primes(G)` / `signatures(G)` / `is_integral(G)` | Genus attributes | |\n| `scale(G)` / `norm(G)` / `local_symbols(G)` | Scale, norm, local data | |\n| `direct_sum(G1, G2)` / `rescale(G, a)` | Operations on genera | |\n| `is_ramified(g)` / `is_split(g)` / `is_inert(g)` / `is_dyadic(g)` | Local genus splitting behavior | |\n\n### 2.17 Isometry group actions on lattices\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `is_isometry(::Hecke.QuadSpace, ::QQMatrix)` / `is_isometry(::ZZLat, ::QQMatrix)` | Matrix-level isometry check for quadratic spaces / integer lattices | |\n| `is_isometry_list(::Hecke.QuadSpace, ::Vector{QQMatrix})` / `is_isometry_list(::ZZLat, ::Vector{QQMatrix})` | Batch isometry checks for matrix lists | |\n| `is_isometry_group(::Hecke.QuadSpace, ::MatGroup)` / `is_isometry_group(::ZZLat, ::MatGroup)` | Group-level isometry check (upstream docs note these matrix/group check helpers are not exported) | |\n| `is_stable_isometry(::ZZLatWithIsom)` | Predicate that fixed isometry acts trivially on the discriminant group (stable isometry) | |\n| `is_special_isometry(::ZZLatWithIsom)` | Predicate that fixed isometry has determinant $+1$ (special isometry) | |\n| `special_orthogonal_group(::ZZLat)` / `special_subgroup(::ZZLat, ::MatGroup)` | $SO(L)$ and special subgroup of a finite isometry group | |\n| `stable_orthogonal_group(::ZZLat)` / `stable_subgroup(::ZZLat, ::MatGroup)` | Stable orthogonal group $O^{\\#}(L)$ and stable subgroup of a finite isometry group | |\n| `stabilizer_discriminant_subgroup(L::ZZLat, G::MatGroup, H::TorQuadModule; pointwise::Bool=false, ambient_representation::Bool=true, check::Bool=true)` | Largest subgroup of `G` preserving discriminant-group submodule `H`; returns `(MatGroup, GAPGroupHomomorphism)` | |\n| `stabilizer_in_orthogonal_group(L::ZZLat, B::QQMatrix; stable::Bool=false, special::Bool=false, check::Bool=true, kwargs...)` | Joint stabilizer in `O(L)` of vectors represented by rows of `B`; upstream requires the largest saturated orthogonal submodule of `L` orthogonal to `B` to be definite or of rank 2 | |\n| `pointwise_stabilizer_in_orthogonal_group(L::ZZLat, S::ZZLat; kwargs...)` | Pointwise stabilizer (fixes each vector of sublattice `S`); upstream requires the largest saturated orthogonal submodule of `L` orthogonal to `S` to be definite or of rank 2 | |\n| `setwise_stabilizer_in_orthogonal_group(L::ZZLat, S::Union{QQMatrix, ZZLat}; stable::Bool=false, special::Bool=false, check::Bool=true, kwargs...)` | Setwise stabilizer of `S`; upstream requires `S` and `S^\\perp` to be definite or of rank 2 (with non-primitive `S` allowed) | |\n| `pointwise_stabilizer_orthogonal_complement_in_orthogonal_group(L::ZZLat, S::Union{QQMatrix, ZZLat}; check::Bool=true, kwargs...)` | Pointwise stabilizer of the orthogonal complement `S^\\perp`; upstream requires `S` to be definite or of rank 2 | |\n| `stabilizer_in_diagonal_action(L::ZZLat, K::ZZLat, N::ZZLat, OK::MatGroup, ON::MatGroup; check::Bool=true)` | Generators for the setwise stabilizer of a primitive extension `K ⊕ N ⊆ L`; returns `Vector{QQMatrix}` | |\n| `maximal_extension(::ZZLat, ::ZZLat, ::MatGroup)` | Maximal extension in the group-action framework | |\n| `saturation(::ZZLat, ::MatGroup, ::MatGroup)` | Saturation of subgroup $H \\le G$; current docs state this explicit computation for finite `G` | |\n| `saturation(::ZZLat, ::MatGroup)` | Saturation inside $O(L)$; current docs require coinvariant lattice definite or rank 2 | |\n| `is_saturated_with_saturation(...)` | Saturation predicate plus witness; current docs state availability when coinvariant lattice is definite | |\n| `extend_to_ambient_space(L::ZZLat, F::T; check::Bool=false) where T <: Union{QQMatrix, Vector{QQMatrix}, MatGroup}` | Convert a collection of isometries from fixed lattice-basis coordinates to ambient-space coordinates; returns the same container type `T` | |\n| `restrict_to_lattice(L::ZZLat, F::T; check::Bool=false) where T <: Union{QQMatrix, Vector{QQMatrix}, MatGroup}` | Convert ambient-space isometries preserving `L` back to fixed lattice-basis coordinates; returns the same container type `T` | |\n\n- Constraint caveat: stabilizer-family methods carry explicit geometric preconditions in upstream docs (definite/rank-2 requirements on relevant orthogonal sublattices); these constraints are part of the method contracts.\n- Representation caveat: upstream text frames `extend_to_ambient_space` / `restrict_to_lattice` as basis-representation conversion for collections of isometries, with `restrict_to_lattice` also usable for ambient-space isometries preserving `L`.\n\n### 2.18 Torsion quadratic modules with isometry (`TorQuadModuleWithIsom`)\n\nFinite quadratic module workflows with a distinguished isometry action. This is the discriminant-form analogue of lattice-with-isometry surfaces and is central for equivariant gluing/classification contracts.\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `TorQuadModuleWithIsom` | Type for a torsion quadratic module paired with an isometry | `[NT]` |\n| `underlying_module(Tf)` / `torsion_quadratic_module(Tf)` | Access underlying finite quadratic module | `[NT]` |\n| `isometry(Tf)` / `order_of_isometry(Tf)` | Access isometry and its order; upstream notes order is finite-order data computed lazily and cached | `[NT]` |\n| `torsion_quadratic_module_with_isometry(T::TorQuadModule, [f::U]; check::Bool=true)` | Constructor from a `TorQuadModule` and an optional isometry `f`; upstream stable docs document `U` as any of `AutomorphismGroupElem{TorQuadModule}`, `TorQuadModuleMap`, `FinGenAbGroupHom`, `ZZMatrix`, or `MatGroupElem{QQFieldElem, QQMatrix}`; omitting `f` uses the identity; `check=true` validates compatibility | `[NT]` |\n| `torsion_quadratic_module_with_isometry(q::QQMatrix, [f::ZZMatrix]; check::Bool=true)` | Constructor from quadratic-form matrix data and optional integer action matrix; omitting `f` uses the identity; `check=true` validates constraints | `[NT]` |\n| `sub(Tf::TorQuadModuleWithIsom, gene::Vector{TorQuadModuleElem})` | Construct an isometry-stable submodule from generators; returns `(TorQuadModuleWithIsom, TorQuadModuleMap)` | `[NT]` |\n| `primary_part(Tf::TorQuadModuleWithIsom, m::IntegerUnion)` | Primary part with induced isometry action; returns `(TorQuadModuleWithIsom, TorQuadModuleMap)` | `[NT]` |\n| `orthogonal_submodule(Tf::TorQuadModuleWithIsom, S::TorQuadModule; check::Bool=true)` | Orthogonal complement with induced action; returns `(TorQuadModuleWithIsom, TorQuadModuleMap)`; upstream requires `S` stable under isometry (enforced when `check=true`) | `[NT]` |\n| `submodules(::TorQuadModuleWithIsom; quotype::Vector{Int}=Int[])` | Enumerate isometry-stable submodules of a torsion quadratic module with fixed isometry; upstream docs expose `quotype` filtering and restrict accepted selector values to `0,1,2,3` | `[NT]` |\n| `automorphism_group_with_inclusion(Tf::TorQuadModuleWithIsom)` | Automorphism group of the pair commuting with fixed isometry; returns `(AutomorphismGroup{TorQuadModule}, GAPGroupHomomorphism)` | `[NT]` |\n| `automorphism_group(Tf::TorQuadModuleWithMap)` | Automorphism group of the pair `(T, f)` (upstream method list typesets `TorQuadModuleWithMap` at this signature location; page context is `TorQuadModuleWithIsom` — treat as a documentation typesetting inconsistency) | `[NT]` |\n| `is_isomorphic_with_map(Tf, Sg)` | Isomorphism test between pairs; upstream return contract is `(true, map)` on success and `(false, 0)` on failure | `[NT]` |\n| `is_anti_isomorphic_with_map(Tf, Sg)` | Anti-isomorphism test between pairs; upstream return contract is `(true, anti_map)` on success and `(false, 0)` on failure | `[NT]` |\n\nSource note: contracts in §2.7/§2.11/§2.13/§2.14/§2.16/§2.17/§2.18 were reconciled against local snapshots under `docs/julia/oscar_jl/number_theory/quad_form_and_isom/` plus OSCAR stable/dev `QuadFormAndIsom` pages (including `spacewithisom`, `latwithisom`, `fingrpact`, `torquadmodwithisom`, and current index surfacing for collections/enumeration) and Hecke manual pages for genera (`quad_forms/genera`, `quad_forms/genusherm`) accessed 2026-02-17/2026-02-18. See provenance note `docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md`.\n- Pass-24 addendum (2026-02-18): `TorQuadModule.submodules` and `stable_submodules` typed signatures updated in §2.11 from OSCAR upstream Hecke discriminant-group docs; `torsion_quadratic_module_with_isometry` type union in §2.18 updated to include `AutomorphismGroupElem{TorQuadModule}` per OSCAR stable upstream constructor docs.\n\n### References\n\n- Oscar manual and Hecke GitHub documentation\n- Hofmann & Fieker (2025)\n- Nebe–Pless–Sloane (lattices), Conway–Sloane (theta series, classification)\n- Kirschmer–Voight (forms over number fields)\n- GAP Quadratic Forms package\n\n### Definiteness summary\n\n| Regime | Available methods |\n|--------|------------------|\n| **PD** | All: LLL, SVP/CVP, kissing number, genus, automorphisms, root recognition, theta series ingredients |\n| **ND** | Use `rescale(L, -1)` to reduce to PD |\n| **INDEF** | `lll` (runs, limited meaning); genus/discriminant forms; rational/local isometry; Vinberg's algorithm (sig $(1,n)$); discriminant group operations; no SVP/CVP |\n\n---\n\n## 3. Oscar.jl\n\nMetapackage combining Nemo, Hecke, Polymake, Singular, GAP. Does not add distinct lattice algorithms — provides unified interface to Hecke's methods.\n\n### Integration points\n\n| Capability | Notes |\n|------------|-------|\n| `Oscar.ZZLat` | High-level type wrapping Hecke's `ZZLat` |\n| `Oscar.to_oscar(obj)` | Emit reproducible Julia code to reconstruct `obj` (useful for `ZZLatWithIsom` examples and bug reports) |\n| Lattice databases | Markus Kirschmer's databases accessible directly |\n| `lll`, `short_vectors`, `close_vectors` | Dispatch to Hecke/Nemo |\n| Discriminant groups | Finite quadratic module type; computes isometries of discriminant form (Nikulin theory) |\n| `rescale(L, r)` | Documented with warnings about INDEF limitations |\n| Intersection forms | Verify primitive embeddings for Néron–Severi / K3 lattices (Nikulin theory) |\n| Polyhedral integration | Use lattice in polyhedral context via Polymake; compute Aut(L) as abstract group |\n\nSame definiteness constraints as Hecke. Oscar v1.6 includes Hecke v0.39.\n\n### References\n\n- Oscar manual, Quadratic Forms section\n- OSCAR homepage and reference paper (2023)\n- `using Oscar` provides unified namespace for Nemo LLL + Hecke genus functions\n\n---\n\n## 4. Nemo.jl\n\nComputer algebra over ℤ, ℚ, ℤ/n. Built on FLINT/Antic. Lattice = `ZZMatrix` (`fmpz_mat` — FLINT integer matrix) whose rows (or columns) form a basis in $\\mathbb{Z}^n$. Provides matrix-level reduction, not high-level lattice classification.\n\n### 4.1 LLL reduction\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `lll(B::ZZMatrix, ctx::LLLContext)` | LLL-reduced basis; default δ=0.99, η=0.51 | `[PD, FLINT]` |\n| `lll_with_transform(B)` | Returns $(L, T)$ with $L = T \\cdot B$ | `[PD, FLINT]` |\n| `lll_gram(G)` | LLL on Gram matrix $G = B B^T$; requires symmetric PSD | `[PD, FLINT]` |\n| `lll_gram_with_transform(G)` | Gram-based LLL + transformation | `[PD, FLINT]` |\n\n- `lll(B)` without explicit Gram uses standard Euclidean dot product\n- Gram-based variant requires symmetric, non-singular (or semi-definite) G\n- INDEF Gram: algorithm executes but \"reduced\" is meaningless — LLL criteria assume PD; supply a PD Gram majorant instead (as in BKZ contexts)\n\n### 4.2 Hermite Normal Form\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `hnf(X)` / `AbstractAlgebra.hnf(X)` | Hermite normal form (triangular, divisibility) | `[DEG, INDEF ok]` |\n| `hnf_with_transform(X)` | Returns $(H, U)$ with $H = U \\cdot X$ | `[DEG, INDEF ok]` |\n\nNo definiteness assumptions. Purely algebraic. Canonical representative of lattice basis. Used in ideal arithmetic and linear Diophantine equations. Fast modular HNF via FLINT. Does not prefer short vectors.\n\n### 4.3 Smith Normal Form\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `snf(X)` / `AbstractAlgebra.snf(X)` | Smith normal form; diagonal $D = UXV$ with invariant factors | `[DEG, INDEF ok]` |\n| `snf_with_transform(X)` | Returns $(D, U, V)$ | `[DEG, INDEF ok]` |\n\nReveals $\\mathbb{Z}^n / L \\cong \\mathbb{Z}/d_1 \\times \\cdots \\times \\mathbb{Z}/d_n$. Discriminant = $\\prod d_i$ (up to sign). No definiteness assumptions.\n\n### 4.4 Other\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| Echelon form | Via FLINT | `[DEG]` |\n| Saturation | No high-level `saturate` function; achieve via HNF/SNF (invariant factors reveal if sublattice has index > 1 in rational span) | `[DEG]` |\n\n### Interaction with Hecke\n\nNemo `ZZMatrix` / `QQMatrix` are the underlying matrix types in Hecke/Oscar lattice objects. One can extract basis/Gram and apply Nemo functions directly.\n\n### References\n\n- Fieker et al., ISSAC 2017\n- FLINT documentation (floating-point LLL, Gram-Schmidt)\n- Cohen, *A Course in Computational Algebraic Number Theory* (HNF/SNF)\n- Nguyen–Vallée, *The LLL Algorithm*\n\n---\n\n## 5. LLLplus.jl\n\n`[PD, EUCLID]` — Experimental lattice reduction toolkit by Christian Peel. Pure Julia. Not registered. Pedagogical / prototyping focus. Applications: cryptography, communications, integer programming.\n\n### Methods\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `lll(B)` | LLL reduction | `[PD, EUCLID]` |\n| `seysen(B)` | Seysen's reduction (minimizes pairwise dot products; more orthogonal than LLL) | `[PD, EUCLID]` |\n| `hkz(B)` | Hermite-Korkine-Zolotarev reduction (exact SVP in projected lattices; exponential cost) | `[PD, EUCLID]` |\n| `brun(B)` | Brun's algorithm (integer relations / Diophantine approximation; precursor to PSLQ) | `[PD, EUCLID]` |\n| `cvp(Q, R, y)` | Closest vector problem via sphere decoder (QR factorization input) | `[PD, EUCLID]` |\n\n### Utility functions\n\n| Function | Description |\n|----------|-------------|\n| `subsetsum(...)` | Subset sum via lattice formulation |\n| `integerfeasibility(...)` | Integer linear feasibility |\n| `rationalapprox(...)` | Rational approximation via short vectors |\n| BBP π digits | Spigot algorithm demo |\n\n### Definiteness\n\nAll algorithms assume Euclidean norm. Input is a real matrix (accepts `randn` floating-point); form is the standard inner product or implicit via QR. INDEF forms not supported. Brun's algorithm internally constructs a PD lattice in extended dimension. For serious/large-scale use, consider fplll (C++) or Nemo.\n\n### References\n\n- Wübben et al. (lattice reduction in communications)\n- Bremner, *Lattice Basis Reduction*\n- Simons Institute Lattice Algorithms workshop (2020)\n- Chris Peel, JuliaCon 2021: \"Lattice Reduction using LLLplus.jl\"\n\n---\n\n## 6. LatticeAlgorithms.jl (Amazon Science)\n\n`[PD, EUCLID]` — Lattice algorithms for GKP quantum error-correcting codes. Accompanied PRX Quantum 4, 040334 (2023).\n\n### Methods\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `lll(M)` | LLL reduction on basis matrix input | `[PD, EUCLID]` |\n| `islllreduced(B)` | Predicate for LLL-reduced basis conditions | `[PD, EUCLID]` |\n| `kz(M)` | KZ (HKZ-style) reduction routine | `[PD, EUCLID]` |\n| `closest_point(x, M)` | CVP-style closest-lattice-point solver | `[PD, EUCLID]` |\n| `closest_point_Dn(x)` | Specialized closest-point routine for $D_n$ | `[PD, EUCLID]` |\n| `Dn(n)` | Constructor/helper for the $D_n$ root lattice family | `[PD, EUCLID]` |\n| `distance(M)` / `distances(M)` | Lattice-distance helper routines used by decoding workflows | `[PD, EUCLID]` |\n\nHigher-level capabilities documented in the package context:\n\n- SVP/CVP and MLD workflows in multimode GKP decoding.\n- Predefined lattice families used in decoder benchmarks.\n\n### Definiteness\n\nAll algorithms require PD (Euclidean distance minimization). GKP symplectic form is INDEF but the decoding problem reduces to CVP in a PD lattice of errors.\n\n### References\n\n- \"Closest Lattice Point Decoding for Multimode GKP Codes\", PRX Quantum 4, 040334 (2023)\n- Subsequent arXiv papers on tensor-network / matching decoders with lattice methods\n- Search algorithm reference: Chalmers University publication (lattice point enumeration)\n- Algorithms efficient in moderate dimensions ($n \\sim 8$–$10$ for multimode GKP)\n- Repository: `https://github.com/QuantumSavory/LatticeAlgorithms.jl`\n- Research repository hub: `https://github.com/amazon-science/lattice-algorithms`\n\n---\n\n## 7. Minor Packages\n\n### 7.1 LatticeBasisReduction.jl\n\n`[PD, EUCLID]` — Minimal Julia package for LLL basis reduction.\n\n### Methods\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `lll(B::AbstractMatrix{<:Integer}; delta=0.99, eta=0.51)` | LLL reduction on an integer basis matrix. | `[PD, EUCLID]` |\n| `lll!(B::Matrix{BigFloat}; delta=0.99, eta=0.51)` | In-place LLL reduction on a `BigFloat` matrix. | `[PD, EUCLID]` |\n| `islllreduced(B::AbstractMatrix{BigFloat}; delta=0.99, eta=0.51)` | Predicate for LLL-reducedness conditions. | `[PD, EUCLID]` |\n\nCaveats:\n\n- The package exports `lll`; `lll!` and `islllreduced` are documented API surfaces but non-exported.\n- Implementation is Euclidean/Gram-Schmidt based and does not provide indefinite-form classification methods.\n\n### 7.2 MinkowskiReduction.jl\n\n`[PD, EUCLID]` — Minkowski reduction for integer lattice bases.\n\n### Methods\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `minkReduce(B::AbstractMatrix{<:Integer}; stable=true)` | Returns a Minkowski-reduced basis. | `[PD, EUCLID]` |\n| `deviousMat(n::Int64, m::Int64)` | Generator for difficult benchmark-style integer bases. | `[PD, EUCLID]` |\n\nCaveats:\n\n- Package scope is low-dimensional Euclidean reduction; no indefinite-form or genus/isometry classification APIs are documented.\n- Upstream notes implementation tested only up to rank `n <= 7`.\n\n### References\n\n- `https://github.com/MGBoom/LatticeBasisReduction.jl`\n- `https://mgboom.github.io/LatticeBasisReduction.jl/stable/API/`\n- `https://github.com/MGBoom/LatticeBasisReduction.jl/blob/master/src/LatticeBasisReduction.jl`\n- `https://github.com/glwhart/MinkowskiReduction.jl`\n- `https://github.com/glwhart/MinkowskiReduction.jl/blob/master/src/MinkowskiReduction.jl`\n- `https://github.com/glwhart/MinkowskiReduction.jl/blob/master/README.md`\n\n---\n\n## 8. Other Considerations\n\n### Theta series\n\nNo Julia package automates theta series computation. Use `short_vectors(L, 0, N)` in Hecke to count vectors by norm and assemble $\\Theta_L(q) = \\sum_{v \\in L} q^{|v|^2}$ manually. No `theta_series(L, precision)` function yet. No package for Eisenstein series or Siegel theta constants; use PARI/GP via Nemo for deeper analysis. `[PD]`\n\n### GAP packages (via GAP.jl / Oscar)\n\n`OrthogonalForms`, `AutomorphismGroups`, etc. Not Julia packages per se. Complement Oscar for exact isometry tests via Hasse invariants.\n\n### Performance notes\n\n| Package | Backend | Speed |\n|---------|---------|-------|\n| Nemo.jl | FLINT (C) | Fast (LLL, HNF) |\n| Hecke.jl | Nemo + GAP + optional PARI/MAGMA (genus computations) | Moderate–fast |\n| Indefinite.jl | GAP | Moderate |\n| LLLplus.jl | Pure Julia | Moderate; use fplll for large-scale |\n| LatticeAlgorithms.jl | Pure Julia | Moderate (designed for dim ~8–10) |\n\n---\n\n## 9. Definiteness Constraints Summary\n\n### Positive-definite\n\nAll reduction (LLL, BKZ, HKZ, Seysen), enumeration (SVP, CVP, `short_vectors`), and packing invariants (`kissing_number`, theta series) apply. Algorithms treat the lattice as a metric space.\n\n### Indefinite\n\nNo SVP/CVP (infinitely many vectors in any bounded norm range due to null directions). Use:\n- Genus symbols and discriminant forms for classification\n- Orbits of isotropic vectors (Indefinite.jl)\n- Vinberg's algorithm for sig $(1,n)$ reflection groups\n- Functions enforce via `check::Bool=true`; throws if form is not definite\n\n### Semi-definite / degenerate\n\nMost functions demand non-degenerate forms (\"nondegenerate $\\mathbb{Z}$-lattice\"). Preprocess by quotienting out the null space. HNF/SNF (Nemo) handle rank-deficient matrices. Hecke/Oscar error out and guide toward `rescale`, `scale(L)`, or orthogonal complement to remove null directions. Nemo/LLLplus simply assume away degenerate cases or rely on generic linear algebra for rank deficiency.\n\n---\n\n## Sources\n\n- Indefinite.jl README (Dutour Sikirić et al.)\n- Oscar/Hecke stable manual (lattices): https://docs.oscar-system.org/stable/Hecke/manual/lattices/integrelattices/ (accessed 2026-02-17)\n- Oscar/Hecke stable manual (lattices with isometry): https://docs.oscar-system.org/stable/Hecke/manual/lattices/lattices_with_isometry/ (accessed 2026-02-17)\n- In-repo localized provenance for `ZZLatWithIsom` attribute-forwarding survey: `docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom_online_provenance_2026-02-17.md`\n- Nemo.jl documentation — LLL, HNF\n- LLLplus.jl README\n- LatticeAlgorithms.jl README (Amazon Science)"
    }
  ],
  "structuredContent": {
    "result": "| `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)` | Generators of `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite); `ambient_representation=true` returns matrices in ambient-space coordinates | `[DEFINITE, GAP]` |\n| `automorphism_group_order(L::AbstractLat; depth::Int=-1, bacher_depth::Int=0)` | Order of `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite) | `[DEFINITE]` |\n| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |\n| `is_locally_isometric(L1, L2, p)` | $p$-adic isometry test | |\n| `is_rationally_isometric(L1, L2)` | Rational (ℚ) isometry test | `[INDEF ok]` |\n| `hasse_invariant(L, p)` | Hasse invariant at prime $p$ | |\n| `witt_invariant(L, p)` | Witt invariant at prime $p$ | |\n\n- DEFINITE (PD or ND): `automorphism_group_generators` / `automorphism_group_order` support both positive and negative definite lattices; finite groups computed via shortest vectors + symmetries (e.g. $E_8$ Weyl group); negative definite lattices may be passed directly (no need to rescale by $-1$ first)\n- Oscar also exposes \"Lattices with isometry\" and \"Groups of automorphisms\" sections\n- INDEF: Aut(L) infinite; use Indefinite.jl or Vinberg's algorithm for reflection subgroups\n- Rational/local isometry tests work for all signatures and are key ingredients in genus theory\n\n### 2.9 Module operations and embeddings\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `direct_sum(L1, L2)` | Orthogonal direct sum; returns $(L, i_1, i_2)$ with injection maps | |\n| `direct_product(L1, L2)` | Direct product; returns $(L, p_1, p_2)$ with projection maps | |\n| `biproduct(L1, L2)` | Biproduct; returns $(L, i_1, i_2, p_1, p_2)$ | |\n| `intersect(L1, L2)` | Intersection in common ambient space | |\n| `+(L1, L2)` | Sum of lattices in common ambient | |\n| `*(n, L)` | Scalar multiple of lattice | |\n| `lattice_in_same_ambient_space(L, B)` | Sublattice with basis B in ambient of L | |\n| `orthogonal_submodule(L, S)` | Orthogonal complement of S in L | |\n| `dual(L)` | Dual lattice $L^\\vee$ | |\n| `is_sublattice(L, S)` | Whether $S \\subseteq L$ | |\n| `is_sublattice_with_relations(L, S)` | Sublattice test + inclusion relations | |\n| `is_primitive(L, S)` | Whether S is primitive in L ($L/S$ torsion-free) | |\n| `primitive_closure(L, S)` | Smallest primitive sublattice of $L$ containing $S$ | |\n| `divisibility(L, v)` | Divisibility of vector $v$ in $L$ | |\n| `in(v, L)` | Vector membership test | |\n| `irreducible_components(L)` | Decompose into orthogonally irreducible components | |\n\n#### Overlattices and embeddings\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `glue_map(L, S, gen_imgs)` | Construct glue map for primitive extension | |\n| `overlattice(glue_map)` | Build overlattice from a glue map | |\n| `primitive_extension(L1, L2, glue_map)` | Nikulin gluing: lattice from isometric discriminant subquotients | |\n| `local_modification(M, L, p)` | Local modification at prime $p$; docs assume `M` is $\\mathbf{Z}_p$-maximal and `L` is isomorphic to `M` over $\\mathbf{Q}_p$ | |\n| `maximal_integral_lattice(L)` | Maximal integral overlattice | |\n| `is_maximal_integral(L)` | Whether $L$ is already maximal integral | |\n| `is_maximal(L)` | Whether $L$ is maximal | |\n| `embed(L, gen)` | Embed lattice into a genus | |\n| `embed_in_unimodular(L, ...)` | Embed into a unimodular lattice; current Hecke docs note this presently works only for even lattices | |\n\n#### Endomorphism-based sublattices\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `kernel_lattice(L, f)` | Kernel of endomorphism $f$ on $L$ | |\n| `invariant_lattice(::ZZLat, ::MatGroup)` | Fixed-point sublattice $L^G$ under finite group action | |\n| `coinvariant_lattice(::ZZLat, ::MatGroup)` | Orthogonal complement of $L^G$ in $L$ for finite group action | |\n| `invariant_coinvariant_pair(::ZZLat, ::Union{QQMatrix, Vector{QQMatrix}, MatGroup})` | Compute invariant/coinvariant pair simultaneously from a single isometry, a list of matrices, or a matrix group action | |\n\n#### Root lattice recognition\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `root_lattice_recognition(L)` | Identify ADE type of root sublattice | `[PD]` |\n| `root_lattice_recognition_fundamental(L)` | Find fundamental root system | `[PD]` |\n| `ADE_type(L)` | Determine root lattice type | `[PD]` |\n| `coxeter_number(L)` | Coxeter number | `[PD]` |\n| `highest_root(L)` | Highest root coordinates | `[PD]` |\n\n### 2.10 Vinberg's algorithm\n\n`[INDEF]` — For hyperbolic lattices (signature $(1,n)$). Enumerates simple roots defining the Weyl chamber of the reflection group.\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `vinberg_algorithm(Q::ZZMatrix, ub; v0, root_lengths, direction_vector)` | Fundamental roots of hyperbolic reflection lattice from Gram matrix | `[INDEF]` |\n| `vinberg_algorithm(S::ZZLat, ub; v0, root_lengths, direction_vector)` | Same, from `ZZLat` of signature $(1,0,n)$ | `[INDEF]` |\n| `short_vectors_affine(S, v, α, d)` | Vectors $x$ with $x^2 = d$, $x \\cdot v = \\alpha$ (used internally by Vinberg) | `[INDEF]` |\n\nComputes Coxeter diagram of reflecting hyperplanes. Applicable to even hyperbolic lattices ($U \\oplus E_8(-1)$, etc.). Implementation follows Algorithm 2.2 of Jingyu Shi 2015.\n\n### 2.11 Discriminant groups (`TorQuadModule`)\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `torsion_quadratic_module(M, N)` | Torsion quadratic module $M/N$ | |\n| `torsion_quadratic_module(q::QQMatrix)` | From rational Gram matrix | |\n| `discriminant_group(L)` | $L^\\vee / L$ as `TorQuadModule` | |\n| `abelian_group(T)` | Underlying abelian group | |\n| `cover(T)` / `relations(T)` | Cover lattice / relation lattice | |\n| `gram_matrix_bilinear(T)` | Bilinear Gram matrix over $\\mathbb{Q}/\\mathbb{Z}$ | |\n| `gram_matrix_quadratic(T)` | Quadratic Gram matrix over $\\mathbb{Q}/2\\mathbb{Z}$ | |\n| `value_module(T)` | Value module of bilinear form | |\n| `value_module_quadratic_form(T)` | Value module of quadratic form | |\n| `modulus_bilinear_form(T)` | Modulus of bilinear form | |\n| `modulus_quadratic_form(T)` | Modulus of quadratic form | |\n| `quadratic_product(a)` | $q(a)$ for element $a \\in T$ | |\n| `inner_product(a, b)` | $b(a,b)$ for elements $a,b \\in T$ | |\n| `lift(a)` / `representative(a)` | Lift element to cover lattice | |\n| `orthogonal_submodule(T, S)` | Orthogonal complement of submodule $S$ in $T$ | |\n| `is_isometric_with_isometry(T, U)` | Isometry test returning `(Bool, map)` (or `(false, 0)` if no isometry). Upstream states the contract assumes either equal quadratic-form moduli or prior rescaling to match, plus semiregular decomposition checks on `T ⊕ U` and `T ⊕ U^{-1}` | |\n| `is_anti_isometric_with_anti_isometry(T, U)` | Anti-isometry test returning `(Bool, anti_map)` (or `(false, 0)` if absent). Upstream documents the same modulus-matching/rescale precondition and semiregular decomposition checks | |\n| `is_degenerate(T)` | Degeneracy test | |\n| `is_semi_regular(T)` | Semi-regularity test | |\n| `radical_bilinear(T)` | Radical of bilinear form | |\n| `radical_quadratic(T)` | Radical of quadratic form | |\n| `normal_form(T; partial=false)` | Normal form of torsion quadratic module | |\n| `brown_invariant(T)` | Brown invariant (mod 8) | |\n| `snf(T)` / `is_snf(T)` | Smith normal form / test | |\n| `rescale(T, k)` | Rescaled module | |\n| `genus(T, sig_pair)` | Genus from discriminant form + signature | |\n| `is_genus(T, sig_pair)` | Check if a genus with this discriminant form exists | |\n| `direct_sum(T1, T2)` / `direct_product` / `biproduct` | Categorical constructions | |\n| `submodules(T::TorQuadModule; order::Int, index::Int, subtype::Vector{Int}, quotype::Vector{Int})` | Iterator over submodules of `T`; keyword filters: `order` (by cardinality), `index` (by index in `T`), `subtype` (by abelian-group invariants of the submodule), `quotype` (by abelian-group invariants of the quotient) | |\n| `stable_submodules(T::TorQuadModule, act::Vector{TorQuadModuleMap}; quotype::Vector{Int})` | Iterator over submodules of `T` stable under the endomorphisms in `act`; keyword `quotype` filters by quotient abelian-group invariants | |\n\n### 2.12 Hermitian lattices (`HermLat` / `QuadLat`)\n\nMethods shared with `ZZLat` (construction, rank, det, etc.) are listed in §2.2–2.8. Additional methods specific to lattices over number fields:\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `base_field(L)` / `base_ring(L)` | Base field $K$ / ring of integers $\\mathcal{O}_K$ | |\n| `fixed_field(L)` / `fixed_ring(L)` | Fixed field under involution / its ring | |\n| `involution(L)` | Involution of the hermitian form | |\n| `pseudo_matrix(L)` / `pseudo_basis(L)` | Pseudo-matrix / pseudo-basis (fractional ideals + vectors) | |\n| `coefficient_ideals(L)` | Coefficient ideals of pseudo-basis | |\n| `absolute_basis(L)` / `absolute_basis_matrix(L)` | Absolute $\\mathbb{Z}$-basis | |\n| `generators(L)` / `gram_matrix_of_generators(L)` | Generators and their Gram matrix | |\n| `local_basis_matrix(L, p)` | Basis matrix of $L_p$ | |\n| `jordan_decomposition(L, p)` | Jordan decomposition at prime $p$ | |\n| `is_isotropic(L, p)` | Whether $L_p$ is isotropic | |\n| `is_modular(L)` / `is_modular(L, p)` | Modular lattice test (global / local) | |\n| `can_scale_totally_positive(L)` | Whether the form can be rescaled to totally positive | |\n| `volume(L)` | Volume ideal | |\n| `is_maximal_integral(L)` / `is_maximal(L)` | Maximality tests | |\n| `maximal_integral_lattice(L)` | Maximal integral overlattice | |\n\n### 2.13 Quadratic spaces with isometry (`QuadSpaceWithIsom`)\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `quadratic_space_with_isometry(V, f; check)` | Pair space $V$ with isometry matrix $f$ (pass `check` explicitly; upstream docs currently show conflicting default wording) | |\n| `quadratic_space_with_isometry(V; neg=false)` | Pair with identity (or negation) | |\n| `space(Vf)` / `isometry(Vf)` / `order_of_isometry(Vf)` | Accessors (`order_of_isometry(Vf)=PosInf` for infinite-order isometries; rank-0 case uses `-1`) | |\n| `rank(Vf)` / `dim(Vf)` / `gram_matrix(Vf)` / `det(Vf)` / `discriminant(Vf)` | Space attributes | |\n| `diagonal(Vf)` / `signature_tuple(Vf)` | Diagonal / signature | |\n| `is_definite(Vf)` / `is_positive_definite(Vf)` / `is_negative_definite(Vf)` | Definiteness | |\n| `characteristic_polynomial(Vf)` / `minimal_polynomial(Vf)` | Polynomials of isometry | |\n| `^(Vf, n)` | Raise isometry to power | |\n| `direct_sum(Vf::Union{QuadSpaceWithIsom, Vector{QuadSpaceWithIsom}}...)` | Equivariant direct sum of quadratic spaces with isometry; current upstream signatures accept varargs and vector input, with binary form returning `(Vf, emb1, emb2)` | |\n| `rescale(Vf, a)` | Rescale preserving isometry | |\n| `rational_spinor_norm(Vf; b)` | Rational spinor norm | |\n\n### 2.14 Lattices with isometry (`ZZLatWithIsom`)\n\nPairs an integer lattice with a finite- or infinite-order isometry. Used for equivariant classification and K3/hyperkähler applications.\n\n#### Construction\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `integer_lattice_with_isometry(L, f; check, ambient_representation)` | Pair lattice $L$ with isometry matrix $f$; `ambient_representation` selects whether `f` is interpreted in the ambient-space basis (`true`) or in the fixed basis of `L` (`false`) | |\n| `integer_lattice_with_isometry(L; neg=false)` | Pair with identity (or negation if `neg=true`) | |\n| `lattice(Vf::QuadSpaceWithIsom)` | Extract lattice from space-with-isometry | |\n| `lattice(Vf::QuadSpaceWithIsom, B)` | Construct an integral lattice in ambient `Vf` from basis/generator matrix `B`; induced isometry is defined when the lattice is stable under ambient action | |\n| `lattice_in_same_ambient_space(Lf, B)` | Sublattice preserving ambient isometry | |\n\n#### Accessors\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `isometry(Lf)` | Isometry matrix | |\n| `ambient_isometry(Lf)` | Isometry on ambient space | |\n| `ambient_space(Lf)` | Ambient quadratic space carrying the isometry | |\n| `lattice(Lf)` | Underlying `ZZLat` | |\n| `basis_matrix(Lf)` | Basis matrix of underlying lattice | |\n| `order_of_isometry(Lf)` | Order of lattice isometry `f`; upstream defines it as a divisor of the ambient isometry order and documents support for both finite- and infinite-order isometries | |\n| `characteristic_polynomial(Lf)` / `minimal_polynomial(Lf)` | Polynomials of the isometry | |\n\n#### Attributes\n\nUpstream docs explicitly expose many `ZZLat` attributes on `ZZLatWithIsom`; these methods report invariants of the underlying lattice `L` in the pair `(L, f)` unless stated otherwise.\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `rank(Lf)` / `degree(Lf)` | Rank and ambient degree inherited from the underlying lattice | |\n| `gram_matrix(Lf)` / `det(Lf)` / `discriminant(Lf)` | Gram/determinant/discriminant invariants forwarded from `L` | |\n| `signature_tuple(Lf)` | Lattice signature tuple `(n_{+}, n_{0}, n_{-})`; distinct from eigenspace signatures returned by `signatures(Lf)` | `[INDEF]` |\n| `rational_span(Lf::ZZLatWithIsom)` | Returns `QuadSpaceWithIsom` — the rational span of the underlying lattice, carrying the induced isometry | `[INDEF]` |\n| `genus(Lf)` | Genus of the underlying lattice `L` | `[INDEF]` |\n| `minimum(Lf)` | Minimum of the underlying lattice; same positive-definite precondition as `minimum(L)` | `[PD]` |\n| `scale(Lf)` / `norm(Lf)` | Scale and norm ideals forwarded from `L` | |\n| `is_even(Lf)` / `is_integral(Lf)` / `is_unimodular(Lf)` | Arithmetic predicates of the underlying lattice | |\n| `is_primary(Lf, p)` / `is_primary_with_prime(Lf)` | `p`-primary discriminant-group predicates forwarded from `L` | |\n| `is_elementary(Lf, p)` / `is_elementary_with_prime(Lf)` | Elementary discriminant-group predicates forwarded from `L` | |\n| `is_positive_definite(Lf)` / `is_negative_definite(Lf)` / `is_definite(Lf)` | Definiteness predicates inherited from `L` | |\n\n#### Type classification\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `type(Lf)` | Type of lattice-with-isometry (dictionary of invariants) | |\n| `is_of_type(Lf, t)` | Test against a type | |\n| `is_of_same_type(Lf, Mg)` | Whether two lattices-with-isometry share the same type | |\n| `is_of_hermitian_type(Lf)` | Whether the isometry gives a hermitian structure | |\n| `hermitian_structure(Lf)` | Extract hermitian lattice from hermitian-type isometry | |\n| `trace_lattice_with_isometry(H)` | Recover `ZZLatWithIsom` from hermitian lattice via trace form | |\n| `trace_lattice_with_isometry(H, res)` | Recover `ZZLatWithIsom` from hermitian lattice with an explicit residue-field embedding choice used in trace-equivalence setup | |\n| `is_hermitian(t::Dict)` | Whether a type dictionary corresponds to hermitian type | |\n\n#### Operations\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `^(Lf, n)` | Raise isometry to power $n$ | |\n| `direct_sum(Lf::Union{ZZLatWithIsom, Vector{ZZLatWithIsom}}...)` | Equivariant direct sum of lattices with isometry; current upstream signatures accept varargs and vector input, with binary form returning `(Lf, emb1, emb2)` | |\n| `dual(Lf)` | Dual with induced isometry | |\n| `lll(Lf)` | LLL with isometry carried along | |\n| `rescale(Lf, a)` | Rescale with isometry preserved | |\n| `orthogonal_submodule(Lf, B)` | Orthogonal complement with induced isometry | |\n\n#### Kernel sublattices\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `kernel_lattice(Lf::ZZLatWithIsom, p::Union{ZZPolyRingElem, QQPolyRingElem})` | Kernel of polynomial $p$ applied to the isometry $f$, as a sublattice with induced action; primitive in $L$ (non-degeneracy ensures this) | |\n| `kernel_lattice(Lf::ZZLatWithIsom, l::Integer)` | Kernel of $f^l - 1$ as a sublattice with induced action; primitive in $L$ | |\n| `invariant_lattice(Lf::ZZLatWithIsom)` | Returns `ZZLatWithIsom` — fixed sublattice $L^f$ with induced isometry | |\n| `coinvariant_lattice(Lf::ZZLatWithIsom)` | Returns `ZZLatWithIsom` — orthogonal complement of $L^f$ with induced isometry | |\n| `invariant_coinvariant_pair(Lf::ZZLatWithIsom)` | Returns `(ZZLatWithIsom, ZZLatWithIsom)` — invariant and coinvariant sublattices simultaneously | |\n\n#### Discriminant groups\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `discriminant_group(Lf::ZZLatWithIsom)` | Returns `(TorQuadModule, AutomorphismGroupElem)` — discriminant module plus the element of `O(D_L)` induced by `f` | |\n| `discriminant_group(::Type{TorQuadModuleWithIsom}, Lf::ZZLatWithIsom; ambient_representation::Bool=true)` | Returns a `TorQuadModuleWithIsom` wrapping the discriminant module with induced isometry action; `ambient_representation` selects basis for representing the action | |\n| `image_centralizer_in_Oq(Lf::ZZLatWithIsom)` | Returns `(AutomorphismGroup{TorQuadModule}, GAPGroupHomomorphism)` — image $G_{L,f}$ of the centralizer map $O(L,f) \\to O(D_L, D_f)$; computable directly for definite lattices, ±identity isometries, and Euler-totient-rank cases; general case uses hermitian Miranda-Morrison theory, which **requires $L$ even** (local snapshot `latwithisom.md`) | |\n| `image_in_Oq(Lf)` | Computes image of $\\pi:O(L)\\to O(D_L)$ (Miranda-Morrison setting; documented for both definite and indefinite lattices; distinct from `image_centralizer_in_Oq`) | |\n| `discriminant_representation(L::ZZLat, G::MatGroup; ambient_representation::Bool=true, full::Bool=true, check::Bool=true)` | Returns `GAPGroupHomomorphism` — action of matrix group `G` on the discriminant group; `ambient_representation` selects coordinate system; `full` controls whether full discriminant group representation is computed; `check=true` validates input | |\n\n#### Spinor norm\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `signatures(Lf::ZZLatWithIsom)` | Returns `Dict{Int, Tuple{Int, Int}}` — signatures of the hermitian-type eigenspace decomposition; upstream constrains this to hermitian-type lattices with isometry whose minimal polynomial is irreducible and cyclotomic | |\n| `rational_spinor_norm(Lf::ZZLatWithIsom; b::Int=-1)` | Returns `QQFieldElem` — rational spinor norm of the isometry with respect to the form `b·Φ`; default `b=-1` | |\n\n#### Enumeration\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `enumerate_classes_of_lattices_with_isometry(::Union{ZZGenus, ZZLat}, ::Int)` | Enumerate isomorphism-class representatives for even lattices with finite-order isometry in a fixed genus/lattice context | |\n| `representatives_of_hermitian_type(::Union{ZZLat, ZZGenus}, ::Union{ZZPolyRingElem, QQPolyRingElem}, ::Int)` | Hermitian-type representatives for irreducible reciprocal polynomial input | |\n| `representatives_of_hermitian_type(::Union{ZZGenus, ZZLat}, ::Int, ::Int)` | Cyclotomic finite-order shortcut for hermitian-type representatives | |\n| `admissible_triples(::ZZGenus, ::Int)` | Tuples of genera satisfying $p$-admissibility constraints | |\n| `is_admissible_triple(::ZZGenus, ::ZZGenus, ::ZZGenus, ::Int)` | Validate $p$-admissibility for a genus triple | |\n| `splitting(::ZZLatWithIsom, ::Int, ::Int)` | Generic splitting routine in the finite-order enumeration machinery | |\n| `splitting_of_hermitian_type(::ZZLatWithIsom, ::Int, ::Int)` | Split hermitian-type lattice-with-isometry into hermitian sublattices | |\n| `splitting_of_prime_power(::ZZLatWithIsom, ::Int, ::Int)` | Split lattice-with-isometry at a prime-power stage | |\n| `splitting_of_pure_mixed_prime_power(::ZZLatWithIsom, ::Int)` | Split pure/mixed part at fixed prime | |\n| `splitting_of_mixed_prime_power(::ZZLatWithIsom, ::Int, ::Int)` | Split mixed part at prime-power stage | |\n\n### 2.15 Primitive embeddings\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `primitive_embeddings(L, M)` | Primitive embeddings of $M$ into $L$ | |\n| `primitive_embeddings(G::ZZGenus, M)` | Primitive embeddings into lattices of genus $G$ | |\n| `primitive_embeddings(q::TorQuadModule, sig, M)` | Via discriminant form + signature | |\n| `primitive_extensions(M, N)` | Isomorphism classes of primitive extensions of $M \\oplus N$ | |\n| `equivariant_primitive_extensions(Mf::ZZLatWithIsom, Nf::ZZLatWithIsom; glue_only=false)` | Equivariant primitive extensions (with isometries); returns `Vector{ZZLatWithIsom}` | |\n| `admissible_equivariant_primitive_extensions(Mf, Nf, gen, poly, p)` | Admissible equivariant extensions satisfying type conditions for a target genus | |\n\n### 2.16 Hermitian genera\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `genus(L::HermLat)` | Global genus of hermitian lattice | |\n| `genus(L::HermLat, p)` | Local genus at prime $p$ | |\n| `hermitian_genera(E::NumField, rank::Int, signatures::Vector{Tuple{Int, Int}}, determinant::Vector{QQFieldElem}; min_scale::Int=(determinant[1] != 0 ? 0 : -3), max_scale::Int=(determinant[1] != 0 ? 0 : 3), kwargs...)` | Enumerate hermitian genera; upstream requires `E` imaginary quadratic, `rank > 0`, and all determinants to have the same sign (positive if `rank` is even, negative if `rank` is odd) | |\n| `hermitian_local_genera(E::NumField, p::AbsNumFieldOrderIdeal, rank::Int, determinant::QQFieldElem, min_scale::Int, max_scale::Int)` | Enumerate local hermitian genera at ideal `p` within the explicit scale window `[min_scale, max_scale]` | |\n| `representative(G)` / `representatives(G)` | Representatives of genus classes | |\n| `genus_representatives(L)` | All representatives in genus of $L$ | |\n| `mass(L)` | Mass of hermitian lattice | |\n| `rank(G)` / `primes(G)` / `signatures(G)` / `is_integral(G)` | Genus attributes | |\n| `scale(G)` / `norm(G)` / `local_symbols(G)` | Scale, norm, local data | |\n| `direct_sum(G1, G2)` / `rescale(G, a)` | Operations on genera | |\n| `is_ramified(g)` / `is_split(g)` / `is_inert(g)` / `is_dyadic(g)` | Local genus splitting behavior | |\n\n### 2.17 Isometry group actions on lattices\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `is_isometry(::Hecke.QuadSpace, ::QQMatrix)` / `is_isometry(::ZZLat, ::QQMatrix)` | Matrix-level isometry check for quadratic spaces / integer lattices | |\n| `is_isometry_list(::Hecke.QuadSpace, ::Vector{QQMatrix})` / `is_isometry_list(::ZZLat, ::Vector{QQMatrix})` | Batch isometry checks for matrix lists | |\n| `is_isometry_group(::Hecke.QuadSpace, ::MatGroup)` / `is_isometry_group(::ZZLat, ::MatGroup)` | Group-level isometry check (upstream docs note these matrix/group check helpers are not exported) | |\n| `is_stable_isometry(::ZZLatWithIsom)` | Predicate that fixed isometry acts trivially on the discriminant group (stable isometry) | |\n| `is_special_isometry(::ZZLatWithIsom)` | Predicate that fixed isometry has determinant $+1$ (special isometry) | |\n| `special_orthogonal_group(::ZZLat)` / `special_subgroup(::ZZLat, ::MatGroup)` | $SO(L)$ and special subgroup of a finite isometry group | |\n| `stable_orthogonal_group(::ZZLat)` / `stable_subgroup(::ZZLat, ::MatGroup)` | Stable orthogonal group $O^{\\#}(L)$ and stable subgroup of a finite isometry group | |\n| `stabilizer_discriminant_subgroup(L::ZZLat, G::MatGroup, H::TorQuadModule; pointwise::Bool=false, ambient_representation::Bool=true, check::Bool=true)` | Largest subgroup of `G` preserving discriminant-group submodule `H`; returns `(MatGroup, GAPGroupHomomorphism)` | |\n| `stabilizer_in_orthogonal_group(L::ZZLat, B::QQMatrix; stable::Bool=false, special::Bool=false, check::Bool=true, kwargs...)` | Joint stabilizer in `O(L)` of vectors represented by rows of `B`; upstream requires the largest saturated orthogonal submodule of `L` orthogonal to `B` to be definite or of rank 2 | |\n| `pointwise_stabilizer_in_orthogonal_group(L::ZZLat, S::ZZLat; kwargs...)` | Pointwise stabilizer (fixes each vector of sublattice `S`); upstream requires the largest saturated orthogonal submodule of `L` orthogonal to `S` to be definite or of rank 2 | |\n| `setwise_stabilizer_in_orthogonal_group(L::ZZLat, S::Union{QQMatrix, ZZLat}; stable::Bool=false, special::Bool=false, check::Bool=true, kwargs...)` | Setwise stabilizer of `S`; upstream requires `S` and `S^\\perp` to be definite or of rank 2 (with non-primitive `S` allowed) | |\n| `pointwise_stabilizer_orthogonal_complement_in_orthogonal_group(L::ZZLat, S::Union{QQMatrix, ZZLat}; check::Bool=true, kwargs...)` | Pointwise stabilizer of the orthogonal complement `S^\\perp`; upstream requires `S` to be definite or of rank 2 | |\n| `stabilizer_in_diagonal_action(L::ZZLat, K::ZZLat, N::ZZLat, OK::MatGroup, ON::MatGroup; check::Bool=true)` | Generators for the setwise stabilizer of a primitive extension `K ⊕ N ⊆ L`; returns `Vector{QQMatrix}` | |\n| `maximal_extension(::ZZLat, ::ZZLat, ::MatGroup)` | Maximal extension in the group-action framework | |\n| `saturation(::ZZLat, ::MatGroup, ::MatGroup)` | Saturation of subgroup $H \\le G$; current docs state this explicit computation for finite `G` | |\n| `saturation(::ZZLat, ::MatGroup)` | Saturation inside $O(L)$; current docs require coinvariant lattice definite or rank 2 | |\n| `is_saturated_with_saturation(...)` | Saturation predicate plus witness; current docs state availability when coinvariant lattice is definite | |\n| `extend_to_ambient_space(L::ZZLat, F::T; check::Bool=false) where T <: Union{QQMatrix, Vector{QQMatrix}, MatGroup}` | Convert a collection of isometries from fixed lattice-basis coordinates to ambient-space coordinates; returns the same container type `T` | |\n| `restrict_to_lattice(L::ZZLat, F::T; check::Bool=false) where T <: Union{QQMatrix, Vector{QQMatrix}, MatGroup}` | Convert ambient-space isometries preserving `L` back to fixed lattice-basis coordinates; returns the same container type `T` | |\n\n- Constraint caveat: stabilizer-family methods carry explicit geometric preconditions in upstream docs (definite/rank-2 requirements on relevant orthogonal sublattices); these constraints are part of the method contracts.\n- Representation caveat: upstream text frames `extend_to_ambient_space` / `restrict_to_lattice` as basis-representation conversion for collections of isometries, with `restrict_to_lattice` also usable for ambient-space isometries preserving `L`.\n\n### 2.18 Torsion quadratic modules with isometry (`TorQuadModuleWithIsom`)\n\nFinite quadratic module workflows with a distinguished isometry action. This is the discriminant-form analogue of lattice-with-isometry surfaces and is central for equivariant gluing/classification contracts.\n\n| Method | Description | Tags |\n|--------|-------------|------|\n| `TorQuadModuleWithIsom` | Type for a torsion quadratic module paired with an isometry | `[NT]` |\n| `underlying_module(Tf)` / `torsion_quadratic_module(Tf)` | Access underlying finite quadratic module | `[NT]` |\n| `isometry(Tf)` / `order_of_isometry(Tf)` | Access isometry and its order; upstream notes order is finite-order data computed lazily and cached | `[NT]` |\n| `torsion_quadratic_module_with_isometry(T::TorQuadModule, [f::U]; check::Bool=true)` | Constructor from a `TorQuadModule` and an optional isometry `f`; upstream stable docs document `U` as any of `AutomorphismGroupElem{TorQuadModule}`, `TorQuadModuleMap`, `FinGenAbGroupHom`, `ZZMatrix`, or `MatGroupElem{QQFieldElem, QQMatrix}`; omitting `f` uses the identity; `check=true` validates compatibility | `[NT]` |\n| `torsion_quadratic_module_with_isometry(q::QQMatrix, [f::ZZMatrix]; check::Bool=true)` | Constructor from quadratic-form matrix data and optional integer action matrix; omitting `f` uses the identity; `check=true` validates constraints | `[NT]` |\n| `sub(Tf::TorQuadModuleWithIsom, gene::Vector{TorQuadModuleElem})` | Construct an isometry-stable submodule from generators; returns `(TorQuadModuleWithIsom, TorQuadModuleMap)` | `[NT]` |\n| `primary_part(Tf::TorQuadModuleWithIsom, m::IntegerUnion)` | Primary part with induced isometry action; returns `(TorQuadModuleWithIsom, TorQuadModuleMap)` | `[NT]` |\n| `orthogonal_submodule(Tf::TorQuadModuleWithIsom, S::TorQuadModule; check::Bool=true)` | Orthogonal complement with induced action; returns `(TorQuadModuleWithIsom, TorQuadModuleMap)`; upstream requires `S` stable under isometry (enforced when `check=true`) | `[NT]` |\n| `submodules(::TorQuadModuleWithIsom; quotype::Vector{Int}=Int[])` | Enumerate isometry-stable submodules of a torsion quadratic module with fixed isometry; upstream docs expose `quotype` filtering and restrict accepted selector values to `0,1,2,3` | `[NT]` |\n| `automorphism_group_with_inclusion(Tf::TorQuadModuleWithIsom)` | Automorphism group of the pair commuting with fixed isometry; returns `(AutomorphismGroup{TorQuadModule}, GAPGroupHomomorphism)` | `[NT]` |\n| `automorphism_group(Tf::TorQuadModuleWithMap)` | Automorphism group of the pair `(T, f)` (upstream method list typesets `TorQuadModuleWithMap` at this signature location; page context is `TorQuadModuleWithIsom` — treat as a documentation typesetting inconsistency) | `[NT]` |\n| `is_isomorphic_with_map(Tf, Sg)` | Isomorphism test between pairs; upstream return contract is `(true, map)` on success and `(false, 0)` on failure | `[NT]` |\n| `is_anti_isomorphic_with_map(Tf, Sg)` | Anti-isomorphism test between pairs; upstream return contract is `(true, anti_map)` on success and `(false, 0)` on failure | `[NT]` |\n\nSource note: contracts in §2.7/§2.11/§2.13/§2.14/§2.16/§2.17/§2.18 were reconciled against local snapshots under `docs/julia/oscar_jl/number_theory/quad_form_and_isom/` plus OSCAR stable/dev `QuadFormAndIsom` pages (including `spacewithisom`, `latwithisom`, `fingrpact`, `torquadmodwithisom`, and current index surfacing for collections/enumeration) and Hecke manual pages for genera (`quad_forms/genera`, `quad_forms/genusherm`) accessed 2026-02-17/2026-02-18. See provenance note `docs/julia/oscar_jl/number_theory/quad_form_and_isom/isom_online_provenance_2026-02-17.md`.\n- Pass-24 addendum (2026-02-18): `TorQuadModule.submodules` and `stable_submodules` typed signatures updated in §2.11 from OSCAR upstream Hecke discriminant-group docs; `torsion_quadratic_module_with_isometry` type union in §2.18 updated to include `AutomorphismGroupElem{TorQuadModule}` per OSCAR stable upstream constructor docs.\n\n### References\n\n- Oscar manual and Hecke GitHub documentation\n- Hofmann & Fieker (2025)\n- Nebe–Pless–Sloane (lattices), Conway–Sloane (theta series, classification)\n- Kirschmer–Voight (forms over number fields)\n- GAP Quadratic Forms package\n\n### Definiteness summary\n\n| Regime | Available methods |\n|--------|------------------|\n| **PD** | All: LLL, SVP/CVP, kissing number, genus, automorphisms, root recognition, theta series ingredients |\n| **ND** | Use `rescale(L, -1)` to reduce to PD |\n| **INDEF** | `lll` (runs, limited meaning); genus/discriminant forms; rational/local isometry; Vinberg's algorithm (sig $(1,n)$); discriminant group operations; no SVP/CVP |\n\n---\n\n## 3. Oscar.jl\n\nMetapackage combining Nemo, Hecke, Polymake, Singular, GAP. Does not add distinct lattice algorithms — provides unified interface to Hecke's methods.\n\n### Integration points\n\n| Capability | Notes |\n|------------|-------|\n| `Oscar.ZZLat` | High-level type wrapping Hecke's `ZZLat` |\n| `Oscar.to_oscar(obj)` | Emit reproducible Julia code to reconstruct `obj` (useful for `ZZLatWithIsom` examples and bug reports) |\n| Lattice databases | Markus Kirschmer's databases accessible directly |\n| `lll`, `short_vectors`, `close_vectors` | Dispatch to Hecke/Nemo |\n| Discriminant groups | Finite quadratic module type; computes isometries of discriminant form (Nikulin theory) |\n| `rescale(L, r)` | Documented with warnings about INDEF limitations |\n| Intersection forms | Verify primitive embeddings for Néron–Severi / K3 lattices (Nikulin theory) |\n| Polyhedral integration | Use lattice in polyhedral context via Polymake; compute Aut(L) as abstract group |\n\nSame definiteness constraints as Hecke. Oscar v1.6 includes Hecke v0.39.\n\n### References\n\n- Oscar manual, Quadratic Forms section\n- OSCAR homepage and reference paper (2023)\n- `using Oscar` provides unified namespace for Nemo LLL + Hecke genus functions\n\n---\n\n## 4. Nemo.jl\n\nComputer algebra over ℤ, ℚ, ℤ/n. Built on FLINT/Antic. Lattice = `ZZMatrix` (`fmpz_mat` — FLINT integer matrix) whose rows (or columns) form a basis in $\\mathbb{Z}^n$. Provides matrix-level reduction, not high-level lattice classification.\n\n### 4.1 LLL reduction\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `lll(B::ZZMatrix, ctx::LLLContext)` | LLL-reduced basis; default δ=0.99, η=0.51 | `[PD, FLINT]` |\n| `lll_with_transform(B)` | Returns $(L, T)$ with $L = T \\cdot B$ | `[PD, FLINT]` |\n| `lll_gram(G)` | LLL on Gram matrix $G = B B^T$; requires symmetric PSD | `[PD, FLINT]` |\n| `lll_gram_with_transform(G)` | Gram-based LLL + transformation | `[PD, FLINT]` |\n\n- `lll(B)` without explicit Gram uses standard Euclidean dot product\n- Gram-based variant requires symmetric, non-singular (or semi-definite) G\n- INDEF Gram: algorithm executes but \"reduced\" is meaningless — LLL criteria assume PD; supply a PD Gram majorant instead (as in BKZ contexts)\n\n### 4.2 Hermite Normal Form\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `hnf(X)` / `AbstractAlgebra.hnf(X)` | Hermite normal form (triangular, divisibility) | `[DEG, INDEF ok]` |\n| `hnf_with_transform(X)` | Returns $(H, U)$ with $H = U \\cdot X$ | `[DEG, INDEF ok]` |\n\nNo definiteness assumptions. Purely algebraic. Canonical representative of lattice basis. Used in ideal arithmetic and linear Diophantine equations. Fast modular HNF via FLINT. Does not prefer short vectors.\n\n### 4.3 Smith Normal Form\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `snf(X)` / `AbstractAlgebra.snf(X)` | Smith normal form; diagonal $D = UXV$ with invariant factors | `[DEG, INDEF ok]` |\n| `snf_with_transform(X)` | Returns $(D, U, V)$ | `[DEG, INDEF ok]` |\n\nReveals $\\mathbb{Z}^n / L \\cong \\mathbb{Z}/d_1 \\times \\cdots \\times \\mathbb{Z}/d_n$. Discriminant = $\\prod d_i$ (up to sign). No definiteness assumptions.\n\n### 4.4 Other\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| Echelon form | Via FLINT | `[DEG]` |\n| Saturation | No high-level `saturate` function; achieve via HNF/SNF (invariant factors reveal if sublattice has index > 1 in rational span) | `[DEG]` |\n\n### Interaction with Hecke\n\nNemo `ZZMatrix` / `QQMatrix` are the underlying matrix types in Hecke/Oscar lattice objects. One can extract basis/Gram and apply Nemo functions directly.\n\n### References\n\n- Fieker et al., ISSAC 2017\n- FLINT documentation (floating-point LLL, Gram-Schmidt)\n- Cohen, *A Course in Computational Algebraic Number Theory* (HNF/SNF)\n- Nguyen–Vallée, *The LLL Algorithm*\n\n---\n\n## 5. LLLplus.jl\n\n`[PD, EUCLID]` — Experimental lattice reduction toolkit by Christian Peel. Pure Julia. Not registered. Pedagogical / prototyping focus. Applications: cryptography, communications, integer programming.\n\n### Methods\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `lll(B)` | LLL reduction | `[PD, EUCLID]` |\n| `seysen(B)` | Seysen's reduction (minimizes pairwise dot products; more orthogonal than LLL) | `[PD, EUCLID]` |\n| `hkz(B)` | Hermite-Korkine-Zolotarev reduction (exact SVP in projected lattices; exponential cost) | `[PD, EUCLID]` |\n| `brun(B)` | Brun's algorithm (integer relations / Diophantine approximation; precursor to PSLQ) | `[PD, EUCLID]` |\n| `cvp(Q, R, y)` | Closest vector problem via sphere decoder (QR factorization input) | `[PD, EUCLID]` |\n\n### Utility functions\n\n| Function | Description |\n|----------|-------------|\n| `subsetsum(...)` | Subset sum via lattice formulation |\n| `integerfeasibility(...)` | Integer linear feasibility |\n| `rationalapprox(...)` | Rational approximation via short vectors |\n| BBP π digits | Spigot algorithm demo |\n\n### Definiteness\n\nAll algorithms assume Euclidean norm. Input is a real matrix (accepts `randn` floating-point); form is the standard inner product or implicit via QR. INDEF forms not supported. Brun's algorithm internally constructs a PD lattice in extended dimension. For serious/large-scale use, consider fplll (C++) or Nemo.\n\n### References\n\n- Wübben et al. (lattice reduction in communications)\n- Bremner, *Lattice Basis Reduction*\n- Simons Institute Lattice Algorithms workshop (2020)\n- Chris Peel, JuliaCon 2021: \"Lattice Reduction using LLLplus.jl\"\n\n---\n\n## 6. LatticeAlgorithms.jl (Amazon Science)\n\n`[PD, EUCLID]` — Lattice algorithms for GKP quantum error-correcting codes. Accompanied PRX Quantum 4, 040334 (2023).\n\n### Methods\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `lll(M)` | LLL reduction on basis matrix input | `[PD, EUCLID]` |\n| `islllreduced(B)` | Predicate for LLL-reduced basis conditions | `[PD, EUCLID]` |\n| `kz(M)` | KZ (HKZ-style) reduction routine | `[PD, EUCLID]` |\n| `closest_point(x, M)` | CVP-style closest-lattice-point solver | `[PD, EUCLID]` |\n| `closest_point_Dn(x)` | Specialized closest-point routine for $D_n$ | `[PD, EUCLID]` |\n| `Dn(n)` | Constructor/helper for the $D_n$ root lattice family | `[PD, EUCLID]` |\n| `distance(M)` / `distances(M)` | Lattice-distance helper routines used by decoding workflows | `[PD, EUCLID]` |\n\nHigher-level capabilities documented in the package context:\n\n- SVP/CVP and MLD workflows in multimode GKP decoding.\n- Predefined lattice families used in decoder benchmarks.\n\n### Definiteness\n\nAll algorithms require PD (Euclidean distance minimization). GKP symplectic form is INDEF but the decoding problem reduces to CVP in a PD lattice of errors.\n\n### References\n\n- \"Closest Lattice Point Decoding for Multimode GKP Codes\", PRX Quantum 4, 040334 (2023)\n- Subsequent arXiv papers on tensor-network / matching decoders with lattice methods\n- Search algorithm reference: Chalmers University publication (lattice point enumeration)\n- Algorithms efficient in moderate dimensions ($n \\sim 8$–$10$ for multimode GKP)\n- Repository: `https://github.com/QuantumSavory/LatticeAlgorithms.jl`\n- Research repository hub: `https://github.com/amazon-science/lattice-algorithms`\n\n---\n\n## 7. Minor Packages\n\n### 7.1 LatticeBasisReduction.jl\n\n`[PD, EUCLID]` — Minimal Julia package for LLL basis reduction.\n\n### Methods\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `lll(B::AbstractMatrix{<:Integer}; delta=0.99, eta=0.51)` | LLL reduction on an integer basis matrix. | `[PD, EUCLID]` |\n| `lll!(B::Matrix{BigFloat}; delta=0.99, eta=0.51)` | In-place LLL reduction on a `BigFloat` matrix. | `[PD, EUCLID]` |\n| `islllreduced(B::AbstractMatrix{BigFloat}; delta=0.99, eta=0.51)` | Predicate for LLL-reducedness conditions. | `[PD, EUCLID]` |\n\nCaveats:\n\n- The package exports `lll`; `lll!` and `islllreduced` are documented API surfaces but non-exported.\n- Implementation is Euclidean/Gram-Schmidt based and does not provide indefinite-form classification methods.\n\n### 7.2 MinkowskiReduction.jl\n\n`[PD, EUCLID]` — Minkowski reduction for integer lattice bases.\n\n### Methods\n\n| Function | Description | Tags |\n|----------|-------------|------|\n| `minkReduce(B::AbstractMatrix{<:Integer}; stable=true)` | Returns a Minkowski-reduced basis. | `[PD, EUCLID]` |\n| `deviousMat(n::Int64, m::Int64)` | Generator for difficult benchmark-style integer bases. | `[PD, EUCLID]` |\n\nCaveats:\n\n- Package scope is low-dimensional Euclidean reduction; no indefinite-form or genus/isometry classification APIs are documented.\n- Upstream notes implementation tested only up to rank `n <= 7`.\n\n### References\n\n- `https://github.com/MGBoom/LatticeBasisReduction.jl`\n- `https://mgboom.github.io/LatticeBasisReduction.jl/stable/API/`\n- `https://github.com/MGBoom/LatticeBasisReduction.jl/blob/master/src/LatticeBasisReduction.jl`\n- `https://github.com/glwhart/MinkowskiReduction.jl`\n- `https://github.com/glwhart/MinkowskiReduction.jl/blob/master/src/MinkowskiReduction.jl`\n- `https://github.com/glwhart/MinkowskiReduction.jl/blob/master/README.md`\n\n---\n\n## 8. Other Considerations\n\n### Theta series\n\nNo Julia package automates theta series computation. Use `short_vectors(L, 0, N)` in Hecke to count vectors by norm and assemble $\\Theta_L(q) = \\sum_{v \\in L} q^{|v|^2}$ manually. No `theta_series(L, precision)` function yet. No package for Eisenstein series or Siegel theta constants; use PARI/GP via Nemo for deeper analysis. `[PD]`\n\n### GAP packages (via GAP.jl / Oscar)\n\n`OrthogonalForms`, `AutomorphismGroups`, etc. Not Julia packages per se. Complement Oscar for exact isometry tests via Hasse invariants.\n\n### Performance notes\n\n| Package | Backend | Speed |\n|---------|---------|-------|\n| Nemo.jl | FLINT (C) | Fast (LLL, HNF) |\n| Hecke.jl | Nemo + GAP + optional PARI/MAGMA (genus computations) | Moderate–fast |\n| Indefinite.jl | GAP | Moderate |\n| LLLplus.jl | Pure Julia | Moderate; use fplll for large-scale |\n| LatticeAlgorithms.jl | Pure Julia | Moderate (designed for dim ~8–10) |\n\n---\n\n## 9. Definiteness Constraints Summary\n\n### Positive-definite\n\nAll reduction (LLL, BKZ, HKZ, Seysen), enumeration (SVP, CVP, `short_vectors`), and packing invariants (`kissing_number`, theta series) apply. Algorithms treat the lattice as a metric space.\n\n### Indefinite\n\nNo SVP/CVP (infinitely many vectors in any bounded norm range due to null directions). Use:\n- Genus symbols and discriminant forms for classification\n- Orbits of isotropic vectors (Indefinite.jl)\n- Vinberg's algorithm for sig $(1,n)$ reflection groups\n- Functions enforce via `check::Bool=true`; throws if form is not definite\n\n### Semi-definite / degenerate\n\nMost functions demand non-degenerate forms (\"nondegenerate $\\mathbb{Z}$-lattice\"). Preprocess by quotienting out the null space. HNF/SNF (Nemo) handle rank-deficient matrices. Hecke/Oscar error out and guide toward `rescale`, `scale(L)`, or orthogonal complement to remove null directions. Nemo/LLLplus simply assume away degenerate cases or rely on generic linear algebra for rank deficiency.\n\n---\n\n## Sources\n\n- Indefinite.jl README (Dutour Sikirić et al.)\n- Oscar/Hecke stable manual (lattices): https://docs.oscar-system.org/stable/Hecke/manual/lattices/integrelattices/ (accessed 2026-02-17)\n- Oscar/Hecke stable manual (lattices with isometry): https://docs.oscar-system.org/stable/Hecke/manual/lattices/lattices_with_isometry/ (accessed 2026-02-17)\n- In-repo localized provenance for `ZZLatWithIsom` attribute-forwarding survey: `docs/julia/oscar_jl/number_theory/quad_form_and_isom/latwithisom_online_provenance_2026-02-17.md`\n- Nemo.jl documentation — LLL, HNF\n- LLLplus.jl README\n- LatticeAlgorithms.jl README (Amazon Science)"
  },
  "isError": false
}
thinking
I found the lines I need to fix:

Lines 233-234 in julia_lattice_methods_reference.md:
```
| `is_isometric(L1, L2)` | Isometry test | `[PD]` |
| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |
```

These need to change from `[PD]` to `[DEFINITE]`. Let me apply this patch.
tool serena.replace_content({"mode":"literal","needle":"| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |","relative_path":"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md","repl":"| `is_isometric(L1, L2)` | Isometry test; upstream requires `is_definite(L1)` and `is_definite(L2)` (positive or negative definite); uses LLL to rescale ND to PD before comparison | `[DEFINITE]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream requires `is_definite(L1)` and `is_definite(L2)`; docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[DEFINITE]` |"})
serena.replace_content({"mode":"literal","needle":"| `is_isometric(L1, L2)` | Isometry test | `[PD]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD]` |","relative_path":"docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md","repl":"| `is_isometric(L1, L2)` | Isometry test; upstream requires `is_definite(L1)` and `is_definite(L2)` (positive or negative definite); uses LLL to rescale ND to PD before comparison | `[DEFINITE]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream requires `is_definite(L1)` and `is_definite(L2)`; docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[DEFINITE]` |"}) success in 299ms:
{
  "content": [
    {
      "type": "text",
      "text": "OK"
    }
  ],
  "structuredContent": {
    "result": "OK"
  },
  "isError": false
}
thinking
Now I need to update the Hecke reference (nemo_hecke_lattice_reference.md).
tool serena.search_for_pattern({"context_lines_after":3,"context_lines_before":3,"paths_include_glob":"*.md","relative_path":"docs/julia/hecke_jl/lattice","substring_pattern":"is_isometric.*L1.*L2"})
serena.search_for_pattern({"context_lines_after":3,"context_lines_before":3,"paths_include_glob":"*.md","relative_path":"docs/julia/hecke_jl/lattice","substring_pattern":"is_isometric.*L1.*L2"}) success in 172ms:
{
  "content": [
    {
      "type": "text",
      "text": "{\"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md\": [\"  >  60:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global/local isometry tests | `[NT]` |\\n  >  61:| `is_isotropic(V, p)` | Local isotropy test | `[INDEF, NT]` |\\n  >  62:| `orthogonal_complement(V, M)` | Orthogonal complement | `[NT]` |\\n  >  63:| `orthogonal_projection(V, M)` | Orthogonal projection | `[NT]` |\\n  >  64:\\n  >  65:### 2.3 Lattice construction\\n  >  66:\\n  >  67:| Method | Description | Tags |\\n  >  68:|--------|-------------|------|\\n  >  69:| `integer_lattice(; gram=G)` | Integer lattice from Gram matrix | `[NT]` |\\n  >  70:| `integer_lattice(B; gram=G)` | Integer lattice from basis + optional Gram | `[NT]` |\\n  >  71:| `lattice(V, B)` | Lattice in ambient quadratic space `V` | `[NT]` |\\n  >  72:| `quadratic_lattice(K, gens; gram=M)` | Lattice from generators and Gram data | `[INDEF, NT]` |\\n  >  73:| `hermitian_lattice(E, gens; gram=M)` | Hermitian lattice from generators | `[NT]` |\\n  >  74:| `root_lattice(:A/:D/:E/:I, n)` | Root lattice constructors | `[PD, NT]` |\\n  >  75:| `hyperbolic_plane_lattice(n)` | Hyperbolic plane lattice | `[INDEF, NT]` |\\n  >  76:| `k3_lattice()` | K3 lattice constructor | `[INDEF, NT]` |\\n  >  77:| `mukai_lattice()` | Mukai lattice constructor | `[INDEF, NT]` |\\n  >  78:| `hyperkaehler_lattice(:K3, n=3)` | Hyperkahler intersection-form lattice | `[INDEF, NT]` |\\n  >  79:| `rescale(L, r)` | Rescaled lattice | `[NT]` |\\n  >  80:\\n  >  81:### 2.4 Intrinsic data and predicates\\n  >  82:\\n  >  83:| Method | Description | Tags |\\n  >  84:|--------|-------------|------|\\n  >  85:| `gram_matrix(L)` / `basis_matrix(L)` | Core matrix data | `[NT]` |\\n  >  86:| `ambient_space(L)` / `rational_span(L)` | Ambient/rational span | `[NT]` |\\n  >  87:| `rank(L)` / `degree(L)` | Rank/ambient degree | `[NT]` |\\n  >  88:| `signature_tuple(L)` | Signature triple `(n_positive, n_zero, n_negative)` | `[INDEF, NT]` |\\n  >  89:| `det(L)` / `discriminant(L)` | Determinant/discriminant | `[NT]` |\\n  >  90:| `scale(L)` / `norm(L)` | Scale and norm ideals | `[NT]` |\\n  >  91:| `is_even(L)` / `is_integral(L)` / `is_unimodular(L)` | Arithmetic predicates | `[NT]` |\\n  >  92:| `is_positive_definite(L)` / `is_negative_definite(L)` / `is_definite(L)` | Definiteness predicates | `[NT]` |\\n  >  93:| `is_primary(L, p)` / `is_elementary(L, p)` | Discriminant-group structure predicates | `[NT]` |\\n  >  94:\\n  >  95:### 2.5 Reduction and vector algorithms\\n  >  96:\\n  >  97:| Method | Description | Tags |\\n  >  98:|--------|-------------|------|\\n  >  99:| `lll(L::ZZLat; same_ambient::Bool=true, redo::Bool=false, ctx::LLLContext=...)` | LLL reduction; `redo=true` forces recomputation; Lovász parameters via `ctx` | `[RED, FLINT, INDEF]` |\\n  > 100:| `short_vectors(L::ZZLat, [lb=0,] ub, [elem_type=ZZRingElem]; check::Bool=true)` | Enumerate bounded-norm vectors; returns `Vector{Tuple{Vector{elem_type}, QQFieldElem}}` | `[PD, NT]` |\\n  > 101:| `short_vectors_iterator(L, lb, ub)` | Lazy bounded-norm iterator | `[PD, NT]` |\\n  > 102:| `shortest_vectors(L::ZZLat, [elem_type=ZZRingElem]; check::Bool=true)` | Shortest vectors + norm | `[PD, NT]` |\\n  > 103:| `minimum(L)` / `kissing_number(L)` | Shortest norm / kissing number | `[PD, NT]` |\\n  > 104:| `close_vectors(L::ZZLat, v::Vector, [lb,] ub; check::Bool=false)` | Bounded close-vector enumeration; **`check` defaults to `false`**; returns `Vector{Tuple{Vector{Int}, QQFieldElem}}` | `[PD, NT]` |\\n  > 105:| `vectors_of_square_and_divisibility(L, n, d)` | Arithmetic vector constraints | `[PD, NT]` |\\n  > 106:| `short_vectors_affine(S, v, a, d)` | Affine constrained vector search | `[INDEF, NT]` |\\n  > 107:\\n  > 108:Indefinite caveats:\\n  > 109:\\n  > 110:- `lll` can run on indefinite lattices, but \\\"shortness\\\" is relative to a majorant.\\n  > 111:- `short_vectors`/`shortest_vectors` are positive-definite workflows.\\n  > 112:- For indefinite reflection workflows use `short_vectors_affine` and Vinberg methods.\\n  > 113:\\n  > 114:### 2.6 Genus and classification\\n  > 115:\\n  > 116:| Method | Description | Tags |\\n  > 117:|--------|-------------|------|\\n  > 118:| `genus(L::ZZLat)` / `genus(A::MatElem)` | Global genus from lattice or Gram | `[INDEF, NT]` |\\n  > 119:| `genus(L, p)` | Local genus at prime `p` | `[NT]` |\\n  > 120:| `integer_genera(sig::Tuple{Int, Int}, det::RationalUnion; even::Bool=true, kwargs...)` / `integer_genera(sig::Tuple{Int, Int}, det::QQFieldElem; even::Bool=true, max_scale::Int=Int(det), rank::Int=sum(sig), kwargs...)` | Enumerate genera by signature and determinant; upstream requires determinant sign `(-1)^{s_-}` for `sig=(s_+, s_-)`, and parity compatibility (`det ∈ 2ZZ` for `even=true`, `det ∈ ZZ` for `even=false`) | `[NT]` |\\n  > 121:| `representative(gen)` / `representatives(gen)` | Class representatives in genus | `[NT]` |\\n  > 122:| `mass(gen)` | Genus mass | `[NT]` |\\n  > 123:| `primes(gen)` / `local_symbol(gen, p)` | Local symbol access | `[NT]` |\\n  > 124:| `quadratic_space(gen)` / `rational_representative(gen)` | Rational representatives | `[NT]` |\\n  > 125:| `represents(G1, G2)` | Representation relation between genera | `[NT]` |\\n  > 126:| `discriminant_group(L)` | `L^vee/L` as finite quadratic module | `[NT]` |\\n  > 127:| `genus_representatives(L)` | Representatives of genus of `L` | `[NT]` |\\n  > 128:\\n  > 129:### 2.7 Automorphisms and isometry\\n  > 130:\\n  > 131:| Method | Description | Tags |\\n  > 132:|--------|-------------|------|\\n  > 133:| `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)` | Generators for `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite); `ambient_representation=true` returns matrices in ambient-space coordinates | `[DEFINITE, GAP, NT]` |\\n  > 134:| `automorphism_group_order(L::AbstractLat; depth::Int=-1, bacher_depth::Int=0)` | Order of automorphism group; upstream requires `is_definite(L)` (positive or negative definite) | `[DEFINITE, NT]` |\\n  > 135:| `is_isometric(L1, L2)` | Isometry test | `[PD, NT]` |\\n  > 136:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD, NT]` |\\n  > 137:| `is_locally_isometric(L1, L2, p)` | Local p-adic isometry test | `[NT]` |\\n  > 138:| `is_rationally_isometric(L1, L2)` | Rational isometry test | `[INDEF, NT]` |\\n  > 139:| `hasse_invariant(L, p)` / `witt_invariant(L, p)` | Local invariants | `[NT]` |\\n  > 140:\\n  > 141:Definite note: `automorphism_group_generators` and `automorphism_group_order` support both positive and negative definite lattices; the upstream requirement is `is_definite(L)`, not `is_positive_definite(L)`.\\n  > 142:Indefinite note: full automorphism groups are often infinite; practical workflows rely on local/rational tests, genus/discriminant forms, and Vinberg/reflection tools.\\n  > 143:\\n  > 144:### 2.8 Module operations, embeddings, overlattices\\n  > 145:\\n  > 146:| Method | Description | Tags |\\n  > 147:|--------|-------------|------|\\n  > 148:| `direct_sum(L1, L2)` / `direct_product` / `biproduct` | Categorical lattice operations | `[NT]` |\\n  > 149:| `intersect(L1, L2)` / `+(L1, L2)` / `*(n, L)` | Basic module operations | `[NT]` |\"]}"
    }
  ],
  "structuredContent": {
    "result": "{\"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md\": [\"  >  60:| `is_isometric(V, W)` / `is_isometric(V, W, p)` | Global/local isometry tests | `[NT]` |\\n  >  61:| `is_isotropic(V, p)` | Local isotropy test | `[INDEF, NT]` |\\n  >  62:| `orthogonal_complement(V, M)` | Orthogonal complement | `[NT]` |\\n  >  63:| `orthogonal_projection(V, M)` | Orthogonal projection | `[NT]` |\\n  >  64:\\n  >  65:### 2.3 Lattice construction\\n  >  66:\\n  >  67:| Method | Description | Tags |\\n  >  68:|--------|-------------|------|\\n  >  69:| `integer_lattice(; gram=G)` | Integer lattice from Gram matrix | `[NT]` |\\n  >  70:| `integer_lattice(B; gram=G)` | Integer lattice from basis + optional Gram | `[NT]` |\\n  >  71:| `lattice(V, B)` | Lattice in ambient quadratic space `V` | `[NT]` |\\n  >  72:| `quadratic_lattice(K, gens; gram=M)` | Lattice from generators and Gram data | `[INDEF, NT]` |\\n  >  73:| `hermitian_lattice(E, gens; gram=M)` | Hermitian lattice from generators | `[NT]` |\\n  >  74:| `root_lattice(:A/:D/:E/:I, n)` | Root lattice constructors | `[PD, NT]` |\\n  >  75:| `hyperbolic_plane_lattice(n)` | Hyperbolic plane lattice | `[INDEF, NT]` |\\n  >  76:| `k3_lattice()` | K3 lattice constructor | `[INDEF, NT]` |\\n  >  77:| `mukai_lattice()` | Mukai lattice constructor | `[INDEF, NT]` |\\n  >  78:| `hyperkaehler_lattice(:K3, n=3)` | Hyperkahler intersection-form lattice | `[INDEF, NT]` |\\n  >  79:| `rescale(L, r)` | Rescaled lattice | `[NT]` |\\n  >  80:\\n  >  81:### 2.4 Intrinsic data and predicates\\n  >  82:\\n  >  83:| Method | Description | Tags |\\n  >  84:|--------|-------------|------|\\n  >  85:| `gram_matrix(L)` / `basis_matrix(L)` | Core matrix data | `[NT]` |\\n  >  86:| `ambient_space(L)` / `rational_span(L)` | Ambient/rational span | `[NT]` |\\n  >  87:| `rank(L)` / `degree(L)` | Rank/ambient degree | `[NT]` |\\n  >  88:| `signature_tuple(L)` | Signature triple `(n_positive, n_zero, n_negative)` | `[INDEF, NT]` |\\n  >  89:| `det(L)` / `discriminant(L)` | Determinant/discriminant | `[NT]` |\\n  >  90:| `scale(L)` / `norm(L)` | Scale and norm ideals | `[NT]` |\\n  >  91:| `is_even(L)` / `is_integral(L)` / `is_unimodular(L)` | Arithmetic predicates | `[NT]` |\\n  >  92:| `is_positive_definite(L)` / `is_negative_definite(L)` / `is_definite(L)` | Definiteness predicates | `[NT]` |\\n  >  93:| `is_primary(L, p)` / `is_elementary(L, p)` | Discriminant-group structure predicates | `[NT]` |\\n  >  94:\\n  >  95:### 2.5 Reduction and vector algorithms\\n  >  96:\\n  >  97:| Method | Description | Tags |\\n  >  98:|--------|-------------|------|\\n  >  99:| `lll(L::ZZLat; same_ambient::Bool=true, redo::Bool=false, ctx::LLLContext=...)` | LLL reduction; `redo=true` forces recomputation; Lovász parameters via `ctx` | `[RED, FLINT, INDEF]` |\\n  > 100:| `short_vectors(L::ZZLat, [lb=0,] ub, [elem_type=ZZRingElem]; check::Bool=true)` | Enumerate bounded-norm vectors; returns `Vector{Tuple{Vector{elem_type}, QQFieldElem}}` | `[PD, NT]` |\\n  > 101:| `short_vectors_iterator(L, lb, ub)` | Lazy bounded-norm iterator | `[PD, NT]` |\\n  > 102:| `shortest_vectors(L::ZZLat, [elem_type=ZZRingElem]; check::Bool=true)` | Shortest vectors + norm | `[PD, NT]` |\\n  > 103:| `minimum(L)` / `kissing_number(L)` | Shortest norm / kissing number | `[PD, NT]` |\\n  > 104:| `close_vectors(L::ZZLat, v::Vector, [lb,] ub; check::Bool=false)` | Bounded close-vector enumeration; **`check` defaults to `false`**; returns `Vector{Tuple{Vector{Int}, QQFieldElem}}` | `[PD, NT]` |\\n  > 105:| `vectors_of_square_and_divisibility(L, n, d)` | Arithmetic vector constraints | `[PD, NT]` |\\n  > 106:| `short_vectors_affine(S, v, a, d)` | Affine constrained vector search | `[INDEF, NT]` |\\n  > 107:\\n  > 108:Indefinite caveats:\\n  > 109:\\n  > 110:- `lll` can run on indefinite lattices, but \\\"shortness\\\" is relative to a majorant.\\n  > 111:- `short_vectors`/`shortest_vectors` are positive-definite workflows.\\n  > 112:- For indefinite reflection workflows use `short_vectors_affine` and Vinberg methods.\\n  > 113:\\n  > 114:### 2.6 Genus and classification\\n  > 115:\\n  > 116:| Method | Description | Tags |\\n  > 117:|--------|-------------|------|\\n  > 118:| `genus(L::ZZLat)` / `genus(A::MatElem)` | Global genus from lattice or Gram | `[INDEF, NT]` |\\n  > 119:| `genus(L, p)` | Local genus at prime `p` | `[NT]` |\\n  > 120:| `integer_genera(sig::Tuple{Int, Int}, det::RationalUnion; even::Bool=true, kwargs...)` / `integer_genera(sig::Tuple{Int, Int}, det::QQFieldElem; even::Bool=true, max_scale::Int=Int(det), rank::Int=sum(sig), kwargs...)` | Enumerate genera by signature and determinant; upstream requires determinant sign `(-1)^{s_-}` for `sig=(s_+, s_-)`, and parity compatibility (`det ∈ 2ZZ` for `even=true`, `det ∈ ZZ` for `even=false`) | `[NT]` |\\n  > 121:| `representative(gen)` / `representatives(gen)` | Class representatives in genus | `[NT]` |\\n  > 122:| `mass(gen)` | Genus mass | `[NT]` |\\n  > 123:| `primes(gen)` / `local_symbol(gen, p)` | Local symbol access | `[NT]` |\\n  > 124:| `quadratic_space(gen)` / `rational_representative(gen)` | Rational representatives | `[NT]` |\\n  > 125:| `represents(G1, G2)` | Representation relation between genera | `[NT]` |\\n  > 126:| `discriminant_group(L)` | `L^vee/L` as finite quadratic module | `[NT]` |\\n  > 127:| `genus_representatives(L)` | Representatives of genus of `L` | `[NT]` |\\n  > 128:\\n  > 129:### 2.7 Automorphisms and isometry\\n  > 130:\\n  > 131:| Method | Description | Tags |\\n  > 132:|--------|-------------|------|\\n  > 133:| `automorphism_group_generators(L::AbstractLat; ambient_representation::Bool=true, depth::Int=-1, bacher_depth::Int=0)` | Generators for `Aut(L)`; upstream requires `is_definite(L)` (positive or negative definite); `ambient_representation=true` returns matrices in ambient-space coordinates | `[DEFINITE, GAP, NT]` |\\n  > 134:| `automorphism_group_order(L::AbstractLat; depth::Int=-1, bacher_depth::Int=0)` | Order of automorphism group; upstream requires `is_definite(L)` (positive or negative definite) | `[DEFINITE, NT]` |\\n  > 135:| `is_isometric(L1, L2)` | Isometry test | `[PD, NT]` |\\n  > 136:| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD, NT]` |\\n  > 137:| `is_locally_isometric(L1, L2, p)` | Local p-adic isometry test | `[NT]` |\\n  > 138:| `is_rationally_isometric(L1, L2)` | Rational isometry test | `[INDEF, NT]` |\\n  > 139:| `hasse_invariant(L, p)` / `witt_invariant(L, p)` | Local invariants | `[NT]` |\\n  > 140:\\n  > 141:Definite note: `automorphism_group_generators` and `automorphism_group_order` support both positive and negative definite lattices; the upstream requirement is `is_definite(L)`, not `is_positive_definite(L)`.\\n  > 142:Indefinite note: full automorphism groups are often infinite; practical workflows rely on local/rational tests, genus/discriminant forms, and Vinberg/reflection tools.\\n  > 143:\\n  > 144:### 2.8 Module operations, embeddings, overlattices\\n  > 145:\\n  > 146:| Method | Description | Tags |\\n  > 147:|--------|-------------|------|\\n  > 148:| `direct_sum(L1, L2)` / `direct_product` / `biproduct` | Categorical lattice operations | `[NT]` |\\n  > 149:| `intersect(L1, L2)` / `+(L1, L2)` / `*(n, L)` | Basic module operations | `[NT]` |\"]}"
  },
  "isError": false
}
thinking
I see the Hecke reference still has `[PD, NT]` for `is_isometric`. Let me fix that:
tool serena.replace_content({"mode":"literal","needle":"| `is_isometric(L1, L2)` | Isometry test | `[PD, NT]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD, NT]` |","relative_path":"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md","repl":"| `is_isometric(L1, L2)` | Isometry test; upstream requires `is_definite(L1)` and `is_definite(L2)` (positive or negative definite); uses LLL to rescale ND to PD before comparison | `[DEFINITE, NT]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream requires `is_definite(L1)` and `is_definite(L2)`; docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[DEFINITE, NT]` |"})
serena.replace_content({"mode":"literal","needle":"| `is_isometric(L1, L2)` | Isometry test | `[PD, NT]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[PD, NT]` |","relative_path":"docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md","repl":"| `is_isometric(L1, L2)` | Isometry test; upstream requires `is_definite(L1)` and `is_definite(L2)` (positive or negative definite); uses LLL to rescale ND to PD before comparison | `[DEFINITE, NT]` |\n| `is_isometric_with_isometry(L1, L2)` | Isometry test returning `(isometric::Bool, f)`; upstream requires `is_definite(L1)` and `is_definite(L2)`; docs specify `(false, zero_matrix(QQ, 0, 0))` on failure and expose kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true` | `[DEFINITE, NT]` |"}) success in 997ms:
{
  "content": [
    {
      "type": "text",
      "text": "OK"
    }
  ],
  "structuredContent": {
    "result": "OK"
  },
  "isError": false
}
thinking
Now I need to check and update the Julia methods checklist.
tool serena.search_for_pattern({"context_lines_after":3,"context_lines_before":3,"paths_include_glob":"docs/julia_methods_checklist.md","relative_path":"docs","substring_pattern":"is_isometric"})
serena.search_for_pattern({"context_lines_after":3,"context_lines_before":3,"paths_include_glob":"docs/julia_methods_checklist.md","relative_path":"docs","substring_pattern":"is_isometric"}) success in 1.07s:
{
  "content": [
    {
      "type": "text",
      "text": "{\"docs/julia_methods_checklist.md\": [\"  >  41:- [ ] ``is_isometric(V, W)` / `is_isometric(V, W, p)``\", \"  >  41:- [ ] ``is_isometric(V, W)` / `is_isometric(V, W, p)``\", \"  > 158:- [ ] ``is_isometric(L1, L2)``\", \"  > 159:- [ ] ``is_isometric_with_isometry(L1, L2)``\", \"  > 229:- [x] ``is_isometric_with_isometry(T, U)`` [test: tests/julia_pytest/migrated_julia_doc/test_migrated_torquadmodule.py::test_22_is_isometric_with_isometry_torquadmodule_isometry_test]\", \"  > 229:- [x] ``is_isometric_with_isometry(T, U)`` [test: tests/julia_pytest/migrated_julia_doc/test_migrated_torquadmodule.py::test_22_is_isometric_with_isometry_torquadmodule_isometry_test]\"]}"
    }
  ],
  "structuredContent": {
    "result": "{\"docs/julia_methods_checklist.md\": [\"  >  41:- [ ] ``is_isometric(V, W)` / `is_isometric(V, W, p)``\", \"  >  41:- [ ] ``is_isometric(V, W)` / `is_isometric(V, W, p)``\", \"  > 158:- [ ] ``is_isometric(L1, L2)``\", \"  > 159:- [ ] ``is_isometric_with_isometry(L1, L2)``\", \"  > 229:- [x] ``is_isometric_with_isometry(T, U)`` [test: tests/julia_pytest/migrated_julia_doc/test_migrated_torquadmodule.py::test_22_is_isometric_with_isometry_torquadmodule_isometry_test]\", \"  > 229:- [x] ``is_isometric_with_isometry(T, U)`` [test: tests/julia_pytest/migrated_julia_doc/test_migrated_torquadmodule.py::test_22_is_isometric_with_isometry_torquadmodule_isometry_test]\"]}"
  },
  "isError": false
}
thinking
I need to look at the checklist entry more closely to see where the tags are stored.
tool serena.read_file({"end_line":"170","relative_path":"docs/julia_methods_checklist.md","start_line":155})
serena.read_file({"end_line":"170","relative_path":"docs/julia_methods_checklist.md","start_line":155}) success in 116ms:
{
  "content": [
    {
      "type": "text",
      "text": "- [ ] ``automorphism_group_order(L::AbstractLat; depth::Int=-1, bacher_depth::Int=0)``\n  - Caveat: upstream requires `is_definite(L)` — supports **both positive and negative definite** lattices; not restricted to positive definite only.\n- [ ] ``is_isometric(L1, L2)``\n- [ ] ``is_isometric_with_isometry(L1, L2)``\n  - Caveat: upstream documents tuple return `(isometric::Bool, f)` with `(false, zero_matrix(QQ, 0, 0))` on failure, and kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true`.\n- [x] ``is_locally_isometric(L1, L2, p)`` [test: tests/julia_pytest/migrated_julia_doc/test_migrated_zzlat_automorphism.py::test_9_is_locally_isometric_same_lattice_at_prime_2]\n- [ ] ``is_rationally_isometric(L1, L2)``\n- [ ] ``hasse_invariant(L, p)``\n- [ ] ``witt_invariant(L, p)``\n### 2.9 Module operations and embeddings\n\n- [ ] ``direct_sum(L1, L2)``\n- [ ] ``direct_product(L1, L2)``\n- [ ] ``biproduct(L1, L2)``\n- [ ] ``intersect(L1, L2)``\n- [x] ``+(L1, L2)`` [test: tests/julia_pytest/migrated_julia_doc/test_migrated_zzlat_module_ops.py::test_18_lattice_sum_in_common_ambient]"
    }
  ],
  "structuredContent": {
    "result": "- [ ] ``automorphism_group_order(L::AbstractLat; depth::Int=-1, bacher_depth::Int=0)``\n  - Caveat: upstream requires `is_definite(L)` — supports **both positive and negative definite** lattices; not restricted to positive definite only.\n- [ ] ``is_isometric(L1, L2)``\n- [ ] ``is_isometric_with_isometry(L1, L2)``\n  - Caveat: upstream documents tuple return `(isometric::Bool, f)` with `(false, zero_matrix(QQ, 0, 0))` on failure, and kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true`.\n- [x] ``is_locally_isometric(L1, L2, p)`` [test: tests/julia_pytest/migrated_julia_doc/test_migrated_zzlat_automorphism.py::test_9_is_locally_isometric_same_lattice_at_prime_2]\n- [ ] ``is_rationally_isometric(L1, L2)``\n- [ ] ``hasse_invariant(L, p)``\n- [ ] ``witt_invariant(L, p)``\n### 2.9 Module operations and embeddings\n\n- [ ] ``direct_sum(L1, L2)``\n- [ ] ``direct_product(L1, L2)``\n- [ ] ``biproduct(L1, L2)``\n- [ ] ``intersect(L1, L2)``\n- [x] ``+(L1, L2)`` [test: tests/julia_pytest/migrated_julia_doc/test_migrated_zzlat_module_ops.py::test_18_lattice_sum_in_common_ambient]"
  },
  "isError": false
}
thinking
Now I'll update the checklist to add the caveat about the definiteness constraint:
tool serena.replace_content({"mode":"literal","needle":"- [ ] ``is_isometric(L1, L2)``\n- [ ] ``is_isometric_with_isometry(L1, L2)``\n  - Caveat: upstream documents tuple return `(isometric::Bool, f)` with `(false, zero_matrix(QQ, 0, 0))` on failure, and kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true`.","relative_path":"docs/julia_methods_checklist.md","repl":"- [ ] ``is_isometric(L1, L2)``\n  - Caveat: upstream requires `is_definite(L1)` and `is_definite(L2)` — supports **both positive and negative definite** lattices; uses LLL to rescale ND to PD before comparison.\n- [ ] ``is_isometric_with_isometry(L1, L2)``\n  - Caveat: upstream requires `is_definite(L1)` and `is_definite(L2)`; documents tuple return `(isometric::Bool, f)` with `(false, zero_matrix(QQ, 0, 0))` on failure, and kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true`."})
serena.replace_content({"mode":"literal","needle":"- [ ] ``is_isometric(L1, L2)``\n- [ ] ``is_isometric_with_isometry(L1, L2)``\n  - Caveat: upstream documents tuple return `(isometric::Bool, f)` with `(false, zero_matrix(QQ, 0, 0))` on failure, and kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true`.","relative_path":"docs/julia_methods_checklist.md","repl":"- [ ] ``is_isometric(L1, L2)``\n  - Caveat: upstream requires `is_definite(L1)` and `is_definite(L2)` — supports **both positive and negative definite** lattices; uses LLL to rescale ND to PD before comparison.\n- [ ] ``is_isometric_with_isometry(L1, L2)``\n  - Caveat: upstream requires `is_definite(L1)` and `is_definite(L2)`; documents tuple return `(isometric::Bool, f)` with `(false, zero_matrix(QQ, 0, 0))` on failure, and kwargs `depth=3`, `bacher_depth=5`, `ambient_representation=true`."}) success in 52ms:
{
  "content": [
    {
      "type": "text",
      "text": "OK"
    }
  ],
  "structuredContent": {
    "result": "OK"
  },
  "isError": false
}
thinking
Now I need to update TODO.md with the completed item. Let me check the current state and add a new checked item for this work.
Plan update
Verifying and correcting the definiteness constraint for is_isometric methods - completed source verification and documentation fixes
  ✓ Verify is_isometric definiteness constraint in source
  ✓ Fix Julia lattice reference: is_isometric [PD] -> [DEFINITE]
  ✓ Fix Hecke lattice reference: is_isometric [PD] -> [DEFINITE]
  ✓ Fix Julia methods checklist: is_isometric [PD] -> [DEFINITE]
  → Update TODO.md with completed item
  • Write continuity memory and commit
thinking
Now I need to update TODO.md with the completed item and then write a continuity memory.
tool serena.read_file({"end_line":"30","relative_path":"docs/TODO.md","start_line":1})
serena.read_file({"end_line":"30","relative_path":"docs/TODO.md","start_line":1}) success in 61ms:
{
  "content": [
    {
      "type": "text",
      "text": "\nThis file tracks missing prerequisites for building the per-package method checklists correctly.\nThe checklists themselves track per-method completion; this file tracks what must exist *before* checklist entries can be filled out with source-backed accuracy (primarily: local copies of upstream docs).\n\nReal work needed.\n\n## Goal 1 maintenance checks (2026-02-18 pass)\n\n- [x] Cursory in-scope package-gap scan: no clear new bilinear-form lattice package surface requiring a new checklist was identified in this pass.\n\n## Goal 2 contract-fidelity items (2026-02-18 pass)\n\n- [x] Tighten `TorQuadModule.submodules` and `TorQuadModule.stable_submodules` signatures in Julia umbrella reference, Hecke mirror reference, and checklist — replaced `...` placeholders with source-backed typed signatures from upstream Hecke `TorQuadModule` discriminant-group docs.\n- [x] Reconcile `torsion_quadratic_module_with_isometry` constructor type union in Julia umbrella reference, Hecke mirror reference, and checklist — added `AutomorphismGroupElem{TorQuadModule}` to the documented type union `U` for the `f` parameter, per OSCAR stable upstream docs.\n- [x] Add optional-parameter fidelity (`[f]` notation) to both `torsion_quadratic_module_with_isometry` constructor rows across all three surfaces.\n- [x] Tighten `kernel_lattice(::ZZLatWithIsom, ...)` typed dispatch signatures (polynomial and integer overloads) and add primitivity caveats across checklist, Julia umbrella reference, and Hecke mirror reference — sourced from local snapshot `latwithisom.md`.\n- [x] Add missing even-lattice precondition to `image_centralizer_in_Oq` (hermitian Miranda-Morrison only available for even lattices) and differentiation caveat for `image_in_Oq` — sourced from local snapshot `latwithisom.md`.\n- [x] Add typed signatures and tuple return shapes for `TorQuadModuleWithIsom` submodule/aut-group methods (`sub`, `primary_part`, `orthogonal_submodule` return `(TorQuadModuleWithIsom, TorQuadModuleMap)`; `automorphism_group_with_inclusion` returns `(AutomorphismGroup{TorQuadModule}, GAPGroupHomomorphism)`) — sourced from OSCAR stable upstream `torquadmodwithisom` page (2026-02-18).\n- [x] Fix `discriminant_group(Lf)` return type to `(TorQuadModule, AutomorphismGroupElem)` and `::Type{TorQuadModuleWithIsom}` type-argument form; add `discriminant_representation` keyword args (`full`, `check`); add `invariant_coinvariant_pair(Lf)` tuple return `(ZZLatWithIsom, ZZLatWithIsom)`; add `signatures(Lf)` cyclotomic/irreducible constraint and `rational_spinor_norm` `b=-1` default; fix `close_vectors` `check` default to `false`; add `lll` `redo` and `ctx` kwargs; fix `rational_span(Lf)` return type to `QuadSpaceWithIsom` — all sourced from OSCAR stable upstream `latwithisom` and `integer_lattices` pages (2026-02-18).\n\n- [x] Fix `IntegralLattice.orthogonal_group` definiteness constraint: tag was `[PD]` (positive definite only) but upstream docs confirm negative definite lattices also work; only indefinite lattices raise `NotImplementedError` — corrected to `[DEFINITE]` across `sage_integral_lattice_reference.md` (method table + definiteness summary) and `sagemath_lattice_reference.md` (method table + two pitfalls entries). Sourced from local upstream snapshot `free_quadratic_module_integer_symmetric.html`.\n\n- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \"Given a definite lattice `L`\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.\n\n## Goal 2 contract-fidelity verification (2026-02-18 follow-up)\n\n- [x] Verified `torquadmodwithisom.md` local snapshot already has `submodules(::TorQuadModuleWithIsom; quotype::Vector{Int}=Int[])` keyword contract — Julia references and checklist are consistent with local snapshot.\n\n## Missing Local Doc Copies\n"
    }
  ],
  "structuredContent": {
    "result": "\nThis file tracks missing prerequisites for building the per-package method checklists correctly.\nThe checklists themselves track per-method completion; this file tracks what must exist *before* checklist entries can be filled out with source-backed accuracy (primarily: local copies of upstream docs).\n\nReal work needed.\n\n## Goal 1 maintenance checks (2026-02-18 pass)\n\n- [x] Cursory in-scope package-gap scan: no clear new bilinear-form lattice package surface requiring a new checklist was identified in this pass.\n\n## Goal 2 contract-fidelity items (2026-02-18 pass)\n\n- [x] Tighten `TorQuadModule.submodules` and `TorQuadModule.stable_submodules` signatures in Julia umbrella reference, Hecke mirror reference, and checklist — replaced `...` placeholders with source-backed typed signatures from upstream Hecke `TorQuadModule` discriminant-group docs.\n- [x] Reconcile `torsion_quadratic_module_with_isometry` constructor type union in Julia umbrella reference, Hecke mirror reference, and checklist — added `AutomorphismGroupElem{TorQuadModule}` to the documented type union `U` for the `f` parameter, per OSCAR stable upstream docs.\n- [x] Add optional-parameter fidelity (`[f]` notation) to both `torsion_quadratic_module_with_isometry` constructor rows across all three surfaces.\n- [x] Tighten `kernel_lattice(::ZZLatWithIsom, ...)` typed dispatch signatures (polynomial and integer overloads) and add primitivity caveats across checklist, Julia umbrella reference, and Hecke mirror reference — sourced from local snapshot `latwithisom.md`.\n- [x] Add missing even-lattice precondition to `image_centralizer_in_Oq` (hermitian Miranda-Morrison only available for even lattices) and differentiation caveat for `image_in_Oq` — sourced from local snapshot `latwithisom.md`.\n- [x] Add typed signatures and tuple return shapes for `TorQuadModuleWithIsom` submodule/aut-group methods (`sub`, `primary_part`, `orthogonal_submodule` return `(TorQuadModuleWithIsom, TorQuadModuleMap)`; `automorphism_group_with_inclusion` returns `(AutomorphismGroup{TorQuadModule}, GAPGroupHomomorphism)`) — sourced from OSCAR stable upstream `torquadmodwithisom` page (2026-02-18).\n- [x] Fix `discriminant_group(Lf)` return type to `(TorQuadModule, AutomorphismGroupElem)` and `::Type{TorQuadModuleWithIsom}` type-argument form; add `discriminant_representation` keyword args (`full`, `check`); add `invariant_coinvariant_pair(Lf)` tuple return `(ZZLatWithIsom, ZZLatWithIsom)`; add `signatures(Lf)` cyclotomic/irreducible constraint and `rational_spinor_norm` `b=-1` default; fix `close_vectors` `check` default to `false`; add `lll` `redo` and `ctx` kwargs; fix `rational_span(Lf)` return type to `QuadSpaceWithIsom` — all sourced from OSCAR stable upstream `latwithisom` and `integer_lattices` pages (2026-02-18).\n\n- [x] Fix `IntegralLattice.orthogonal_group` definiteness constraint: tag was `[PD]` (positive definite only) but upstream docs confirm negative definite lattices also work; only indefinite lattices raise `NotImplementedError` — corrected to `[DEFINITE]` across `sage_integral_lattice_reference.md` (method table + definiteness summary) and `sagemath_lattice_reference.md` (method table + two pitfalls entries). Sourced from local upstream snapshot `free_quadratic_module_integer_symmetric.html`.\n\n- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \"Given a definite lattice `L`\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.\n\n## Goal 2 contract-fidelity verification (2026-02-18 follow-up)\n\n- [x] Verified `torquadmodwithisom.md` local snapshot already has `submodules(::TorQuadModuleWithIsom; quotype::Vector{Int}=Int[])` keyword contract — Julia references and checklist are consistent with local snapshot.\n\n## Missing Local Doc Copies\n"
  },
  "isError": false
}
thinking
Now I need to add an item to the TODO for the is_isometric fix. Let me add it to the Goal 2 contract-fidelity items section.
tool serena.replace_content({"mode":"literal","needle":"- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \"Given a definite lattice `L`\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.","relative_path":"docs/TODO.md","repl":"- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \"Given a definite lattice `L`\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.\n\n- [x] Fix `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)` definiteness constraint: tags were `[PD]` but upstream Hecke source code (Lattices.jl) shows the implementation uses LLL to rescale negative definite to positive definite before comparison, explicitly requiring `is_definite(L)` (both PD and ND supported); corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`. Sourced from Hecke.jl source `src/QuadForm/Lattices.jl` (2026-02-19)."})
serena.replace_content({"mode":"literal","needle":"- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \"Given a definite lattice `L`\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.","relative_path":"docs/TODO.md","repl":"- [x] Fix `automorphism_group_generators` and `automorphism_group_order` definiteness constraint: tags were `[PD]` (positive definite only) but upstream OSCAR/Hecke docs explicitly state \"Given a definite lattice `L`\" — negative definite lattices are also supported; only indefinite lattices are excluded; corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`; also added `ambient_representation::Bool=true` kwarg to `automorphism_group_generators` signature. Sourced from `https://docs.oscar-system.org/stable/Hecke/manual/quad_forms/integer_lattices/`.\n\n- [x] Fix `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)` definiteness constraint: tags were `[PD]` but upstream Hecke source code (Lattices.jl) shows the implementation uses LLL to rescale negative definite to positive definite before comparison, explicitly requiring `is_definite(L)` (both PD and ND supported); corrected to `[DEFINITE]` across `julia_lattice_methods_reference.md`, `nemo_hecke_lattice_reference.md`, and `julia_methods_checklist.md`. Sourced from Hecke.jl source `src/QuadForm/Lattices.jl` (2026-02-19)."}) success in 139ms:
{
  "content": [
    {
      "type": "text",
      "text": "OK"
    }
  ],
  "structuredContent": {
    "result": "OK"
  },
  "isError": false
}
thinking
Now let me write the continuity memory and commit the changes.
Plan update
Writing continuity memory and committing changes
  ✓ Verify is_isometric definiteness constraint in source
  ✓ Fix Julia lattice reference: is_isometric [PD] -> [DEFINITE]
  ✓ Fix Hecke lattice reference: is_isometric [PD] -> [DEFINITE]
  ✓ Fix Julia methods checklist: is_isometric [PD] -> [DEFINITE]
  ✓ Update TODO.md with completed item
  → Write continuity memory and commit
thinking
Now I need to write the continuity memory and commit. Let me check what files were changed.
exec
/bin/bash -lc 'cd /home/dzack/lattice_interface && git diff --stat docs/' in /home/dzack/lattice_interface succeeded in 51ms:
 docs/TODO.md                                                   | 2 ++
 docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md    | 4 ++--
 docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md | 4 ++--
 docs/julia_methods_checklist.md                                | 3 ++-
 4 files changed, 8 insertions(+), 5 deletions(-)
thinking
The changes are as expected. Let me commit them now.
exec
/bin/bash -lc 'cd /home/dzack/lattice_interface && git add docs/TODO.md docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md docs/julia_methods_checklist.md && git commit -m "docs: correct is_isometric definiteness constraint from [PD] to [DEFINITE]

Fixes contract-fidelity error in Julia lattice isometry methods.
Previous documentation tagged is_isometric(L1, L2) and is_isometric_with_isometry
as [PD] (positive definite only), but upstream Hecke source code shows the
implementation uses LLL to rescale negative definite to positive definite
before comparison. The upstream requirement is is_definite(L), supporting
both PD and ND lattices.

Sourced from Hecke.jl src/QuadForm/Lattices.jl (2026-02-19)."' in /home/dzack/lattice_interface succeeded in 51ms:
[main fc23d1b] docs: correct is_isometric definiteness constraint from [PD] to [DEFINITE]
 4 files changed, 8 insertions(+), 5 deletions(-)
thinking
Now let me write a continuity memory for this work, then push the commit.
tool serena.write_memory({"content":"# Doc Coverage Audit Handoff (2026-02-19): `is_isometric` / `is_isometric_with_isometry` definiteness constraint\n\n## FIRST GOAL (cursory package-surface maintenance)\n- Brief in-scope package-surface maintenance check completed; no new bilinear-form lattice package surface gap identified requiring a new checklist.\n\n## SECOND GOAL (active phase focus)\n- Corrected source-backed contract-fidelity error in Julia lattice isometry test methods.\n- Previous documentation tagged `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)` as `[PD]` (positive definite only).\n- Source verification via Hecke.jl source code (`src/QuadForm/Lattices.jl`) shows:\n  - Implementation explicitly rescales ND to PD: `if ZgramL[1][1, 1] < 0: ZgramL[1] = -ZgramL[1]`\n  - Upstream requirement is `is_definite(L)`, supporting both positive and negative definite lattices\n  - Only indefinite lattices are excluded from isometry testing\n\n## Completed edits\n\n1. `docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md` (§2.8)\n   - Changed `[PD]` → `[DEFINITE]` for both `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)`\n   - Added explicit description: \"upstream requires `is_definite(L1)` and `is_definite(L2)` (positive or negative definite); uses LLL to rescale ND to PD before comparison\"\n\n2. `docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md` (§2.7)\n   - Changed `[PD, NT]` → `[DEFINITE, NT]` for both methods\n   - Added same explicit description as above\n\n3. `docs/julia_methods_checklist.md` (§2.8)\n   - Added caveat to both `is_isometric` entries documenting the definiteness requirement\n   - Clarified that LLL rescaling handles ND lattices\n\n4. `docs/TODO.md`\n   - Added and checked off Goal 2 contract-fidelity item for this pass\n\n## Source evidence\n- Hecke.jl source: `src/QuadForm/Lattices.jl`\n  - `is_isometric` docstring: no explicit definiteness constraint stated in docs\n  - Implementation: rescaling logic `if ZgramL[1][1, 1] < 0` confirms ND support\n  - Upstream `automorphism_group_generators` / `automorphism_group_order` explicitly state \"Given a definite lattice L\"\n\n## Commit\n- `fc23d1b` — docs: correct is_isometric definiteness constraint from [PD] to [DEFINITE]\n\n## Validation\n- Documentation-only pass; no runtime tests executed.\n\n## Intentional non-edits\n- Did not modify unrelated pre-existing dirty files:\n  - `README.md`, `docs/documentation_coverage_audit_playbook.md`, `prompt.md`, `scripts/doc_coverage_scheduler.py`\n  - untracked `.serena/`, `scripts/__pycache__/`, `agent_runner/` logs\n\n## Pattern note (for future workers)\nThis is the **third** instance of the same `[PD]` vs `[DEFINITE]` error pattern in this project:\n- Pass 1: Sage `IntegralLattice.orthogonal_group` — `[PD]` → `[DEFINITE]`\n- Pass 2: Julia/OSCAR `automorphism_group_generators` / `automorphism_group_order` — `[PD]` → `[DEFINITE]`\n- Pass 3 (this pass): Julia/OSCAR `is_isometric` / `is_isometric_with_isometry` — `[PD]` → `[DEFINITE]`\n\nContinue checking other `[PD]`-tagged methods where upstream may actually say \"definite\" (not \"positive definite\"). The definitive source is checking the actual implementation code in Hecke.jl / SageMath source.\n\n## Remaining high-impact gaps\n1. Continue Goal 2 contract-fidelity tightening for other `[PD]`-tagged methods that may actually support negative definite lattices.\n2. Missing local doc copies still open in TODO.md (flint, gap, ntl, fpylll, forms, g6k, crystallographic_stack, pari_gp).\n3. Many unchecked method entries in Julia checklist (§2.3, §2.4, §2.9, §2.14).\n","memory_file_name":"doc_coverage_audit_2026-02-19_is_isometric_definiteness_contract_fidelity"})
serena.write_memory({"content":"# Doc Coverage Audit Handoff (2026-02-19): `is_isometric` / `is_isometric_with_isometry` definiteness constraint\n\n## FIRST GOAL (cursory package-surface maintenance)\n- Brief in-scope package-surface maintenance check completed; no new bilinear-form lattice package surface gap identified requiring a new checklist.\n\n## SECOND GOAL (active phase focus)\n- Corrected source-backed contract-fidelity error in Julia lattice isometry test methods.\n- Previous documentation tagged `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)` as `[PD]` (positive definite only).\n- Source verification via Hecke.jl source code (`src/QuadForm/Lattices.jl`) shows:\n  - Implementation explicitly rescales ND to PD: `if ZgramL[1][1, 1] < 0: ZgramL[1] = -ZgramL[1]`\n  - Upstream requirement is `is_definite(L)`, supporting both positive and negative definite lattices\n  - Only indefinite lattices are excluded from isometry testing\n\n## Completed edits\n\n1. `docs/julia/oscar_jl/lattice/julia_lattice_methods_reference.md` (§2.8)\n   - Changed `[PD]` → `[DEFINITE]` for both `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)`\n   - Added explicit description: \"upstream requires `is_definite(L1)` and `is_definite(L2)` (positive or negative definite); uses LLL to rescale ND to PD before comparison\"\n\n2. `docs/julia/hecke_jl/lattice/nemo_hecke_lattice_reference.md` (§2.7)\n   - Changed `[PD, NT]` → `[DEFINITE, NT]` for both methods\n   - Added same explicit description as above\n\n3. `docs/julia_methods_checklist.md` (§2.8)\n   - Added caveat to both `is_isometric` entries documenting the definiteness requirement\n   - Clarified that LLL rescaling handles ND lattices\n\n4. `docs/TODO.md`\n   - Added and checked off Goal 2 contract-fidelity item for this pass\n\n## Source evidence\n- Hecke.jl source: `src/QuadForm/Lattices.jl`\n  - `is_isometric` docstring: no explicit definiteness constraint stated in docs\n  - Implementation: rescaling logic `if ZgramL[1][1, 1] < 0` confirms ND support\n  - Upstream `automorphism_group_generators` / `automorphism_group_order` explicitly state \"Given a definite lattice L\"\n\n## Commit\n- `fc23d1b` — docs: correct is_isometric definiteness constraint from [PD] to [DEFINITE]\n\n## Validation\n- Documentation-only pass; no runtime tests executed.\n\n## Intentional non-edits\n- Did not modify unrelated pre-existing dirty files:\n  - `README.md`, `docs/documentation_coverage_audit_playbook.md`, `prompt.md`, `scripts/doc_coverage_scheduler.py`\n  - untracked `.serena/`, `scripts/__pycache__/`, `agent_runner/` logs\n\n## Pattern note (for future workers)\nThis is the **third** instance of the same `[PD]` vs `[DEFINITE]` error pattern in this project:\n- Pass 1: Sage `IntegralLattice.orthogonal_group` — `[PD]` → `[DEFINITE]`\n- Pass 2: Julia/OSCAR `automorphism_group_generators` / `automorphism_group_order` — `[PD]` → `[DEFINITE]`\n- Pass 3 (this pass): Julia/OSCAR `is_isometric` / `is_isometric_with_isometry` — `[PD]` → `[DEFINITE]`\n\nContinue checking other `[PD]`-tagged methods where upstream may actually say \"definite\" (not \"positive definite\"). The definitive source is checking the actual implementation code in Hecke.jl / SageMath source.\n\n## Remaining high-impact gaps\n1. Continue Goal 2 contract-fidelity tightening for other `[PD]`-tagged methods that may actually support negative definite lattices.\n2. Missing local doc copies still open in TODO.md (flint, gap, ntl, fpylll, forms, g6k, crystallographic_stack, pari_gp).\n3. Many unchecked method entries in Julia checklist (§2.3, §2.4, §2.9, §2.14).\n","memory_file_name":"doc_coverage_audit_2026-02-19_is_isometric_definiteness_contract_fidelity"}) success in 73ms:
{
  "content": [
    {
      "type": "text",
      "text": "Memory doc_coverage_audit_2026-02-19_is_isometric_definiteness_contract_fidelity written."
    }
  ],
  "structuredContent": {
    "result": "Memory doc_coverage_audit_2026-02-19_is_isometric_definiteness_contract_fidelity written."
  },
  "isError": false
}
thinking
Now let me update the plan to mark all tasks as completed.
Plan update
Completed all documentation corrections for is_isometric definiteness constraint
  ✓ Verify is_isometric definiteness constraint in source
  ✓ Fix Julia lattice reference: is_isometric [PD] -> [DEFINITE]
  ✓ Fix Hecke lattice reference: is_isometric [PD] -> [DEFINITE]
  ✓ Fix Julia methods checklist: is_isometric [PD] -> [DEFINITE]
  ✓ Update TODO.md with completed item
  ✓ Write continuity memory and commit
thinking
Let me verify what was done and provide a final summary:

1. FIRST GOAL: Checked for missing in-scope package surfaces - no new bilinear-form lattice package gap identified.

2. SECOND GOAL (active phase focus): 
   - Found that `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)` were incorrectly tagged as `[PD]` (positive definite only)
   - Verified through source code that these methods actually support both positive and negative definite lattices
   - The implementation in Hecke.jl explicitly rescaling ND to PD before comparison confirms this
   - Fixed the tags to `[DEFINITE]` across three files

3. TODO.md: Added completed item

4. Commit made

5. Continuity memory written

This completes the task. Now I need to provide the final output as specified: 2-3 plain sentences.
codex
The `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)` methods were incorrectly tagged as `[PD]` (positive definite only) in the Julia lattice references, but source verification in Hecke.jl shows the implementation explicitly rescales negative definite lattices to positive definite before comparison—meaning both PD and ND (definite) lattices are supported. This has been corrected to `[DEFINITE]` across the Julia lattice methods reference, Hecke mirror reference, and the checklist, with appropriate caveats added documenting the upstream requirement.
tokens used
127,654
The `is_isometric(L1, L2)` and `is_isometric_with_isometry(L1, L2)` methods were incorrectly tagged as `[PD]` (positive definite only) in the Julia lattice references, but source verification in Hecke.jl shows the implementation explicitly rescales negative definite lattices to positive definite before comparison—meaning both PD and ND (definite) lattices are supported. This has been corrected to `[DEFINITE]` across the Julia lattice methods reference, Hecke mirror reference, and the checklist, with appropriate caveats added documenting the upstream requirement.

[0m
> code Â· minimax/minimax-m2.5:free
[0m
[0mâ†’ [0mRead agents/doc_coverage/playbook.md
[0mâœ± [0mGlob "agents/doc_coverage/example_tasks/*.md"[90m 7 matches[0m
[0mâ†’ [0mRead agents/doc_coverage/example_tasks/mathematical_contract_audit.md
[0mâœ± [0mGlob "docs/**/*.md"[90m 100 matches[0m
[0mâ†’ [0mRead docs/TODO.md
Let me examine the PARI/GP reference doc since it has upstream provenance tracked and seems ready for contract auditing.
[0mâ†’ [0mRead docs/pari_gp/lattice/pari_gp_lattice_reference.md
[0mâ†’ [0mRead docs/fpylll/lattice/fpylll_lattice_reference.md
[0mâœ± [0mGlob "docs/fpylll/upstream/*"[90m 2 matches[0m
[0mâ†’ [0mRead docs/fpylll/upstream/README.rst
[0mâ†’ [0mRead docs/gap/lattice/gap_lattice_methods_reference.md
Let me examine the GAP lattice reference doc for contract gaps.
[0mâ†’ [0mRead docs/gap_methods_checklist.md
[0mâ†’ [0mRead docs/flint/lattice/flint_lattice_reference.md
[0mâ†’ [0mRead docs/sage/lattice/sagemath_lattice_reference.md
[0mâ†’ [0mRead docs/flatter/lattice/flatter_lattice_reference.md
[0mâœ± [0mGlob "docs/ntl/**/*.md"[90m 1 match[0m
[0mâ†’ [0mRead docs/ntl/lattice/ntl_lattice_reference.md
[0mâœ± [0mGlob "docs/ntl/upstream/*"[90m 4 matches[0m
[0mâ†’ [0mRead docs/ntl/upstream/LLL.cpp.html[90m [limit=200][0m
Let me check the NTL upstream doc to verify the signature and constraints.
[0mâ†’ [0mRead docs/sage/genus/sage_genus_reference.md
Let me search for any gaps systematically. Let me check the Sage genus reference for missing contract details.
[0mâ†’ [0mRead docs/julia/oscar_jl/number_theory/quad_form_and_isom/torquadmodwithisom.md
[0mâ†’ [0mRead docs/pari_gp/lattice/pari_gp_lattice_reference.md[90m [limit=50, offset=30][0m
[0mâœ± [0mGlob "docs/pari_gp/upstream/*"[90m 5 matches[0m
[0mâœ± [0mGrep "qfperfection"[90m in docs/pari_gp/upstream Â· 7 matches[0m
[0mâ†’ [0mRead docs/pari_gp/upstream/vectors_matrices_linear_algebra.html[90m [limit=30, offset=2590][0m
[0mâ†’ [0mRead docs/pari_gp/lattice/pari_gp_lattice_reference.md[90m [limit=10, offset=78][0m
[0m
[0mâ† [0mEdit docs/pari_gp/lattice/pari_gp_lattice_reference.md
Index: /mnt/extra/lattice_interface/docs/pari_gp/lattice/pari_gp_lattice_reference.md
===================================================================
--- /mnt/extra/lattice_interface/docs/pari_gp/lattice/pari_gp_lattice_reference.md
+++ /mnt/extra/lattice_interface/docs/pari_gp/lattice/pari_gp_lattice_reference.md
@@ -79,9 +79,9 @@
 
 | Function | Argument Types | Return Type | Description | Tags |
 |----------|----------------|-------------|-------------|------|
 | `qfgaussred(q, {flag = 0})` | `q`: integer (binary form discriminant) or integer matrix; `flag`: integer (optional) | vector | Gauss reduction of binary quadratic forms | `[NT]` |
-| `qfperfection(G)` | `G`: symmetric integer matrix | vector | Perfection/perfect-form style analysis (currently rank 8 only in upstream docs) | `[NT]` |
+| `qfperfection(G)` | `G`: symmetric integer matrix | vector | Perfection/perfect-form style analysis; **requires positive-definite form** per upstream docs; currently rank 8 only | `[PD, NT]` |
 
 ---
 
 ## 6. Indefinite-First Usage Guidance

[0m
I found a contract gap. The `qfperfection` function in the PARI/GP reference doc is missing the `[PD]` tag. The upstream documentation explicitly states it requires a "positive definite quadratic form" but the reference doc doesn't tag it. Let me fix this.
[0mâœ± [0mGrep "qfgaussred"[90m in docs/pari_gp/upstream Â· 13 matches[0m
[0mâ†’ [0mRead docs/pari_gp/upstream/vectors_matrices_linear_algebra.html[90m [limit=60, offset=2114][0m
[0m
[0m$ [0mgit diff
diff --git a/agent_runner/logs/agent_management/claude/agent.log b/agent_runner/logs/agent_management/claude/agent.log
index eb84056..efcd2bd 100644
--- a/agent_runner/logs/agent_management/claude/agent.log
+++ b/agent_runner/logs/agent_management/claude/agent.log
@@ -8,3 +8,8 @@ last_message: The behavioral failure was shirking: the ollama/minimax agent at 0
 2026-02-19 19:40:03 UTC [claude/agent_management] elapsed=9m08s tokens=n/a files=3 loc=+5/-3
 last_message: The behavioral failure was that doc_coverage worker agents (kilo at 18:50, opencode at 19:39) concluded "no gaps requiring immediate fixes were found" after broad verification scans â€” one produced no commit, the other pivoted to management work outside its scope. The structural cause was that the doc_coverage prompt framed Goal 2 as "find a gap, fix it," which agents satisfied by concluding they had looked and found none; the phrase "no gaps requiring immediate fixes" provided an implicit severity escape hatch that the prompt did not prohibit. The fixes add explicit statements that gaps always exist, ban "no gaps found" conclusions, prohibit pivoting to management work, make a no-commit run a failure regardless of verification effort, and require the output format to name a specific gap â€” runners who cannot do so have failed.
 
+
+=== 2026-02-19 20:40:03 UTC [claude/agent_management] ===
+2026-02-19 20:40:03 UTC [claude/agent_management] elapsed=7m17s tokens=n/a files=3 loc=+36/-2
+last_message: Doc_coverage agents repeatedly edited `agents/` files despite a nominal prohibition because the prior constraint was conditional ("when no documentation gap is obvious"), giving agents a rationalization path whenever they perceived a management gap; the fix replaces this with an absolute scope boundary ("your edits are limited to `docs/`â€”never modify files under `agents/`"), removing the conditional entirely. Separately, the management agent prompt incorrectly directed agents to find playbooks at `docs/*_playbook.md` (they are at `agents/*/playbook.md`), a factual error that could cause management agents to fail to locate the files they need to audit. Both changes were committed.
+
diff --git a/agent_runner/logs/agent_management/task.log b/agent_runner/logs/agent_management/task.log
index eb84056..efcd2bd 100644
--- a/agent_runner/logs/agent_management/task.log
+++ b/agent_runner/logs/agent_management/task.log
@@ -8,3 +8,8 @@ last_message: The behavioral failure was shirking: the ollama/minimax agent at 0
 2026-02-19 19:40:03 UTC [claude/agent_management] elapsed=9m08s tokens=n/a files=3 loc=+5/-3
 last_message: The behavioral failure was that doc_coverage worker agents (kilo at 18:50, opencode at 19:39) concluded "no gaps requiring immediate fixes were found" after broad verification scans â€” one produced no commit, the other pivoted to management work outside its scope. The structural cause was that the doc_coverage prompt framed Goal 2 as "find a gap, fix it," which agents satisfied by concluding they had looked and found none; the phrase "no gaps requiring immediate fixes" provided an implicit severity escape hatch that the prompt did not prohibit. The fixes add explicit statements that gaps always exist, ban "no gaps found" conclusions, prohibit pivoting to management work, make a no-commit run a failure regardless of verification effort, and require the output format to name a specific gap â€” runners who cannot do so have failed.
 
+
+=== 2026-02-19 20:40:03 UTC [claude/agent_management] ===
+2026-02-19 20:40:03 UTC [claude/agent_management] elapsed=7m17s tokens=n/a files=3 loc=+36/-2
+last_message: Doc_coverage agents repeatedly edited `agents/` files despite a nominal prohibition because the prior constraint was conditional ("when no documentation gap is obvious"), giving agents a rationalization path whenever they perceived a management gap; the fix replaces this with an absolute scope boundary ("your edits are limited to `docs/`â€”never modify files under `agents/`"), removing the conditional entirely. Separately, the management agent prompt incorrectly directed agents to find playbooks at `docs/*_playbook.md` (they are at `agents/*/playbook.md`), a factual error that could cause management agents to fail to locate the files they need to audit. Both changes were committed.
+
diff --git a/agent_runner/logs/document_coverage/kilo/agent.log b/agent_runner/logs/document_coverage/kilo/agent.log
index 393978b..37df206 100644
--- a/agent_runner/logs/document_coverage/kilo/agent.log
+++ b/agent_runner/logs/document_coverage/kilo/agent.log
@@ -53,3 +53,8 @@ last_message: The missing `discriminant()` method on `IntegralLattice` was undoc
 2026-02-19 20:20:03 UTC [kilo/document_coverage] elapsed=12m54s tokens=n/a files=1 loc=+2/-1
 last_message: I found and fixed a contract gap in the PARI/GP reference documentation. The `qfcholesky` function was incorrectly tagged as `[PD]` (positive-definite) in the reference doc, but the upstream PARI documentation only states "Given a square symmetric matrix M" without explicitly requiring positive-definiteness. This differs from other PARI functions like `qfisom`, `qfauto`, `qfisominit`, and `qfcvp` which explicitly state "positive definite quadratic form" in their documentation. I removed the unsupported `[PD]` tag and clarified that Cholesky decomposition mathematically succeeds only for positive (semi)definite matrices, added a source citation, and committed the fix.
 
+
+=== 2026-02-19 20:50:04 UTC [kilo/document_coverage] ===
+2026-02-19 20:50:04 UTC [kilo/document_coverage] elapsed=4m36s tokens=n/a files=1 loc=+22/-13
+last_message: The NTL reference doc was missing the `long` return type from all LLL/BKZ/LLL_plus/image method signatures - these methods return the rank `r` of the matrix, which is critical contract information for callers. Additionally, the `ComputeGS` and `NearVector` utility functions were completely absent from the reference despite existing in upstream. These gaps are now fixed with full signatures and source citations.
+
diff --git a/agent_runner/logs/document_coverage/task.log b/agent_runner/logs/document_coverage/task.log
index 64f4cf5..e4e865b 100644
--- a/agent_runner/logs/document_coverage/task.log
+++ b/agent_runner/logs/document_coverage/task.log
@@ -161,3 +161,8 @@ last_message: {"type":"result","subtype":"success","uuid":"0aa8456d-eb72-4abd-83
 2026-02-19 20:20:03 UTC [kilo/document_coverage] elapsed=12m54s tokens=n/a files=1 loc=+2/-1
 last_message: I found and fixed a contract gap in the PARI/GP reference documentation. The `qfcholesky` function was incorrectly tagged as `[PD]` (positive-definite) in the reference doc, but the upstream PARI documentation only states "Given a square symmetric matrix M" without explicitly requiring positive-definiteness. This differs from other PARI functions like `qfisom`, `qfauto`, `qfisominit`, and `qfcvp` which explicitly state "positive definite quadratic form" in their documentation. I removed the unsupported `[PD]` tag and clarified that Cholesky decomposition mathematically succeeds only for positive (semi)definite matrices, added a source citation, and committed the fix.
 
+
+=== 2026-02-19 20:50:04 UTC [kilo/document_coverage] ===
+2026-02-19 20:50:04 UTC [kilo/document_coverage] elapsed=4m36s tokens=n/a files=1 loc=+22/-13
+last_message: The NTL reference doc was missing the `long` return type from all LLL/BKZ/LLL_plus/image method signatures - these methods return the rank `r` of the matrix, which is critical contract information for callers. Additionally, the `ComputeGS` and `NearVector` utility functions were completely absent from the reference despite existing in upstream. These gaps are now fixed with full signatures and source citations.
+
diff --git a/agent_runner/logs/heartbeat/task.log b/agent_runner/logs/heartbeat/task.log
index 29cbe60..029b6a1 100644
--- a/agent_runner/logs/heartbeat/task.log
+++ b/agent_runner/logs/heartbeat/task.log
@@ -1134,3 +1134,50 @@
 2026-02-19 20:36:01 UTC
 2026-02-19 20:37:02 UTC
 2026-02-19 20:38:02 UTC
+2026-02-19 20:39:01 UTC
+2026-02-19 20:40:03 UTC
+2026-02-19 20:41:02 UTC
+2026-02-19 20:42:01 UTC
+2026-02-19 20:43:02 UTC
+2026-02-19 20:44:01 UTC
+2026-02-19 20:45:03 UTC
+2026-02-19 20:46:04 UTC
+2026-02-19 20:47:02 UTC
+2026-02-19 20:48:02 UTC
+2026-02-19 20:49:02 UTC
+2026-02-19 20:50:04 UTC
+2026-02-19 20:51:03 UTC
+2026-02-19 20:52:02 UTC
+2026-02-19 20:53:03 UTC
+2026-02-19 20:54:02 UTC
+2026-02-19 20:55:03 UTC
+2026-02-19 20:56:02 UTC
+2026-02-19 20:57:02 UTC
+2026-02-19 20:58:02 UTC
+2026-02-19 20:59:02 UTC
+2026-02-19 21:00:03 UTC
+2026-02-19 21:01:02 UTC
+2026-02-19 21:02:02 UTC
+2026-02-19 21:03:02 UTC
+2026-02-19 21:04:02 UTC
+2026-02-19 21:05:02 UTC
+2026-02-19 21:06:02 UTC
+2026-02-19 21:07:02 UTC
+2026-02-19 21:08:02 UTC
+2026-02-19 21:09:01 UTC
+2026-02-19 21:10:03 UTC
+2026-02-19 21:11:02 UTC
+2026-02-19 21:12:03 UTC
+2026-02-19 21:13:03 UTC
+2026-02-19 21:14:02 UTC
+2026-02-19 21:15:02 UTC
+2026-02-19 21:16:01 UTC
+2026-02-19 21:17:03 UTC
+2026-02-19 21:18:01 UTC
+2026-02-19 21:19:02 UTC
+2026-02-19 21:20:04 UTC
+2026-02-19 21:21:04 UTC
+2026-02-19 21:22:02 UTC
+2026-02-19 21:23:03 UTC
+2026-02-19 21:24:03 UTC
+2026-02-19 21:25:02 UTC
diff --git a/agent_runner/src/agent_runner/agents.py b/agent_runner/src/agent_runner/agents.py
index ff8b0a1..dfc5497 100644
--- a/agent_runner/src/agent_runner/agents.py
+++ b/agent_runner/src/agent_runner/agents.py
@@ -14,7 +14,12 @@ from pydantic import BaseModel, ConfigDict
 
 from . import config
 from .agent_errors import classify_usage_limit
-from .errors import AgentMetadataError, AgentTimeoutError, RateLimitUsageError
+from .errors import (
+    AgentConnectivityError,
+    AgentMetadataError,
+    AgentTimeoutError,
+    RateLimitUsageError,
+)
 from .tasks import AgentTask
 
 TIMEOUT_SECONDS = int(os.environ.get("AGENT_RUNNER_TIMEOUT_SECONDS", "900"))  # 15 minutes default
@@ -47,17 +52,40 @@ class AgentInterface(BaseModel, ABC):
     subcommand: str | None
     base_args: list[str]
     env: Mapping[str, str]
+    quality: int
 
-    def run_task(self, task: AgentTask, run_ctx: RunContext) -> ProcessResult:
-        result = self._run_with_prompt(task.prompt_text(), task, run_ctx)
+    def run_task(
+        self, task: AgentTask, run_ctx: RunContext, timeout_seconds: int = TIMEOUT_SECONDS
+    ) -> ProcessResult:
+        result = self._run_with_prompt(task.prompt_text(), task, run_ctx, timeout_seconds)
         classified = classify_usage_limit(self.name, result.stdout)
         if classified:
             raise RateLimitUsageError(self.name, classified.message)
         return result
 
+    def check_connectivity(self, run_ctx: RunContext) -> None:
+        hello_task = AgentTask(
+            name="preflight_hello",
+            task_key="preflight_hello",
+            prompt_path=config.settings.debug_prompts()["smoke"],
+            requires_commit=False,
+        )
+        result = self._run_with_prompt(
+            hello_task.prompt_text(), hello_task, run_ctx, timeout_seconds=30
+        )
+        classified = classify_usage_limit(self.name, result.stdout)
+        if classified:
+            raise AgentConnectivityError(self.name, classified.message)
+        if result.exit_code != 0:
+            raise AgentConnectivityError(self.name, f"exit code {result.exit_code}")
+
     @abstractmethod
     def _run_with_prompt(
-        self, prompt_string: str, task: AgentTask, run_ctx: RunContext
+        self,
+        prompt_string: str,
+        task: AgentTask,
+        run_ctx: RunContext,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         raise NotImplementedError
 
@@ -70,6 +98,7 @@ class AgentInterface(BaseModel, ABC):
         prompt_string: str,
         run_ctx: RunContext,
         cwd: Path | None = None,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         env = {**os.environ, **self._build_env()}
         final_args = [self.binary, *args, prompt_string]
@@ -104,7 +133,7 @@ class AgentInterface(BaseModel, ABC):
 
             reader_thread = threading.Thread(target=read_output)
             reader_thread.start()
-            reader_thread.join(timeout=TIMEOUT_SECONDS)
+            reader_thread.join(timeout=timeout_seconds)
 
             if reader_thread.is_alive():
                 timed_out = True
@@ -115,7 +144,7 @@ class AgentInterface(BaseModel, ABC):
                     reader_thread.join(timeout=2)
 
         if timed_out:
-            raise AgentTimeoutError(self.name, run_ctx.task_name, TIMEOUT_SECONDS)
+            raise AgentTimeoutError(self.name, run_ctx.task_name, timeout_seconds)
 
         # Invariant: only reachable when the process completed within TIMEOUT_SECONDS.
         # A timed-out process always raises above; proc.wait() is never called on a killed process.
@@ -126,8 +155,14 @@ class AgentInterface(BaseModel, ABC):
 
 
 class CodexAgent(AgentInterface):
+    quality: int = 90
+
     def _run_with_prompt(
-        self, prompt_string: str, task: AgentTask, run_ctx: RunContext
+        self,
+        prompt_string: str,
+        task: AgentTask,
+        run_ctx: RunContext,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         last_message = run_ctx.run_dir / "last_message.txt"
         args = [
@@ -150,7 +185,9 @@ class CodexAgent(AgentInterface):
             if retcode != 0:
                 msg = "MCP server 'serena' not configured for codex"
                 raise AgentMetadataError(msg)
-        result = self._run_command(args=args, prompt_string=prompt_string, run_ctx=run_ctx)
+        result = self._run_command(
+            args=args, prompt_string=prompt_string, run_ctx=run_ctx, timeout_seconds=timeout_seconds
+        )
         return ProcessResult(
             exit_code=result.exit_code,
             stdout=result.stdout,
@@ -159,11 +196,14 @@ class CodexAgent(AgentInterface):
 
 
 class ClaudeAgent(AgentInterface):
+    quality: int = 80
+
     def _run_with_prompt(
         self,
         prompt_string: str,
         task: AgentTask,  # noqa: ARG002
         run_ctx: RunContext,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         args = [
             "-p",
@@ -179,15 +219,19 @@ class ClaudeAgent(AgentInterface):
             prompt_string=prompt_string,
             run_ctx=run_ctx,
             cwd=config.settings.repo_root,
+            timeout_seconds=timeout_seconds,
         )
 
 
 class GeminiAgent(AgentInterface):
+    quality: int = 40
+
     def _run_with_prompt(
         self,
         prompt_string: str,
         task: AgentTask,  # noqa: ARG002
         run_ctx: RunContext,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         args = [
             "--model",
@@ -196,15 +240,20 @@ class GeminiAgent(AgentInterface):
             "json",
             "--prompt",
         ]
-        return self._run_command(args=args, prompt_string=prompt_string, run_ctx=run_ctx)
+        return self._run_command(
+            args=args, prompt_string=prompt_string, run_ctx=run_ctx, timeout_seconds=timeout_seconds
+        )
 
 
 class OllamaAgent(AgentInterface):
+    quality: int = 50
+
     def _run_with_prompt(
         self,
         prompt_string: str,
         task: AgentTask,  # noqa: ARG002
         run_ctx: RunContext,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         model = os.environ.get("OLLAMA_MODEL", "minimax-m2.5:cloud")
         args = [
@@ -222,15 +271,19 @@ class OllamaAgent(AgentInterface):
             prompt_string=prompt_string,
             run_ctx=run_ctx,
             cwd=config.settings.repo_root,
+            timeout_seconds=timeout_seconds,
         )
 
 
 class KiloAgent(AgentInterface):
+    quality: int = 70
+
     def _run_with_prompt(
         self,
         prompt_string: str,
         task: AgentTask,  # noqa: ARG002
         run_ctx: RunContext,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         args = [
             "run",
@@ -243,15 +296,19 @@ class KiloAgent(AgentInterface):
             prompt_string=prompt_string,
             run_ctx=run_ctx,
             cwd=config.settings.repo_root,
+            timeout_seconds=timeout_seconds,
         )
 
 
 class OpencodeAgent(AgentInterface):
+    quality: int = 60
+
     def _run_with_prompt(
         self,
         prompt_string: str,
         task: AgentTask,  # noqa: ARG002
         run_ctx: RunContext,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         model = os.environ.get("OPENCODE_MODEL", "opencode/glm-5-free")
         args = [
@@ -264,15 +321,19 @@ class OpencodeAgent(AgentInterface):
             prompt_string=prompt_string,
             run_ctx=run_ctx,
             cwd=config.settings.repo_root,
+            timeout_seconds=timeout_seconds,
         )
 
 
 class QwenAgent(AgentInterface):
+    quality: int = 20
+
     def _run_with_prompt(
         self,
         prompt_string: str,
         task: AgentTask,  # noqa: ARG002
         run_ctx: RunContext,
+        timeout_seconds: int = TIMEOUT_SECONDS,
     ) -> ProcessResult:
         model = os.environ.get("QWEN_MODEL", "coder-model")
         args = [
@@ -287,4 +348,5 @@ class QwenAgent(AgentInterface):
             prompt_string=prompt_string,
             run_ctx=run_ctx,
             cwd=config.settings.repo_root,
+            timeout_seconds=timeout_seconds,
         )
diff --git a/agent_runner/src/agent_runner/errors.py b/agent_runner/src/agent_runner/errors.py
index 9041d05..bf1a5f6 100644
--- a/agent_runner/src/agent_runner/errors.py
+++ b/agent_runner/src/agent_runner/errors.py
@@ -40,3 +40,16 @@ class AgentTimeoutError(AgentRunnerError):
         self.agent = agent
         self.task = task
         self.timeout_seconds = timeout_seconds
+
+
+class AgentConnectivityError(AgentRunnerError):
+    def __init__(self, agent: str, detail: str) -> None:
+        super().__init__(f"Agent {agent} connectivity check failed: {detail}")
+        self.agent = agent
+        self.detail = detail
+
+
+class AgentSelectionError(AgentRunnerError):
+    def __init__(self, detail: str) -> None:
+        super().__init__(f"Auto agent selection failed: {detail}")
+        self.detail = detail
diff --git a/agent_runner/src/agent_runner/orchestrator.py b/agent_runner/src/agent_runner/orchestrator.py
index 5aa8b1c..cf9c721 100644
--- a/agent_runner/src/agent_runner/orchestrator.py
+++ b/agent_runner/src/agent_runner/orchestrator.py
@@ -10,6 +10,7 @@ from pydantic import BaseModel
 
 from . import config, git, transcript
 from .agents import (
+    AgentInterface,
     ClaudeAgent,
     CodexAgent,
     GeminiAgent,
@@ -22,8 +23,11 @@ from .agents import (
 from .agent_errors import classify_usage_limit
 from .errors import (
     AgentCommitMissingError,
+    AgentConnectivityError,
+    AgentMetadataError,
     AgentProcessError,
     AgentRunnerError,
+    AgentSelectionError,
     AgentTimeoutError,
     RateLimitUsageError,
 )
@@ -45,7 +49,8 @@ from .tasks import (
 
 app = typer.Typer(add_completion=False)
 
-AgentName = Literal["codex", "claude", "gemini", "kilo", "ollama", "opencode", "qwen"]
+ConcreteAgentName = Literal["codex", "claude", "gemini", "kilo", "ollama", "opencode", "qwen"]
+AgentName = Literal["codex", "claude", "gemini", "kilo", "ollama", "opencode", "qwen", "auto"]
 TaskName = Literal[
     "agent_management",
     "document_coverage",
@@ -70,13 +75,24 @@ class Orchestrator(BaseModel):
     def run(self) -> int:
         """Run an agent task with centralized logging."""
         task_obj = _build_task(self.args.task)
-        agent_obj = _build_agent(self.args.agent)
 
         now = datetime.now(timezone.utc)
         run_id = now.strftime("%Y%m%d_%H%M%S")
-        run_ctx = build_run_context(
-            agent_name=agent_obj.name, task_name=task_obj.name, run_id=run_id
-        )
+
+        connectivity_verified = False
+        if self.args.agent == "auto":
+            try:
+                agent_obj, run_ctx = _select_auto_agent(task_obj, run_id)
+            except AgentSelectionError as exc:
+                typer.echo(f"AgentSelectionError: {exc}", err=True)
+                return 13
+            connectivity_verified = True
+        else:
+            agent_obj = _build_agent(self.args.agent)
+            run_ctx = build_run_context(
+                agent_name=agent_obj.name, task_name=task_obj.name, run_id=run_id
+            )
+
         logger = get_logger(run_ctx)
 
         debug_prompt_path = None
@@ -102,6 +118,8 @@ class Orchestrator(BaseModel):
                 stdout = "(dry-run)"
                 exit_code = 0
             else:
+                if not connectivity_verified:
+                    agent_obj.check_connectivity(run_ctx)
                 proc_result = agent_obj.run_task(task_obj, run_ctx)
                 stdout = proc_result.stdout
                 exit_code = proc_result.exit_code
@@ -216,6 +234,23 @@ class Orchestrator(BaseModel):
                 "requires_commit": task_obj.requires_commit,
             }
             write_metadata(run_ctx.metadata_path, error_meta)
+        except AgentConnectivityError as exc:
+            end_time = datetime.now(timezone.utc)
+            exit_code = 12
+            error_type = "connectivity"
+            error_detail = str(exc)
+            logger.exception("Agent connectivity check failed")
+            typer.echo(f"AgentConnectivityError: {exc}", err=True)
+            error_meta = {
+                "run_id": run_ctx.run_id,
+                "agent": agent_obj.name,
+                "task": task_obj.name,
+                "exit_code": None,
+                "error": str(exc),
+                "classified_error": "connectivity",
+                "requires_commit": task_obj.requires_commit,
+            }
+            write_metadata(run_ctx.metadata_path, error_meta)
         except AgentTimeoutError as exc:
             end_time = datetime.now(timezone.utc)
             exit_code = 11
@@ -325,7 +360,52 @@ def _build_task(task_name: TaskName) -> AgentTask:
             assert_never(task_name)
 
 
-def _build_agent(agent_name: AgentName):
+def _all_agents() -> list[AgentInterface]:
+    env = {"PATH": f"{config.settings.path_prefix}:{os.environ.get('PATH', '')}"}
+    return [
+        ClaudeAgent(
+            name="claude", binary=config.settings.claude_bin, subcommand=None, base_args=[], env=env
+        ),
+        CodexAgent(
+            name="codex", binary=config.settings.codex_bin, subcommand="exec", base_args=[], env=env
+        ),
+        GeminiAgent(
+            name="gemini", binary=config.settings.gemini_bin, subcommand=None, base_args=[], env=env
+        ),
+        OllamaAgent(
+            name="ollama", binary=config.settings.ollama_bin, subcommand=None, base_args=[], env=env
+        ),
+        KiloAgent(
+            name="kilo", binary=config.settings.kilo_bin, subcommand=None, base_args=[], env=env
+        ),
+        OpencodeAgent(
+            name="opencode",
+            binary=config.settings.opencode_bin,
+            subcommand=None,
+            base_args=[],
+            env=env,
+        ),
+        QwenAgent(
+            name="qwen", binary=config.settings.qwen_bin, subcommand=None, base_args=[], env=env
+        ),
+    ]
+
+
+def _select_auto_agent(task_obj: AgentTask, run_id: str) -> tuple[AgentInterface, RunContext]:
+    candidates = sorted(_all_agents(), key=lambda a: a.quality, reverse=True)
+    last_exc: Exception | None = None
+    for agent in candidates:
+        run_ctx = build_run_context(agent_name=agent.name, task_name=task_obj.name, run_id=run_id)
+        try:
+            agent.check_connectivity(run_ctx)
+            return agent, run_ctx
+        except (AgentConnectivityError, AgentTimeoutError, AgentMetadataError) as exc:
+            last_exc = exc
+            continue
+    raise AgentSelectionError(str(last_exc) if last_exc else "no agents available")
+
+
+def _build_agent(agent_name: ConcreteAgentName):
     env = {"PATH": f"{config.settings.path_prefix}:{os.environ.get('PATH', '')}"}
     match agent_name:
         case "codex":
diff --git a/docs/pari_gp/lattice/pari_gp_lattice_reference.md b/docs/pari_gp/lattice/pari_gp_lattice_reference.md
index b60d811..a6aec3f 100644
--- a/docs/pari_gp/lattice/pari_gp_lattice_reference.md
+++ b/docs/pari_gp/lattice/pari_gp_lattice_reference.md
@@ -80,7 +80,7 @@ Use these for indefinite arithmetic problems where shortest-vector Euclidean wor
 | Function | Argument Types | Return Type | Description | Tags |
 |----------|----------------|-------------|-------------|------|
 | `qfgaussred(q, {flag = 0})` | `q`: integer (binary form discriminant) or integer matrix; `flag`: integer (optional) | vector | Gauss reduction of binary quadratic forms | `[NT]` |
-| `qfperfection(G)` | `G`: symmetric integer matrix | vector | Perfection/perfect-form style analysis (currently rank 8 only in upstream docs) | `[NT]` |
+| `qfperfection(G)` | `G`: symmetric integer matrix | vector | Perfection/perfect-form style analysis; **requires positive-definite form** per upstream docs; currently rank 8 only | `[PD, NT]` |
 
 ---
[0m
[0m$ [0mgit add docs/pari_gp/lattice/pari_gp_lattice_reference.md && git commit -m "docs: add [PD] tag to qfperfection - requires positive-definite form

Source: docs/pari_gp/upstream/vectors_matrices_linear_algebra.html
Lines 2595-2598 explicitly state 'positive definite quadratic form'"
[main 816f0a0] docs: add [PD] tag to qfperfection - requires positive-definite form
 1 file changed, 1 insertion(+), 1 deletion(-)
[0m
[0mâ†’ [0mRead docs/pari_gp/lattice/pari_gp_lattice_reference.md[90m [limit=20, offset=78][0m
The `qfperfection` function in the PARI/GP reference doc was missing the `[PD]` tag required for positive-definite forms. The upstream documentation explicitly states it operates on "positive definite quadratic form" (lines 2595-2598 of the local snapshot), yet the reference only noted the rank-8 limitation without tagging the definiteness constraint. This created an inconsistency with other PARI functions like `qfisom`, `qfauto`, and `qfisominit` that properly document their PD requirements. The fix adds the `[PD]` tag and explicit constraint language, sourced from the local upstream docs.

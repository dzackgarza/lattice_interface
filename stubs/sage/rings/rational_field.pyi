import sage.rings.number_field.number_field_base as number_field_base
from typing import Any, overload
from collections.abc import Generator
from sage.misc.fast_methods import Singleton
from sage.rings.integer import Integer
from sage.rings.rational import Rational
from sage.rings.infinity import PlusInfinity

ZZ: Integer

class RationalField(Singleton, number_field_base.NumberField):
    def __new__(cls) -> RationalField: ...
    def __init__(self) -> None: ...
    def __reduce__(self) -> tuple[type[RationalField], tuple[()]]: ...
    def __len__(self) -> int: ...
    def construction(self) -> tuple[Any, Any]: ...  # functor, parent
    def completion(self, p: Any, prec: int, extras: dict[str, Any] = {}) -> Any: ...
    def __iter__(self) -> Generator[Rational, None, None]: ...
    def __truediv__(self, I: Any) -> Any: ...
    def range_by_height(self, start: int, end: int | None = None) -> Generator[Rational, None, None]: ...
    def primes_of_bounded_norm_iter(self, B: int) -> Generator[Integer, None, None]: ...
    def discriminant(self) -> Integer: ...
    def absolute_discriminant(self) -> Integer: ...
    def relative_discriminant(self) -> Integer: ...
    def class_number(self) -> Integer: ...
    def signature(self) -> tuple[Integer, Integer]: ...
    def embeddings(self, K: Any) -> list[Any]: ...
    def automorphisms(self) -> Any: ... # Sequence
    def places(self, all_complex: bool = False, prec: int | None = None) -> list[Any]: ...
    def complex_embedding(self, prec: int = 53) -> Any: ...
    def residue_field(self, p: Any, check: bool = True) -> Any: ...
    def hilbert_symbol_negative_at_S(self, S: list[Any], b: Any, check: bool = True) -> Integer: ...
    def gens(self) -> tuple[Rational]: ...
    def gen(self, n: int = 0) -> Rational: ...
    def degree(self) -> Integer: ...
    def absolute_degree(self) -> Integer: ...
    def ngens(self) -> Integer: ...
    def is_absolute(self) -> bool: ...
    def is_prime_field(self) -> bool: ...
    def characteristic(self) -> Integer: ...
    def maximal_order(self) -> Any: ... # IntegerRing
    def number_field(self) -> RationalField: ...
    def power_basis(self) -> list[Rational]: ...
    def extension(self, poly: Any, names: Any, **kwds: Any) -> Any: ...
    def algebraic_closure(self) -> Any: ...
    def order(self) -> PlusInfinity: ...
    def polynomial(self) -> Any: ...
    defining_polynomial = polynomial
    absolute_polynomial = polynomial
    def some_elements(self) -> Generator[Rational, None, None]: ...
    def random_element(self, num_bound: int | None = None, den_bound: int | None = None, *args: Any, **kwds: Any) -> Rational: ...
    def zeta(self, n: int = 2) -> Rational: ...
    @overload
    def selmer_generators(self, S: Any, m: int, proof: bool = True, orders: bool = False) -> list[Any]: ...
    @overload
    def selmer_generators(self, S: Any, m: int, proof: bool = True, orders: bool = True) -> tuple[list[Any], list[Integer]]: ...
    def selmer_group_iterator(self, S: Any, m: int, proof: bool = True) -> Generator[Any, None, None]: ...
    def selmer_space(self, S: Any, p: Any, proof: Any = None) -> tuple[Any, list[Any], Any, Any]: ...
    def quadratic_defect(self, a: Any, p: Any, check: bool = True) -> Any: ...
    def valuation(self, p: Any) -> Any: ...

QQ: RationalField
Q = QQ

def is_RationalField(x: Any) -> bool: ...
def frac(n: Any, d: Any) -> Rational: ...

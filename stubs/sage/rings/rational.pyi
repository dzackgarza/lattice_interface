r"""
Rational Numbers
"""
from typing import Any, Optional, Union, List, Tuple, Dict
from sage.structure.element import FieldElement, Element
from sage.structure.parent import Parent
from sage.rings.integer import Integer
from sage.categories.map import Map
from sage.categories.morphism import Morphism

class Rational(FieldElement):
    def __init__(self, x: Any = None, base: int = 0) -> None: ...
    def _richcmp_(self, right: Any, op: int) -> Any: ...
    def _add_(self, right: Any) -> Rational: ...
    def _sub_(self, right: Any) -> Rational: ...
    def _neg_(self) -> Rational: ...
    def _mul_(self, right: Any) -> Rational: ...
    def _div_(self, right: Any) -> Rational: ...
    def _pow_(self, other: Any) -> Any: ...
    def __reduce__(self) -> Tuple[Any, Tuple[str]]: ...
    def __index__(self) -> int: ...
    def list(self) -> List[Rational]: ...
    def continued_fraction_list(self, type: str = 'std') -> List[Integer]: ...
    def continued_fraction(self) -> Any: ...
    def __copy__(self) -> Rational: ...
    def __deepcopy__(self, memo: Any) -> Rational: ...
    def __repr__(self) -> str: ...
    def _latex_(self) -> str: ...
    def _symbolic_(self, sring: Any) -> Any: ...
    def _sympy_(self) -> Any: ...
    def __mpz__(self) -> Any: ...
    def __mpq__(self) -> Any: ...
    def _magma_init_(self, magma: Any) -> str: ...
    def _regina_(self, regina: Any) -> Any: ...
    @property
    def __array_interface__(self) -> Any: ...
    def _mathml_(self) -> str: ...
    def _im_gens_(self, codomain: Parent, im_gens: Any, base_map: Any = None) -> Any: ...
    def content(self, other: Any) -> Rational: ...
    def valuation(self, p: Any) -> Union[Integer, float]: ...
    def ord(self, p: Any) -> Union[Integer, float]: ...
    def local_height(self, p: Any, prec: Any = None) -> Any: ...
    def local_height_arch(self, prec: Any = None) -> Any: ...
    def global_height_non_arch(self, prec: Any = None) -> Any: ...
    def global_height_arch(self, prec: Any = None) -> Any: ...
    def global_height(self, prec: Any = None) -> Any: ...
    def is_square(self) -> bool: ...
    def is_norm(self, L: Any, element: bool = False, proof: bool = True) -> Any: ...
    def is_perfect_power(self, expected_value: bool = False) -> bool: ...
    def squarefree_part(self) -> Any: ...
    def is_padic_square(self, p: Any, check: bool = True) -> bool: ...
    def val_unit(self, p: Any) -> Tuple[Union[Integer, float], Rational]: ...
    def prime_to_S_part(self, S: Any = ...) -> Rational: ...
    def sqrt(self, prec: Any = None, extend: bool = True, all: bool = False) -> Any: ...
    def period(self) -> Integer: ...
    def nth_root(self, n: int) -> Rational: ...
    def is_nth_power(self, n: int) -> bool: ...
    def str(self, base: int = 10) -> str: ...
    def __float__(self) -> float: ...
    def __hash__(self) -> int: ...
    def __getitem__(self, n: int) -> Rational: ...
    def __add__(self, right: Any) -> Any: ...
    def __sub__(self, right: Any) -> Any: ...
    def __mul__(self, right: Any) -> Any: ...
    def __truediv__(self, right: Any) -> Any: ...
    def __invert__(self) -> Rational: ...
    def __pos__(self) -> Rational: ...
    def __neg__(self) -> Rational: ...
    def __bool__(self) -> bool: ...
    def __abs__(self) -> Rational: ...
    def sign(self) -> Integer: ...
    def mod_ui(self, n: int) -> Integer: ...
    def __mod__(self, other: Any) -> Any: ...
    def norm(self) -> Rational: ...
    def relative_norm(self) -> Rational: ...
    def absolute_norm(self) -> Rational: ...
    def trace(self) -> Rational: ...
    def charpoly(self, var: str = 'x') -> Any: ...
    def minpoly(self, var: str = 'x') -> Any: ...
    def _integer_(self, Z: Any = None) -> Integer: ...
    def numerator(self) -> Integer: ...
    def numer(self) -> Integer: ...
    def __int__(self) -> int: ...
    def denominator(self) -> Integer: ...
    def denom(self) -> Integer: ...
    def as_integer_ratio(self) -> Tuple[Integer, Integer]: ...
    def factor(self) -> Any: ...
    def support(self) -> List[Integer]: ...
    def log(self, m: Any = None, prec: Any = None) -> Any: ...
    def gamma(self, prec: Any = None) -> Any: ...
    def floor(self) -> Integer: ...
    def ceil(self) -> Integer: ...
    def trunc(self) -> Integer: ...
    def round(self, mode: str = 'even') -> Integer: ...
    def real(self) -> Rational: ...
    def imag(self) -> Rational: ...
    def height(self) -> Integer: ...
    def additive_order(self) -> Any: ...
    def multiplicative_order(self) -> Any: ...
    def is_one(self) -> bool: ...
    def is_integral(self) -> bool: ...
    def is_integer(self) -> bool: ...
    def is_rational(self) -> bool: ...
    def is_S_integral(self, S: Any = ...) -> bool: ...
    def is_S_unit(self, S: Any = None) -> bool: ...
    def __lshift__(self, y: Any) -> Rational: ...
    def __rshift__(self, y: Any) -> Rational: ...
    def conjugate(self) -> Rational: ...
    def __pari__(self) -> Any: ...
    def _interface_init_(self, I: Any = None) -> str: ...
    def _sage_input_(self, sib: Any, coerced: Any) -> Any: ...

class Z_to_Q(Morphism):
    def __init__(self) -> None: ...
    def _call_(self, x: Any) -> Element: ...
    def section(self) -> Any: ...
    def is_surjective(self) -> bool: ...

class Q_to_Z(Map):
    def _call_(self, x: Any) -> Element: ...
    def section(self) -> Any: ...

class int_to_Q(Morphism):
    def __init__(self) -> None: ...
    def _call_(self, a: Any) -> Element: ...

def integer_rational_power(a: Integer, b: Rational) -> Optional[Integer]: ...
def rational_power_parts(a: Any, b: Rational, factor_limit: Any = None) -> Tuple[Any, Any]: ...
def is_Rational(x: Any) -> bool: ...
def make_rational(s: str) -> Rational: ...

from typing import Any, ClassVar, List, Optional, Tuple, Union, overload, Literal
from sage.structure.element import FieldElement, Element
from sage.categories.morphism import Morphism
from sage.rings.integer import Integer
from sage.rings.real_double import RealDoubleElement, RealDoubleField_class
import gmpy2

# Mock base class
ComplexDoubleFieldABC = Any

class ComplexDoubleField_class(ComplexDoubleFieldABC):
    precision: int
    prec: int

    def __init__(self) -> None: ...
    def is_exact(self) -> bool: ...
    def _coerce_map_from_(self, S: Any) -> Optional[Morphism]: ...
    def __reduce__(self) -> Tuple[Any, Tuple[Any]]: ...
    def __richcmp__(self, other: Any, op: int) -> Any: ...
    def __hash__(self) -> int: ...
    def characteristic(self) -> Integer: ...
    def random_element(self, xmin: float = -1, xmax: float = 1, ymin: float = -1, ymax: float = 1) -> ComplexDoubleElement: ...
    def _repr_(self) -> str: ...
    def _latex_(self) -> str: ...
    def __call__(self, x: Any = None, im: Any = None) -> ComplexDoubleElement: ...
    def _element_constructor_(self, x: Any) -> ComplexDoubleElement: ...
    def _magma_init_(self, magma: Any) -> str: ...
    def _fricas_init_(self) -> str: ...
    def to_prec(self, prec: int) -> Any: ... # Returns ComplexDoubleField or ComplexField
    def gen(self, n: int = 0) -> ComplexDoubleElement: ...
    def ngens(self) -> int: ...
    def algebraic_closure(self) -> ComplexDoubleField_class: ...
    def real_double_field(self) -> RealDoubleField_class: ...
    def pi(self) -> ComplexDoubleElement: ...
    def construction(self) -> Tuple[Any, Any]: ...
    def zeta(self, n: int = 2) -> ComplexDoubleElement: ...
    def _factor_univariate_polynomial(self, f: Any) -> Any: ...

class ComplexDoubleElement(FieldElement):
    __array_interface__: ClassVar[dict]
    real_part: Any # Method alias
    imag_part: Any # Method alias
    algdep: Any # Method alias

    def __init__(self, real: Any, imag: Any) -> None: ...
    def __reduce__(self) -> Tuple[Any, Tuple[float, float]]: ...
    def __hash__(self) -> int: ...
    def __getitem__(self, n: int) -> float: ...
    def _magma_init_(self, magma: Any) -> str: ...
    def prec(self) -> int: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __complex__(self) -> complex: ...
    def _interface_init_(self, I: Optional[Any] = None) -> str: ...
    def _mathematica_init_(self) -> str: ...
    def _maxima_init_(self, I: Optional[Any] = None) -> str: ...
    def _sympy_(self) -> Any: ...
    def _repr_(self) -> str: ...
    def __format__(self, format_spec: str) -> str: ...
    def _latex_(self) -> str: ...
    def __pari__(self) -> Any: ...
    def __mpc__(self) -> gmpy2.mpc: ...
    def _add_(self, right: Any) -> ComplexDoubleElement: ...
    def _sub_(self, right: Any) -> ComplexDoubleElement: ...
    def _mul_(self, right: Any) -> ComplexDoubleElement: ...
    def _div_(self, right: Any) -> ComplexDoubleElement: ...
    def __invert__(self) -> ComplexDoubleElement: ...
    def _neg_(self) -> ComplexDoubleElement: ...
    def conjugate(self) -> ComplexDoubleElement: ...
    def conj(self) -> ComplexDoubleElement: ...
    def arg(self) -> RealDoubleElement: ...
    def __abs__(self) -> RealDoubleElement: ...
    def abs(self) -> RealDoubleElement: ...
    def argument(self) -> RealDoubleElement: ...
    def abs2(self) -> RealDoubleElement: ...
    def norm(self) -> RealDoubleElement: ...
    def logabs(self) -> RealDoubleElement: ...
    def real(self) -> RealDoubleElement: ...
    def imag(self) -> RealDoubleElement: ...
    
    @overload
    def sqrt(self, all: Literal[False] = ..., **kwds: Any) -> ComplexDoubleElement: ...
    @overload
    def sqrt(self, all: Literal[True], **kwds: Any) -> List[ComplexDoubleElement]: ...
    
    @overload
    def nth_root(self, n: int, all: Literal[False] = ...) -> ComplexDoubleElement: ...
    @overload
    def nth_root(self, n: int, all: Literal[True]) -> List[ComplexDoubleElement]: ...

    def is_square(self) -> bool: ...
    def is_integer(self) -> bool: ...
    def is_positive_infinity(self) -> bool: ...
    def is_negative_infinity(self) -> bool: ...
    def is_infinity(self) -> bool: ...
    def is_NaN(self) -> bool: ...
    def _pow_(self, other: Any) -> ComplexDoubleElement: ...
    def exp(self) -> ComplexDoubleElement: ...
    def log(self, base: Any = None) -> ComplexDoubleElement: ...
    def log10(self) -> ComplexDoubleElement: ...
    def log_b(self, b: Any) -> ComplexDoubleElement: ...
    def sin(self) -> ComplexDoubleElement: ...
    def cos(self) -> ComplexDoubleElement: ...
    def tan(self) -> ComplexDoubleElement: ...
    def sec(self) -> ComplexDoubleElement: ...
    def csc(self) -> ComplexDoubleElement: ...
    def cot(self) -> ComplexDoubleElement: ...
    def arcsin(self) -> ComplexDoubleElement: ...
    def arccos(self) -> ComplexDoubleElement: ...
    def arctan(self) -> ComplexDoubleElement: ...
    def arccsc(self) -> ComplexDoubleElement: ...
    def arccot(self) -> ComplexDoubleElement: ...
    def arcsec(self) -> ComplexDoubleElement: ...
    def sinh(self) -> ComplexDoubleElement: ...
    def cosh(self) -> ComplexDoubleElement: ...
    def tanh(self) -> ComplexDoubleElement: ...
    def sech(self) -> ComplexDoubleElement: ...
    def csch(self) -> ComplexDoubleElement: ...
    def coth(self) -> ComplexDoubleElement: ...
    def arcsinh(self) -> ComplexDoubleElement: ...
    def arccosh(self) -> ComplexDoubleElement: ...
    def arctanh(self) -> ComplexDoubleElement: ...
    def arcsech(self) -> ComplexDoubleElement: ...
    def arccsch(self) -> ComplexDoubleElement: ...
    def arccoth(self) -> ComplexDoubleElement: ...
    def eta(self, omit_frac: int = 0) -> ComplexDoubleElement: ...
    def agm(self, right: Any, algorithm: str = 'optimal') -> ComplexDoubleElement: ...
    def dilog(self) -> ComplexDoubleElement: ...
    def gamma(self) -> Union[ComplexDoubleElement, Any]: ... # Can return infinity (which type?)
    def gamma_inc(self, t: Any) -> ComplexDoubleElement: ...
    def algebraic_dependency(self, n: int) -> Any: ...

class FloatToCDF(Morphism):
    def __init__(self, R: Any) -> None: ...
    def _call_(self, x: Any) -> ComplexDoubleElement: ...
    def _repr_type(self) -> str: ...

class ComplexToCDF(Morphism):
    def __init__(self, R: Any) -> None: ...
    def _call_(self, x: Any) -> ComplexDoubleElement: ...
    def _repr_type(self) -> str: ...

RDF: RealDoubleField_class
_CDF: ComplexDoubleField_class
CDF: ComplexDoubleField_class

def is_ComplexDoubleElement(x: Any) -> bool: ...
def ComplexDoubleField() -> ComplexDoubleField_class: ...

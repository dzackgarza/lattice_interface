from typing import Any, Optional, Union, List, Tuple, Dict
from sage.structure.element import EuclideanDomainElement, Element, RingElement
from sage.structure.parent import Parent
from sage.rings.rational import Rational
from sage.categories.morphism import Morphism

class Integer(EuclideanDomainElement):
    def __init__(self, x: Any = None, base: int = 0) -> None: ...
    def __reduce__(self) -> Tuple[Any, Tuple[str]]: ...
    def __index__(self) -> int: ...
    def _im_gens_(self, codomain: Parent, im_gens: Any, base_map: Any = None) -> Any: ...
    def __xor__(self, other: Any) -> Any: ...
    def __richcmp__(self, other: Any, op: int) -> Any: ...
    def _richcmp_(self, other: Any, op: int) -> Any: ...
    def __copy__(self) -> Integer: ...
    def __deepcopy__(self, memo: Any) -> Integer: ...
    def list(self) -> List[Integer]: ...
    def __repr__(self) -> str: ...
    def _latex_(self) -> str: ...
    def _symbolic_(self, sring: Any) -> Any: ...
    def _sympy_(self) -> Any: ...
    def _mathml_(self) -> str: ...
    def __mpz__(self) -> Any: ...
    def _regina_(self, regina: Any) -> Any: ...
    def str(self, base: int = 10) -> str: ...
    def __format__(self, *args: Any, **kwargs: Any) -> str: ...
    def ordinal_str(self) -> str: ...
    def hex(self) -> str: ...
    def oct(self) -> str: ...
    def binary(self) -> str: ...
    def bits(self) -> List[Integer]: ...
    def bit_length(self) -> int: ...
    def nbits(self) -> int: ...
    def trailing_zero_bits(self) -> int: ...
    def digits(self, base: int = 10, digits: Any = None, padto: int = 0) -> List[Any]: ...
    def balanced_digits(self, base: int = 10, positive_shift: bool = True) -> List[int]: ...
    def ndigits(self, base: int = 10) -> int: ...
    def __add__(self, other: Any) -> Any: ...
    def _add_(self, right: Integer) -> Integer: ...
    def _add_long(self, n: int) -> Integer: ...
    def __sub__(self, other: Any) -> Any: ...
    def _sub_(self, right: Integer) -> Integer: ...
    def __neg__(self) -> Integer: ...
    def _neg_(self) -> Integer: ...
    def _act_on_(self, s: Any, self_on_left: bool) -> Any: ...
    def _mul_long(self, n: int) -> Integer: ...
    def __mul__(self, other: Any) -> Any: ...
    def _mul_(self, right: Integer) -> Integer: ...
    def __truediv__(self, other: Any) -> Any: ...
    def _div_(self, right: Integer) -> Rational: ...
    def _floordiv_(self, right: Integer) -> Integer: ...
    def __pow__(self, other: Any, modulus: Any = None) -> Any: ...
    def _pow_(self, other: Integer) -> Any: ...
    def _pow_int(self, n: Any) -> Any: ...
    def nth_root(self, n: int, truncate_mode: bool = False) -> Union[Integer, Tuple[Integer, bool]]: ...
    def exact_log(self, m: Any) -> Integer: ...
    def log(self, m: Any = None, prec: Any = None) -> Any: ...
    def exp(self, prec: Any = None) -> Any: ...
    def prime_to_m_part(self, m: Any) -> Integer: ...
    def prime_divisors(self, *args: Any, **kwds: Any) -> List[Integer]: ...
    def prime_factors(self, *args: Any, **kwds: Any) -> List[Integer]: ...
    def divisors(self, method: Optional[str] = None) -> List[Integer]: ...
    def __pos__(self) -> Integer: ...
    def __abs__(self) -> Integer: ...
    def euclidean_degree(self) -> int: ...
    def sign(self) -> Integer: ...
    def __mod__(self, other: Any) -> Any: ...
    def quo_rem(self, other: Any) -> Tuple[Any, Any]: ...
    def powermod(self, exp: Any, mod: Any) -> Integer: ...
    def rational_reconstruction(self, m: Integer) -> Rational: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def _rpy_(self) -> int: ...
    def __hash__(self) -> int: ...
    def trial_division(self, bound: int = ..., start: int = 2) -> Integer: ...
    def factor(self, algorithm: str = 'pari', proof: Optional[bool] = None, limit: Optional[int] = None, int_: bool = False, verbose: int = 0, flint_bits: Optional[int] = None) -> Any: ...
    def support(self) -> List[Integer]: ...
    def coprime_integers(self, m: Any) -> List[Integer]: ...
    def divides(self, n: Any) -> bool: ...
    def valuation(self, p: Any) -> Union[Integer, float]: ...
    def ord(self, p: Any) -> Union[Integer, float]: ...
    def p_primary_part(self, p: Any) -> Integer: ...
    def val_unit(self, p: Any) -> Tuple[Union[Integer, float], Integer]: ...
    def odd_part(self) -> Integer: ...
    def divide_knowing_divisible_by(self, right: Any) -> Integer: ...
    def _lcm(self, n: Integer) -> Integer: ...
    def _gcd(self, n: Integer) -> Integer: ...
    def denominator(self) -> Integer: ...
    def numerator(self) -> Integer: ...
    def as_integer_ratio(self) -> Tuple[Integer, Integer]: ...
    def factorial(self) -> Integer: ...
    def multifactorial(self, k: int) -> Any: ...
    def gamma(self) -> Any: ...
    def floor(self) -> Integer: ...
    def ceil(self) -> Integer: ...
    def trunc(self) -> Integer: ...
    def round(self, mode: str = 'away') -> Integer: ...
    def real(self) -> Integer: ...
    def imag(self) -> Integer: ...
    def is_one(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def is_integral(self) -> bool: ...
    def is_rational(self) -> bool: ...
    def is_integer(self) -> bool: ...
    def is_unit(self) -> bool: ...
    def is_square(self) -> bool: ...
    def perfect_power(self) -> Tuple[Integer, Integer]: ...
    def global_height(self, prec: Any = None) -> Any: ...
    def is_power_of(self, n: Any) -> bool: ...
    def is_prime_power(self, proof: Optional[bool] = None, get_data: bool = False) -> Union[bool, Tuple[Integer, Integer]]: ...
    def is_prime(self, proof: Optional[bool] = None) -> bool: ...
    def is_irreducible(self) -> bool: ...
    def is_pseudoprime(self) -> bool: ...
    def is_pseudoprime_power(self, get_data: bool = False) -> Union[bool, Tuple[Integer, Integer]]: ...
    def is_perfect_power(self) -> bool: ...
    def is_norm(self, K: Any, element: bool = False, proof: bool = True) -> Any: ...
    def _bnfisnorm(self, K: Any, proof: bool = True, extra_primes: int = 0) -> Any: ...
    def jacobi(self, b: Any) -> int: ...
    def kronecker(self, b: Any) -> int: ...
    def class_number(self, proof: bool = True) -> int: ...
    def squarefree_part(self, bound: int = -1) -> Integer: ...
    def next_probable_prime(self) -> Integer: ...
    def next_prime(self, proof: Optional[bool] = None) -> Integer: ...
    def previous_prime(self, proof: Optional[bool] = None) -> Integer: ...
    def next_prime_power(self, proof: Optional[bool] = None) -> Integer: ...
    def previous_prime_power(self, proof: Optional[bool] = None) -> Integer: ...
    def additive_order(self) -> Any: ...
    def multiplicative_order(self) -> Any: ...
    def is_squarefree(self) -> bool: ...
    def is_discriminant(self) -> bool: ...
    def is_fundamental_discriminant(self) -> bool: ...
    def __pari__(self) -> Any: ...
    def _interface_init_(self, I: Any = None) -> str: ...
    @property
    def __array_interface__(self) -> Any: ...
    def _magma_init_(self, magma: Any) -> str: ...
    def _sage_input_(self, sib: Any, coerced: Any) -> Any: ...
    def sqrtrem(self) -> Tuple[Integer, Integer]: ...
    def isqrt(self) -> Integer: ...
    def sqrt(self, prec: Any = None, extend: bool = True, all: bool = False) -> Any: ...
    def xgcd(self, n: Integer) -> Tuple[Integer, Integer, Integer]: ...
    def _xgcd(self, n: Integer, minimal: bool = False) -> Tuple[Integer, Integer, Integer]: ...
    def _shift_helper(self, y: Any, sign: int) -> Integer: ...
    def __lshift__(self, y: Any) -> Integer: ...
    def __rshift__(self, y: Any) -> Integer: ...
    def __and__(self, other: Any) -> Any: ...
    def __or__(self, other: Any) -> Any: ...
    def __invert__(self) -> Rational: ...
    def inverse_of_unit(self) -> Integer: ...
    def inverse_mod(self, n: Any) -> Integer: ...
    def crt(self, y: Any, m: Any, n: Any) -> Integer: ...
    def test_bit(self, index: int) -> int: ...
    def popcount(self) -> Any: ...
    def conjugate(self) -> Integer: ...
    def binomial(self, m: Any, algorithm: str = 'gmp') -> Integer: ...
    def to_bytes(self, length: int = 1, byteorder: str = 'big', is_signed: bool = False) -> bytes: ...
    def canonical_associate(self) -> Tuple[Integer, Integer]: ...

class IntegerWrapper(Integer):
    def __init__(self, parent: Any = None, x: Any = None, base: int = 0) -> None: ...

def is_Integer(x: Any) -> bool: ...
def GCD_list(v: Any) -> Integer: ...
def make_integer(s: str) -> Integer: ...

class int_to_Z(Morphism):
    def __init__(self) -> None: ...
    def _call_(self, a: Any) -> Element: ...
    def _repr_type(self) -> str: ...

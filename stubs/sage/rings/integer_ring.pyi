from typing import Any, Iterator, List, Optional, Tuple, Union, overload
from sage.structure.parent import Parent
from sage.categories.morphism import Morphism
from sage.rings.integer import Integer
from sage.rings.rational_field import RationalField as RationalField_class

# Mock base class
PrincipalIdealDomain = Any

class IntegerRing_class(PrincipalIdealDomain):
    def __init__(self) -> None: ...
    def __reduce__(self) -> Tuple[Any, Tuple[()]]: ...
    def _repr_(self) -> str: ...
    def _latex_(self) -> str: ...
    def fraction_field(self) -> RationalField_class: ...
    def is_field(self, proof: bool = True) -> bool: ...
    def is_finite(self) -> bool: ...
    def characteristic(self) -> Integer: ...
    def order(self) -> Any: ... # Returns Infinity
    def degree(self) -> int: ...
    def free_module(self) -> Any: ...
    def _coerce_map_from_(self, S: Any) -> Optional[Morphism]: ...
    def random_element(self, x: Optional[Any] = None, y: Optional[Any] = None, distribution: Optional[str] = None) -> Integer: ...
    
    @overload
    def range(self, end: int) -> Iterator[Integer]: ...
    @overload
    def range(self, start: int, end: int) -> Iterator[Integer]: ...
    @overload
    def range(self, start: int, end: int, step: int) -> Iterator[Integer]: ...
    
    def _an_element_(self) -> Integer: ...
    def discriminant(self) -> Integer: ...
    def polynomial_repository(self) -> Any: ...
    def completion(self, p: Any, prec: Any = None, extras: Any = None) -> Any: ... # Returns pAdicRing or self
    def extension(self, poly: Any, names: Any = None, **kwds: Any) -> Any: ... # Returns NumberField or similar
    def roots_of_unity(self) -> List[Integer]: ...
    def zeta(self, n: int = 2) -> Integer: ...
    def complex_embedding(self, prec: int = 53) -> Any: ...
    def _pseudo_fraction_field(self) -> RationalField_class: ...
    def krull_dimension(self) -> Any: ...
    def is_noetherian(self) -> bool: ...
    def is_integrally_closed(self) -> bool: ...
    def is_unique_factorization_domain(self, proof: bool = True) -> bool: ...
    def is_dedekind_domain(self) -> bool: ...
    def gens(self) -> Tuple[Integer]: ...
    def gen(self, n: int = 0) -> Integer: ...
    def ngens(self) -> int: ...
    def parameter(self) -> Integer: ...
    def _roots_univariate_polynomial(self, p: Any, multiplicities: bool = True) -> List[Any]: ...
    def _gap_init_(self) -> str: ...
    def _fricas_init_(self) -> str: ...
    def _magma_init_(self, magma: Any) -> str: ...
    def _macaulay2_init_(self, macaulay2: Any = None) -> str: ...
    def _polymake_init_(self) -> str: ...
    def _sympy_(self) -> Any: ...
    def _sage_input_(self, sib: Any, coerced: Any) -> Any: ...
    def valuation(self, p: Any) -> Any: ...
    def from_bytes(self, input_bytes: bytes, byteorder: str = 'big', is_signed: bool = False) -> Integer: ...

ZZ: IntegerRing_class
Z: IntegerRing_class

def IntegerRing() -> IntegerRing_class: ...
def crt_basis(X: List[Integer], xgcd: Any = None) -> List[Integer]: ...

r"""
Elements
"""
from typing import Any, Optional, Union, Tuple, List
from sage.structure.sage_object import SageObject
from sage.structure.parent import Parent
from sage.structure.coerce import CoercionModel

coercion_model: CoercionModel

def make_element(_class: type, _dict: dict, parent: Parent) -> Any: ...
def is_Element(x: Any) -> bool: ...

class Element(SageObject):
    def __init__(self, parent: Parent) -> None: ...
    def _set_parent(self, parent: Parent) -> None: ...
    def __getattr__(self, name: str) -> Any: ...
    def __dir__(self) -> List[str]: ...
    def _repr_(self) -> str: ...
    def __getstate__(self) -> Tuple[Parent, dict]: ...
    def __setstate__(self, state: Tuple[Parent, dict]) -> None: ...
    def __copy__(self) -> Element: ...
    def _im_gens_(self, codomain: Parent, im_gens: Any, base_map: Any = None) -> Any: ...
    def base_extend(self, R: Any) -> Any: ...
    def base_ring(self) -> Any: ...
    def category(self) -> Any: ...
    def _test_new(self, **options: Any) -> None: ...
    def _test_category(self, **options: Any) -> None: ...
    def _test_eq(self, **options: Any) -> None: ...
    def parent(self, x: Any = None) -> Any: ...
    def subs(self, in_dict: Optional[dict] = None, **kwds: Any) -> Any: ...
    def substitute(self, *args: Any, **kwds: Any) -> Any: ...
    def numerical_approx(self, prec: Optional[int] = None, digits: Optional[int] = None, algorithm: Optional[str] = None) -> Any: ...
    def n(self, prec: Optional[int] = None, digits: Optional[int] = None, algorithm: Optional[str] = None) -> Any: ...
    def _mpmath_(self, prec: int = 53, rounding: Optional[str] = None) -> Any: ...
    def _act_on_(self, x: Any, self_on_left: bool) -> Any: ...
    def _acted_upon_(self, x: Any, self_on_left: bool) -> Any: ...
    def __xor__(self, right: Any) -> Any: ...
    def __pos__(self) -> Element: ...
    def _coeff_repr(self, no_space: bool = True) -> str: ...
    def _latex_coeff_repr(self) -> str: ...
    def _is_atomic(self) -> bool: ...
    def __bool__(self) -> bool: ...
    def is_zero(self) -> bool: ...
    def _cache_key(self) -> Tuple[Parent, str]: ...
    def __richcmp__(self, other: Any, op: int) -> Any: ...
    def _richcmp_(self, other: Any, op: int) -> Any: ...
    def __add__(self, other: Any) -> Any: ...
    def _add_(self, other: Any) -> Any: ...
    def _add_long(self, n: int) -> Any: ...
    def __sub__(self, other: Any) -> Any: ...
    def _sub_(self, other: Any) -> Any: ...
    def __neg__(self) -> Any: ...
    def _neg_(self) -> Any: ...
    def __mul__(self, other: Any) -> Any: ...
    def _mul_(self, other: Any) -> Any: ...
    def _mul_long(self, n: int) -> Any: ...
    def __matmul__(self, other: Any) -> Any: ...
    def _matmul_(self, other: Any) -> Any: ...
    def __truediv__(self, other: Any) -> Any: ...
    def _div_(self, other: Any) -> Any: ...
    def __floordiv__(self, other: Any) -> Any: ...
    def _floordiv_(self, other: Any) -> Any: ...
    def __mod__(self, other: Any) -> Any: ...
    def _mod_(self, other: Any) -> Any: ...
    def __pow__(self, other: Any, modulus: Any = None) -> Any: ...
    def _pow_(self, other: Any) -> Any: ...
    def _pow_int(self, other: Any) -> Any: ...
    def _pow_long(self, n: int) -> Any: ...

def is_ModuleElement(x: Any) -> bool: ...

class ElementWithCachedMethod(Element): ...

class ModuleElement(Element):
    def _add_(self, other: Any) -> Any: ...
    def _add_long(self, n: int) -> Any: ...
    def _sub_(self, other: Any) -> Any: ...
    def _neg_(self) -> Any: ...
    def _mul_long(self, n: int) -> Any: ...
    def _rmul_(self, left: Element) -> Any: ...
    def _lmul_(self, right: Element) -> Any: ...
    def order(self) -> Any: ...
    def additive_order(self) -> Any: ...

class ModuleElementWithMutability(ModuleElement):
    def __init__(self, parent: Parent, is_immutable: bool = False) -> None: ...
    def set_immutable(self) -> None: ...
    def is_mutable(self) -> bool: ...
    def is_immutable(self) -> bool: ...

def is_MonoidElement(x: Any) -> bool: ...

class MonoidElement(Element):
    def order(self) -> Any: ...
    def multiplicative_order(self) -> Any: ...
    def _pow_int(self, n: Any) -> Any: ...
    def powers(self, n: int) -> List[Any]: ...
    def __bool__(self) -> bool: ...

def is_AdditiveGroupElement(x: Any) -> bool: ...

class AdditiveGroupElement(ModuleElement):
    def order(self) -> Any: ...
    def __invert__(self) -> Any: ...

def is_MultiplicativeGroupElement(x: Any) -> bool: ...

class MultiplicativeGroupElement(MonoidElement):
    def order(self) -> Any: ...
    def _div_(self, right: Any) -> Any: ...
    def __invert__(self) -> Any: ...

def is_RingElement(x: Any) -> bool: ...

class RingElement(ModuleElement):
    def _mul_(self, other: Any) -> Any: ...
    def is_one(self) -> bool: ...
    def _pow_int(self, n: Any) -> Any: ...
    def powers(self, n: int) -> List[Any]: ...
    def _div_(self, other: Any) -> Any: ...
    def __divmod__(self, other: Any) -> Tuple[Any, Any]: ...
    def __invert__(self) -> Any: ...
    def additive_order(self) -> Any: ...
    def multiplicative_order(self) -> Any: ...
    def is_nilpotent(self) -> bool: ...
    def abs(self) -> Any: ...
    def is_prime(self) -> bool: ...

def is_CommutativeRingElement(x: Any) -> bool: ...

class CommutativeRingElement(RingElement):
    def inverse_mod(self, I: Any) -> Any: ...
    def divides(self, x: Any) -> bool: ...
    def mod(self, I: Any) -> Any: ...

class Expression(CommutativeRingElement): ...

class Vector(ModuleElementWithMutability):
    def __mul__(self, right: Any) -> Any: ...
    def _dot_product_(self, right: Vector) -> Any: ...
    def _dot_product_coerce_(self, right: Vector) -> Any: ...
    def _pairwise_product_(self, right: Vector) -> Any: ...
    def __truediv__(self, right: Any) -> Any: ...
    def _magma_init_(self, magma: Any) -> str: ...

def is_Vector(x: Any) -> bool: ...

class Matrix(ModuleElement):
    def __mul__(self, right: Any) -> Any: ...
    def __truediv__(self, right: Any) -> Any: ...
    def _vector_times_matrix_(self, vector_left: Vector) -> Any: ...
    def _matrix_times_vector_(self, vector_right: Vector) -> Any: ...
    def _matrix_times_matrix_(self, right: Matrix) -> Any: ...

def is_Matrix(x: Any) -> bool: ...

def is_IntegralDomainElement(x: Any) -> bool: ...

class IntegralDomainElement(CommutativeRingElement):
    def is_nilpotent(self) -> bool: ...

def is_DedekindDomainElement(x: Any) -> bool: ...

class DedekindDomainElement(IntegralDomainElement): ...

def is_PrincipalIdealDomainElement(x: Any) -> bool: ...

class PrincipalIdealDomainElement(DedekindDomainElement):
    def gcd(self, right: Any) -> Any: ...
    def lcm(self, right: Any) -> Any: ...

def is_EuclideanDomainElement(x: Any) -> bool: ...

class EuclideanDomainElement(PrincipalIdealDomainElement):
    def degree(self) -> Any: ...
    def leading_coefficient(self) -> Any: ...
    def quo_rem(self, other: Any) -> Tuple[Any, Any]: ...
    def _floordiv_(self, right: Any) -> Any: ...
    def _mod_(self, other: Any) -> Any: ...

def is_FieldElement(x: Any) -> bool: ...

class FieldElement(CommutativeRingElement):
    def _floordiv_(self, right: Any) -> Any: ...
    def is_unit(self) -> bool: ...
    def _lcm(self, other: FieldElement) -> Any: ...
    def quo_rem(self, right: Any) -> Tuple[Any, Any]: ...
    def divides(self, other: FieldElement) -> bool: ...
    def canonical_associate(self) -> Tuple[Any, Any]: ...

def is_AlgebraElement(x: Any) -> bool: ...

class AlgebraElement(RingElement): ...

def is_CommutativeAlgebraElement(x: Any) -> bool: ...

class CommutativeAlgebraElement(CommutativeRingElement): ...

def is_InfinityElement(x: Any) -> bool: ...

class InfinityElement(RingElement):
    def __invert__(self) -> Any: ...

def canonical_coercion(x: Any, y: Any) -> Tuple[Any, Any]: ...
def bin_op(x: Any, y: Any, op: Any) -> Any: ...
def get_coercion_model() -> CoercionModel: ...
def coercion_traceback(dump: bool = True) -> Any: ...
def coerce_binop(method: Any) -> Any: ...

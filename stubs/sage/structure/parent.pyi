r"""
Base class for parent objects
"""
from typing import Any, Optional, Union, Callable, List, Dict, Tuple, Iterator, Type
from sage.structure.sage_object import SageObject
from sage.structure.category_object import CategoryObject
from sage.categories.category import Category
from sage.structure.coerce_maps import Map

class Parent(CategoryObject):
    def __init__(self, base: Any = None, *, category: Optional[Union[Category, Tuple[Category, ...]]] = None,
                 names: Optional[Union[str, Tuple[str, ...]]] = None, normalize: bool = True, facade: Any = None) -> None: ...
    def _init_category_(self, category: Category) -> None: ...
    def _refine_category_(self, category: Category) -> None: ...
    def _unset_category(self) -> None: ...
    @property
    def _abstract_element_class(self) -> type: ...
    @property
    def element_class(self) -> type: ...
    def __make_element_class__(self, cls: type, name: Optional[str] = None, module: Optional[str] = None, inherit: Optional[bool] = None) -> type: ...
    def category(self) -> Category: ...
    def _test_category(self, **options: Any) -> None: ...
    def _test_eq(self, **options: Any) -> None: ...
    def _introspect_coerce(self) -> Dict[str, Any]: ...
    def _repr_option(self, key: str) -> bool: ...
    def __call__(self, x: Any = 0, *args: Any, **kwds: Any) -> Any: ...
    def __mul__(self, x: Any) -> Any: ...
    def __pow__(self, x: Any, mod: Any = None) -> Any: ...
    def __contains__(self, x: Any) -> bool: ...
    def coerce(self, x: Any) -> Any: ...
    def __getitem__(self, n: Any) -> Any: ...
    def _is_valid_homomorphism_(self, codomain: Parent, im_gens: Any, base_map: Optional[Map] = None) -> bool: ...
    def Hom(self, codomain: Parent, category: Optional[Category] = None) -> Parent: ...
    def hom(self, im_gens: Any, codomain: Optional[Parent] = None, check: Optional[bool] = None, base_map: Optional[Map] = None, category: Optional[Category] = None, **kwds: Any) -> Map: ...
    def _populate_coercion_lists_(self, coerce_list: List[Any] = [], action_list: List[Any] = [], convert_list: List[Any] = [], embedding: Any = None, convert_method_name: Optional[str] = None, element_constructor: Any = None, init_no_parent: Optional[bool] = None, unpickling: bool = False) -> None: ...
    def _unset_coercions_used(self) -> None: ...
    def _unset_embedding(self) -> None: ...
    def _is_coercion_cached(self, domain: Parent) -> bool: ...
    def _is_conversion_cached(self, domain: Parent) -> bool: ...
    def _remove_from_coerce_cache(self, domain: Parent) -> None: ...
    def register_coercion(self, mor: Union[Map, Parent, type]) -> None: ...
    def register_action(self, action: Any) -> None: ...
    def register_conversion(self, mor: Union[Map, Parent, type]) -> None: ...
    def register_embedding(self, embedding: Union[Map, Parent]) -> None: ...
    def coerce_embedding(self) -> Optional[Map]: ...
    def _generic_coerce_map(self, S: Parent) -> Map: ...
    def _generic_convert_map(self, S: Parent, category: Optional[Category] = None) -> Map: ...
    def _convert_method_map(self, S: Parent, method_name: Optional[str] = None) -> Optional[Map]: ...
    def convert_method_map(self, S: Parent, method_name: str) -> Optional[Map]: ...
    def _coerce_map_via(self, v: List[Parent], S: Parent) -> Optional[Map]: ...
    def has_coerce_map_from(self, S: Parent) -> bool: ...
    def _coerce_map_from_(self, S: Parent) -> Optional[Union[Map, bool, Callable]]: ...
    def coerce_map_from(self, S: Parent) -> Optional[Map]: ...
    def _internal_coerce_map_from(self, S: Parent) -> Optional[Map]: ...
    def discover_coerce_map_from(self, S: Parent) -> Optional[Map]: ...
    def convert_map_from(self, S: Parent) -> Optional[Map]: ...
    def _internal_convert_map_from(self, S: Parent) -> Optional[Map]: ...
    def discover_convert_map_from(self, S: Parent) -> Optional[Map]: ...
    def _convert_map_from_(self, S: Parent) -> Optional[Map]: ...
    def get_action(self, S: Any, op: Any = ..., self_on_left: bool = True, self_el: Any = None, S_el: Any = None) -> Any: ...
    def discover_action(self, S: Any, op: Any, self_on_left: bool, self_el: Any = None, S_el: Any = None) -> Any: ...
    def _get_action_(self, S: Any, op: Any, self_on_left: bool) -> Any: ...
    def an_element(self) -> Any: ...
    def _an_element_(self) -> Any: ...
    def is_exact(self) -> bool: ...
    def _is_numerical(self) -> bool: ...
    def _is_real_numerical(self) -> bool: ...

class Set_generic(Parent):
    def object(self) -> Any: ...

class EltPair:
    def __init__(self, x: Any, y: Any, tag: Any) -> None: ...
    def short_repr(self) -> Tuple[Any, str, str]: ...

def is_Parent(x: Any) -> bool: ...

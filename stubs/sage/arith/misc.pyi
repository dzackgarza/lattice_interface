from typing import Any, overload, Union
from collections.abc import Generator, Iterable, Iterator, Sequence

from sage.rings.integer import Integer
from sage.rings.rational import Rational
from sage.structure.factorization import Factorization

def algebraic_dependency(z: Any, degree: int, known_bits: int | None = None, use_bits: int | None = None, known_digits: int | None = None, use_digits: int | None = None, height_bound: int | None = None, proof: bool = False) -> Any: ...
algdep = algebraic_dependency

def bernoulli(n: int, algorithm: str = 'default', num_threads: int = 1) -> Rational: ...
def factorial(n: int, algorithm: str = 'gmp') -> Integer: ...
def is_prime(n: Any) -> bool: ...
def is_pseudoprime(n: Any) -> bool: ...
@overload
def is_prime_power(n: Any, get_data: bool = False) -> bool: ...
@overload
def is_prime_power(n: Any, get_data: bool = True) -> tuple[Integer, int]: ...
@overload
def is_pseudoprime_power(n: Any, get_data: bool = False) -> bool: ...
@overload
def is_pseudoprime_power(n: Any, get_data: bool = True) -> tuple[Integer, int]: ...
def valuation(m: Any, *args: Any, **kwds: Any) -> Any: ...
def prime_powers(start: int, stop: int | None = None) -> list[Integer]: ...
def primes_first_n(n: int, leave_pari: bool = False) -> list[Integer]: ...
def eratosthenes(n: int) -> list[Integer]: ...
def primes(start: int = 2, stop: int | None = None, proof: bool | None = None) -> Iterator[Integer]: ...
def next_prime_power(n: Any) -> Integer: ...
def next_probable_prime(n: Any) -> Integer: ...
def next_prime(n: Any, proof: bool | None = None) -> Integer: ...
def previous_prime(n: Any) -> Integer: ...
def previous_prime_power(n: Any) -> Integer: ...
def random_prime(n: int, proof: bool | None = None, lbound: int = 2) -> Integer: ...
def divisors(n: Any) -> list[Any]: ...

class Sigma:
    def __call__(self, n: int, k: int = 1) -> Integer: ...
    def plot(self, xmin: int = 1, xmax: int = 50, k: int = 1, pointsize: int = 30, rgbcolor: Any = (0, 0, 1), join: bool = True, **kwds: Any) -> Any: ...

sigma: Sigma

def gcd(a: Any, b: Any = None, **kwargs: Any) -> Any: ...
GCD = gcd

def xlcm(m: Any, n: Any) -> tuple[Any, Any, Any]: ...
def xgcd(a: Any, b: Any = None) -> tuple[Any, Any, Any] | tuple[Any, ...]: ...
XGCD = xgcd

def xkcd(n: str | int = '') -> Any: ...
def inverse_mod(a: Any, m: Any) -> Any: ...
def get_gcd(order: int) -> Any: ...
def get_inverse_mod(order: int) -> Any: ...
def power_mod(a: Any, n: int, m: Any) -> Any: ...
def rational_reconstruction(a: int, m: int, algorithm: str = 'fast') -> Rational: ...
def mqrr_rational_reconstruction(u: int, m: int, T: int) -> tuple[Integer, Integer] | None: ...
def trial_division(n: int, bound: int | None = None) -> Integer: ...
def factor(n: Any, proof: bool | None = None, int_: bool = False, algorithm: str | None = None, verbose: int = 0, **kwds: Any) -> Factorization | Any: ...
def radical(n: Any, *args: Any, **kwds: Any) -> Any: ...
def prime_divisors(n: Any) -> list[Any]: ...
prime_factors = prime_divisors

def odd_part(n: Any) -> Integer: ...
def prime_to_m_part(n: Any, m: int) -> Integer: ...
@overload
def is_square(n: Any, root: bool = False) -> bool: ...
@overload
def is_square(n: Any, root: bool = True) -> tuple[bool, Any]: ...
def is_squarefree(n: Any) -> bool: ...

class Euler_Phi:
    def __call__(self, n: int) -> Integer: ...
    def plot(self, xmin: int = 1, xmax: int = 50, pointsize: int = 30, rgbcolor: Any = (0, 0, 1), join: bool = True, **kwds: Any) -> Any: ...

euler_phi: Euler_Phi

def carmichael_lambda(n: int) -> Integer: ...
def crt(a: Any, b: Any, m: Any = None, n: Any = None) -> Any: ...
CRT = crt

def CRT_list(values: list[Any], moduli: list[Any] | None = None) -> Any: ...
def CRT_basis(moduli: list[Any], *, require_coprime_moduli: bool = True) -> list[Any] | tuple[list[Any], bool]: ...
def CRT_vectors(X: Sequence[Sequence[Any]], moduli: list[Any]) -> list[Any]: ...
def binomial(x: Any, m: Any, **kwds: Any) -> Any: ...
def multinomial(*ks: Any) -> Integer: ...
def binomial_coefficients(n: int) -> dict[tuple[int, int], int]: ...
def multinomial_coefficients(m: int, n: int) -> dict[tuple[int, ...], int]: ...
def kronecker_symbol(x: int, y: int) -> Integer: ...
kronecker = kronecker_symbol

def legendre_symbol(x: int, p: int) -> Integer: ...
def jacobi_symbol(a: int, b: int) -> Integer: ...
def primitive_root(n: int, check: bool = True) -> Integer: ...
def nth_prime(n: int) -> Integer: ...
def quadratic_residues(n: int) -> list[Integer]: ...

class Moebius:
    def __call__(self, n: Any) -> Integer: ...
    def plot(self, xmin: int = 0, xmax: int = 50, pointsize: int = 30, rgbcolor: Any = (0, 0, 1), join: bool = True, **kwds: Any) -> Any: ...
    def range(self, start: int, stop: int | None = None, step: int | None = None) -> list[Integer]: ...

moebius: Moebius

def continuant(v: Sequence[Any], n: int | None = None) -> Any: ...
def number_of_divisors(n: int) -> Integer: ...
def hilbert_symbol(a: int, b: int, p: int, algorithm: str = 'pari') -> Integer: ...
def hilbert_conductor(a: int, b: int) -> Integer: ...
def hilbert_conductor_inverse(d: int) -> tuple[Integer, Integer]: ...
def falling_factorial(x: Any, a: Any) -> Any: ...
def rising_factorial(x: Any, a: Any) -> Any: ...
def integer_ceil(x: Any) -> Integer: ...
def integer_floor(x: Any) -> Integer: ...
def integer_trunc(i: Any) -> Integer: ...
def two_squares(n: int) -> tuple[Integer, Integer]: ...
def three_squares(n: int) -> tuple[Integer, Integer, Integer]: ...
def four_squares(n: int) -> tuple[Integer, Integer, Integer, Integer]: ...
def sum_of_k_squares(k: int, n: int) -> tuple[Integer, ...]: ...
def subfactorial(n: int) -> Integer: ...
def is_power_of_two(n: int) -> bool: ...
def differences(lis: Sequence[Any], n: int = 1) -> list[Any]: ...
def sort_complex_numbers_for_display(nums: list[Any]) -> list[Any]: ...
def fundamental_discriminant(D: int) -> Integer: ...
def squarefree_divisors(x: Any) -> Generator[Any, None, None]: ...
def dedekind_sum(p: int, q: int, algorithm: str = 'default') -> Rational: ...
def gauss_sum(char_value: Any, finite_field: Any) -> Any: ...
def dedekind_psi(N: int) -> Integer: ...
def smooth_part(x: Any, base: Any) -> Factorization: ...
def coprime_part(x: Any, base: Any) -> Any: ...

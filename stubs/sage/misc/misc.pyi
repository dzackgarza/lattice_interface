import contextlib
from typing import Any, Callable, Iterable, Iterator, List, Optional, TypeVar, Union, IO, Tuple

T = TypeVar("T")

LOCAL_IDENTIFIER: str

def try_read(obj: Any, splitlines: bool = False) -> Optional[Union[str, bytes, List[str], List[bytes]]]: ...
def exactly_one_is_true(iterable: Iterable[Any]) -> bool: ...
def strunc(s: Any, n: int = 60) -> str: ...
def newton_method_sizes(N: int) -> List[int]: ...
def compose(f: Callable[[Any], Any], g: Callable[[Any], Any]) -> Callable[[Any], Any]: ...
def nest(f: Callable[[Any], Any], n: int, x: Any) -> Any: ...
def is_iterator(it: Any) -> bool: ...
def random_sublist(X: List[T], s: float) -> List[T]: ...
def is_sublist(X: List[Any], Y: Iterable[Any]) -> bool: ...
def some_tuples(elements: Iterable[T], repeat: Optional[int], bound: int, max_samples: Optional[int] = None) -> Union[Iterator[Union[T, Tuple[T, ...]]], List[Union[T, Tuple[T, ...]]]]: ...
def exists(S: Iterable[T], P: Callable[[T], Any]) -> Tuple[bool, Optional[T]]: ...
def forall(S: Iterable[T], P: Callable[[T], Any]) -> Tuple[bool, Optional[T]]: ...

set_trace: Callable[[], None]

def word_wrap(s: str, ncols: int = 85) -> str: ...
def pad_zeros(s: Any, size: int = 3) -> str: ...
def is_in_string(line: str, pos: int) -> bool: ...
def get_main_globals() -> dict[str, Any]: ...
def inject_variable(name: str, value: Any, warn: bool = True) -> None: ...
def inject_variable_test(name: str, value: Any, depth: int) -> None: ...
def run_once(func: T) -> T: ...
@contextlib.contextmanager
def increase_recursion_limit(increment: int) -> Iterator[None]: ...

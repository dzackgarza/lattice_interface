from typing import Any, Optional, Union, List, Tuple, Dict, Set, FrozenSet, Type, Iterator, Iterable, Callable
from sage.structure.unique_representation import UniqueRepresentation
from sage.structure.sage_object import SageObject
from sage.misc.unknown import Unknown

class Category(UniqueRepresentation, SageObject):
    def __init__(self) -> None: ...
    @staticmethod
    def __classcall__(cls, *args: Any, **options: Any) -> Any: ...
    @property
    def _label(self) -> str: ...
    def _repr_object_names(self) -> str: ...
    def _short_name(self) -> str: ...
    @classmethod
    def an_instance(cls) -> "Category": ...
    def __call__(self, x: Any, *args: Any, **opts: Any) -> Any: ...
    def _call_(self, x: Any) -> Any: ...
    def _repr_(self) -> str: ...
    def _latex_(self) -> str: ...
    def _subcategory_hook_(self, category: "Category") -> Union[bool, Unknown]: ...
    def __contains__(self, x: Any) -> bool: ...
    @staticmethod
    def __classcontains__(cls, x: Any) -> bool: ...
    def is_abelian(self) -> bool: ...
    def category_graph(self) -> Any: ...
    def super_categories(self) -> List["Category"]: ...
    @property
    def _all_super_categories(self) -> List["Category"]: ...
    @property
    def _all_super_categories_proper(self) -> List["Category"]: ...
    @property
    def _set_of_super_categories(self) -> FrozenSet["Category"]: ...
    def all_super_categories(self, proper: bool = False) -> List["Category"]: ...
    @property
    def _super_categories(self) -> List["Category"]: ...
    @property
    def _super_categories_for_classes(self) -> List["Category"]: ...
    def additional_structure(self) -> Optional["Category"]: ...
    def structure(self) -> FrozenSet["Category"]: ...
    def is_full_subcategory(self, other: "Category") -> bool: ...
    def full_super_categories(self) -> List["Category"]: ...
    def _test_category_graph(self, **options: Any) -> None: ...
    def _test_category(self, **options: Any) -> None: ...
    def _make_named_class(self, name: str, method_provider: str, cache: bool = False, picklable: bool = True) -> Type: ...
    @property
    def subcategory_class(self) -> Type: ...
    @property
    def parent_class(self) -> Type: ...
    @property
    def element_class(self) -> Type: ...
    @property
    def morphism_class(self) -> Type: ...
    def required_methods(self) -> Dict[str, Dict[str, List[str]]]: ...
    def is_subcategory(self, c: "Category") -> Union[bool, Unknown]: ...
    def or_subcategory(self, category: Optional[Union["Category", Tuple["Category", ...], List["Category"]]] = None, join: bool = False) -> "Category": ...
    def _is_subclass(self, c: Union["Category", Type["Category"]]) -> bool: ...
    def _meet_(self, other: "Category") -> "Category": ...
    @staticmethod
    def meet(categories: Iterable["Category"]) -> "Category": ...
    def axioms(self) -> FrozenSet[str]: ...
    def _with_axiom_as_tuple(self, axiom: str) -> Tuple["Category", ...]: ...
    def _with_axiom(self, axiom: str) -> "Category": ...
    def _with_axioms(self, axioms: Iterable[str]) -> "Category": ...
    def _without_axiom(self, axiom: str) -> "Category": ...
    def _without_axioms(self, named: bool = False) -> "Category": ...
    @staticmethod
    def _sort(categories: Iterable["Category"]) -> Tuple["Category", ...]: ...
    def __and__(self, other: "Category") -> "Category": ...
    def __or__(self, other: "Category") -> "Category": ...
    @staticmethod
    def join(categories: Iterable["Category"], as_list: bool = False, ignore_axioms: Tuple[str, ...] = (), axioms: Tuple[str, ...] = ()) -> Union["Category", List["Category"]]: ...
    def category(self) -> "Category": ...
    def example(self, *args: Any, **keywords: Any) -> Any: ...

def is_Category(x: Any) -> bool: ...
def category_sample() -> Tuple["Category", ...]: ...
def category_graph(categories: Optional[Iterable["Category"]] = None) -> Any: ...

class CategoryWithParameters(Category):
    def _make_named_class(self, name: str, method_provider: str, cache: bool = False, **options: Any) -> Type: ...
    def _make_named_class_key(self, name: str) -> Any: ...
    def _subcategory_hook_(self, C: "Category") -> Union[bool, Unknown]: ...

class JoinCategory(CategoryWithParameters):
    def __init__(self, super_categories: Iterable[Category], **kwds: Any) -> None: ...
    def _make_named_class_key(self, name: str) -> Tuple[Any, ...]: ...
    def super_categories(self) -> List[Category]: ...
    def additional_structure(self) -> None: ...
    def _subcategory_hook_(self, category: Category) -> bool: ...
    def is_subcategory(self, C: Category) -> Union[bool, Unknown]: ...
    def _with_axiom(self, axiom: str) -> Category: ...
    def _without_axiom(self, axiom: str) -> Category: ...
    def _without_axioms(self, named: bool = False) -> Category: ...
    def _cmp_key(self) -> None: ...
    def _repr_object_names(self) -> str: ...
    def _repr_(self, as_join: bool = False) -> str: ...
